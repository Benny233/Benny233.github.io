{"meta":{"title":"Benny's Notebook","subtitle":"","description":"","author":"Benny","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-06-06T10:05:44.000Z","updated":"2018-06-06T10:05:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"gallery","date":"2018-06-06T10:04:39.000Z","updated":"2018-06-06T10:04:39.000Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""},{"title":"timeline","date":"2018-06-06T10:06:07.000Z","updated":"2018-06-06T10:06:07.000Z","comments":true,"path":"timeline/index.html","permalink":"http://yoursite.com/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"iterm快捷键总结","slug":"iterm","date":"2018-06-04T15:38:02.000Z","updated":"2018-06-14T02:56:42.000Z","comments":true,"path":"2018/06/04/iterm/","link":"","permalink":"http://yoursite.com/2018/06/04/iterm/","excerpt":"","text":"iterm2的快捷键总结 标签新建tab：⌘ + t 切换 tab： ⌘+←, ⌘+→ ​ ⌘+{, ⌘+} ​ ⌘ + Num 切换全屏：⌘ + enter 关闭tab：⌘ + w 分屏切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分； 切换Tab中的pane：⌘ + [ / ] 按方向切换 pane：⌘+Option+方向键 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原 关闭panel：⌘ + w 全局智能查找，支持正则查找：⌘+f 全屏展示所有的 tab，可以搜索：⌘+Option+e 自动填充：⌘ + ； 命令补全提示 打开最近目录： ⌘ + alt + / 窗口太多，快速定位到光标所在位置：⌘ + / 鼠标所在行高亮显示： ⌘ + alt + ； ⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作 ⌘+Shift+h弹出历史记录窗口 快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了 双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。 按住⌘键可以拖拽选中的字符串 可以点击 url：调用默认浏览器访问该网址 可以点击文件：调用默认程序打开文件 如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行 点击文件夹：在 finder 中打开该文件夹 标记设置标记：⌘ + shift + m 跳转到上个标记：⌘ + shift + j 多个标记切换：⌘ + shift + arrow(上下) 其他置空屏幕: clear ​ ctrl + l ​ ⌘ + k 清空屏幕: command + k/r 字体调大: command + + 字体调小: command + - 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 从光标处删至字首/尾：ctrl + w / k","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"区块链架构","slug":"区块链架构","date":"2018-05-26T14:47:23.000Z","updated":"2018-06-14T02:56:59.000Z","comments":true,"path":"2018/05/26/区块链架构/","link":"","permalink":"http://yoursite.com/2018/05/26/区块链架构/","excerpt":"","text":"基本定义这里有一段很好的关于架构的讲述，就不完整的抄了 架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构、组成的组件以及组件之间的关联关系。动态层面主要规范组件的行为以及组件之间的交互协议。根据系统的架构，可以界定系统的功能特性和非功能特性。功能特性是特点，非功能特性是不可缺少的共性部分。 架构设计要考虑不断变化和恒久不变的两方面。 一个有长久生命力的系统都有一个设计高明的架构，其精髓在于架构能支持系统功能的变化、发展、演化，允许系统功能不断变化，也就是架构必须提供灵活性。 而系统对易用性、安全性、稳定性和性能却应该是恒久不变的，因此IT架构的设计必须强调非功能特性，其中 开放性 可扩展性 可移植性 可维护性 灵活性 安全性 性能(响应时间、吞吐率、并发数) 1.0 例如比特币，支撑虚拟货币应用，也就是与转账、汇款和数字化支付相关的密码学货币应用。 2.0 2.0支撑智能合约应用，合约是经济、市场和金融的区块链应用的基石。2.0应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。 3.0 超越货币、金融和市场的范围的去中心化应用，特别是在政府、健康、科学、文化和艺术领域的应用。 比特币架构比特币前端钱包保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。 签名、钱包加密、备份、密钥导入、导出。 钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。 非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。 决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。 根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。 移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。 桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易 互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。 纸钱包，字面意思 HTTP/JSON RPC APIAPI，给外部提供查询余额，支付和转账的接口 命令行工具bitcoin-cli基于API开发的命令行工具 比特币浏览器bx比命令行工具更强大的工具 图形开发工具Qt比特币核心是Qt开发的，是比特币使用最广的客户端 比特币节点后端比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。 区块链管理区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。 下载区块链，先下区块头，再并发下载区块体 接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。 区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了 重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易区块验证比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。 脚本是基于堆栈的一些命令。 内存池管理mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。 内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。 邻节点管理当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。 发现邻节点的方法。 用DNS种子查询DNS。比特币核心带有5个DNS种子 把一个已知的邻节点作为种子节点。共识管理比特币的关键是在陌生P2P环境监理共识机制。 比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。 比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。 规则管理比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理 密码模块crypto模块主要是处理比特币地址。 私钥产生公钥。公钥经过几步产生地址 SHA256哈希处理 RIPEMD160哈希处理得到一个160位的结果 Base58Check编码 Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误 签名模块比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。 secp256k1曲线比其他曲线具有更高的性能。 脚本引擎基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。这样设计是不希望矿工有能力提交一个可能有死循环的脚本。 比特币作为一个虚拟货币系统，这样的设计已经足够。 挖矿中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。 CPU&gt;GPU&gt;FPCA&gt;ASIC HTTP/JSON RPC 服务端提供接口来控制比特币节点 Berkeley DB和LevelDB数据库Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。 LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。 P2P网络管理在P2P网络上实现和其他邻接点的通信功能 ZMQ队列管理采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。 以太坊架构核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。 账户设计两种账户。外部所有账户EOA和合约账户。 以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。 合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。 区块链设计Merkle Patricia树 PoW机制Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。 计算和图灵完备EVM高级语言以太坊P2P网络节点间使用RLPx协议，Dapp间用Whisper协议 事件合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。 3.0 超越货币，金融范围的区块链应用超宇货币和金融范围，特别是政府、健康、科学、工业、文化和艺术的应用支持广义资产、广义交换、支持行业应用。支持行业应用意味着具备企业级属性。其中安全性最突出。同时对网络和共识算法的性能、每秒交易数TPS都有比较高的要求。可以不是完全去中华的架构，最有可能是在不同场景下的混合架构。 通用架构典型应用自动化采购智能化物联网应用供应链自动化管理虚拟资产兑换、转移产权登记互联链架构剖析不同链的价值转移","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"共识算法详解","slug":"共识算法详解","date":"2018-05-26T12:14:43.000Z","updated":"2018-06-14T02:57:00.000Z","comments":true,"path":"2018/05/26/共识算法详解/","link":"","permalink":"http://yoursite.com/2018/05/26/共识算法详解/","excerpt":"","text":"共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点 共识算法的假设条件有以下几种， 故障模型： 非拜占庭故障/拜占庭故障 通信模型： 同步/异步 通信网络连接： 节点间直连数 信息发送者身份： 实名/匿名 通信通道稳定性： 通道可靠/不可靠 消息认证性： 认证消息/非认证消息 由于应用场景的不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，私有链和联盟链对一致性、正确性要求更高，一般采用强一致性的共识算法。公有链对一致性和正确性通常没法做到百分之百，通常采用最终一致性Eventual Consistency的共识算法。 拜占庭容错技术拜占庭将军问题拜占庭容错系统实用的拜占庭容错系统Raft协议Raft基础leader选举记账过程PoW一句话解释，根据投入的算力来选择记账节点 会导致算力浪费 穷举法找到一个符合要求的哈希值。 工作量证明函数区块难度值PoW的过程基于PoW的共识记账关于比特币PoW能否解决拜占庭将军的问题PoS一句话解释，根据拥有的货币数量来算则记账节点 会导致中心化 用户证明拥有某些数量的货币(即对货币的权益) PoS的应用点点币结合币龄 随机区块选择NXT和blackcoin采用随机方法预测下一合法区块，使用公式查找与权益大小结合的最小哈希值 基于权益速度的选择Reddcoin引入权益速度证明，即鼓励钱币的流动而非囤积。通过给币龄引入指数衰减函数，使得币龄不会超过2币月 DPoS股份授权证明机制 Delegated Proof of Stake,期望通过引入一个技术民主层来减少中心化的负面影响 持股人投票选出见证人。见证人按序生成区块。 Ripple共识算法基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。 参与投票节点的身份是事先知道的，因此算法的效率比PoW高，交易的确认只需要几秒钟。这点也决定了它只适合权限链。 容忍20%的拜占庭错误 Ripple的网络结构Ripple共识算法小蚁共识机制PoW、PoS、DPoS确定谁有记账权。小蚁侧重于解决如何限制记账人权利的问题。这种记账机制被称为中性记账。记账人只有选择是否参加的权利，而不能改变交易数据，不能认为排除某笔交易，也不能对交易排序。 总结PoW安全性和公平性强一些。PoS和DPoS更环保高效。 PoW和PoS比较适合公共链环境，PBFT和Raft适合联盟链和私有链的分布式环境。 比特币的PoW机制是一种概念性的拜占庭协议，能在一定程度上解决拜占庭问题，而PoS等其他机制 并没有严格分析其在拜占庭协议方面的属性。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"以太坊笔记","slug":"以太坊","date":"2018-05-25T10:12:03.000Z","updated":"2018-06-14T02:57:02.000Z","comments":true,"path":"2018/05/25/以太坊/","link":"","permalink":"http://yoursite.com/2018/05/25/以太坊/","excerpt":"","text":"以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。比特币没有账户的概念，只有UTXO。需要计算。 以太坊架构智能合约部署在以太坊虚拟机上，通过虚拟机和RPC接口和底层区块链进行交互 核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。 账户设计两种账户。外部所有账户EOA和合约账户。 以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。 合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。 区块链设计Merkle Patricia树 PoW机制Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。 计算和图灵完备EVM高级语言以太坊P2P网络节点间使用RLPx协议，Dapp间用Whisper协议 事件合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。 以太坊技术以太坊核心概念EVM由许多互联的计算机组成。程序按照EVM定义的方式运行在其上。任何人都可以为所有权、交易格式和状态转换函数创建商业逻辑 账户两类账户，公用一个空间地址。 外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。 合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含四个部分 随机数，用于确定每笔交易只能被处理一次的计数器 账户目前的以太币余额 账户的合约代码（如果有的话） 账户的存储（默认为空） 消息类似于比特币的交易，主要有3点不同： 以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建 以太坊消息可以选择包含数据 如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念 交易指存储从外部账户发出的消息的签名数据包。交易包含： 消息的接受者 用于确认发送者的签名 以太币账户余额 要发送的数据 STARTGAS，通过需要支付的燃料来对计算步骤进行限制 GASPRICE，每一计算步骤需要支付给矿工的燃料 Gas每笔交易都会被收取一定数量的Gas，其目的是限制交易执行所需要的工作量，同时为交易的执行支付费用。 存储、主存和栈每个账户都有一块永久内存区域，成为存储，key-value形式。存储的读写开销比主存和栈大。合约只能对自己的存储进行读写。 第二个内存区叫主存，合约执行每次消息调用时都有一块新的被清除过的主存。 EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈的区域内执行。 指令集EVM指令集被可以保持在最小规模，以尽可能的避免可能导致共识问题的而错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作还有条件跳转和无条件跳转。 此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 消息调用合约通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，目标，数据负载，以太币，Gas和返回数据。 事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会一次产生更多的消息调用。 代码调用和库callcode是一种特殊的消息调用。加载来自目标地址的代码将在发起调用的合约上下文中运行。用来实现库。 以太坊状态转换一个交易发生时，从一个状态转换到下一个状态 以太坊客户端go语言客户端Geth 客户端浏览器Mist 以太坊智能合约智能合约由尼克萨博提出，几乎与互联网同龄。但一直没有可信的执行环境，以太坊首先实现了区块链和智能合约的完整契合。 以太坊这方面的特性有： 图灵完备性 价值意识(value-awareness) 区块链意识(blockchain-awareness) 多状态开发语言以太坊有四种专用语言： Serpent(Python) Solidity(Js) Mutan(Go) LLL(Lisp) 图灵完备，可以解决所有的计算问题。但是半图灵完备，因为通过对计算量设置上限来避免图灵完备语言的无法停机的问题。 代码执行以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的。可以访问三种存储空间。 堆栈 内存，可无限扩展的字节队列 合约的长期存储，一个秘钥/数值的存储堆栈与内存计算结束就重置，长期存储会保持。以太坊的去中心化应用什么是DappDapp由智能合约和客户端代码构成。类似于后端和前端。智能合约跑在区块链上。 应用举例","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"TDD笔记","slug":"TDD笔记","date":"2017-12-21T11:22:36.000Z","updated":"2018-06-14T02:57:04.000Z","comments":true,"path":"2017/12/21/TDD笔记/","link":"","permalink":"http://yoursite.com/2017/12/21/TDD笔记/","excerpt":"","text":"graph TD 需求提出--&gt;抽象出模型 抽象出模型--&gt;转化出测试用例 转化出测试用例--&gt;TDD:定义接口测试接口 抽象出模型--&gt;|not TDD|code TDD:定义接口测试接口--&gt;提交PR并讨论 提交PR并讨论--&gt;code code --&gt;整合 自己写测试的心得普通写代码就是直接撸，写成啥是啥，错了就改正确的写测试就是 先想好接口，根据接口来写测试用例，最后再写代码去通过测试这就叫谋而后动 今天跟了一个测试教程学会了测试语言describe it before after(mocha) expect(supettest) 在egg中写测试这是应用的单元测试，不是插件和框架的单元测试 内置的egg-bin模块，这个模块已经内置了所有测试所需要的好用的模块。包括：Mocha、co-mocha、power-assert，istanbul测试mock辅助模块egg-mock 第一步，编写测试基础讲解第二步 配置测试在==package.json==中配置==script.test== { &quot;scripts&quot;:{ &quot;test&quot;:&quot;egg-bin test&quot; } } 第三步 启动测试npm test 打开TDD的正确姿势 TDD是什么tested dirven development,测试驱动开发 TDD的核心做好需求分析和设计，将==需求==拆解 为什么要测试，什么时候测试因为错误不可避免，要排除错误减少损失测试越早越好，因为错误绝大部分错误是在早期引入的，发现在中后期错误造成的损失随着时间呈现指数级的增长，越早发现，成本越低。这是软件测试的作用 测试驱动开发的作用：测试是根据需求来的，测试用例就是各个需求点，只要通过测试，模块的行为就能确保正确。在修改的时候做测试也能确保没有修改出错误。 测试的概念单元测试：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。就是该部分能否正常工作 测试用例：进行单元测试使用的例子 单元测试不通过说明要么有bug，要么测试用例不正确 测试正确说明，对该函数的修改没有对原来的行为造成影响。 测试驱动，是测试的什么？测试个模块的接口检验是否满足规定的需求，找出与预期的差异 测试效果的指标提高测试覆盖率，测试效率 测试的误区盲目追求覆盖率 测试的工具mochamocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。 使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。 mocha的特点主要有： 既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一； 可以自动运行所有测试，也可以只运行特定的测试； 可以支持before、after、beforeEach和afterEach来编写初始化代码。 describe包裹it们 第一个参数是测试的名字 第二个参数是一个函数，函数里是it it是各个测试用例 第一个参数是测试用例的描述 第二个参数是一个函数，函数体就是测试的内容，assert们 supertest网络测试构造请求，expect断言 判断回复 node自带断言库 assert如何写好测试所有人都假设TDD以后软件质量一定提高到最高境界了，但是测试代码也是代码，也有合理不合理的问题，也有价值与维护成本，不好的测试代码会降低效率那么如何写好测试代码呢 测试的核心是“可测试“，可测试意味着好的代码架构，写出可测试代码是优良测试的必要条件。 测试驱动开发不是测试人员驱动。这种开发方法完全是开发人员自行实施的，要点在于开发功能之前先开发该功能的测试程序，当然一开始测试程序的结果是失败的，然后去实现功能，让测试结果成功通过测试驱动也不是测试驱动项目运转 因为国内大多数程序员写的代码粒度太粗，无法测试。 编写测试的原则是，一次只测一种情况，且测试代码要非常简单。 TDD和时间的关系 如果时间够，自然可以TDD。如果时间不够，有人可以tdd，测试先行，不代表真的要先写测试。tdd像一种工具或者流程，其背后有它自己的思维，掌握了思维，没有按流程出招，或许就表示tdd已死了吧。如果楼主是指形式或者招式，那么其在某些情况下还是继续存活的。比如时间足够，而程序员足够热爱它 TDD只是一个概念，时间允许的话每个重要的方法业务都写单元测试，涉及正确性测试，边界测试，错误测试等等。之后代码有改动再跑单元测试就可以了。这样开发会节省挺多时间。 和时间的关系，写测试要消耗时间这是一个问题，很多公司的迭代周期比较短，比如半个月。那么如何搞TDD呢 TDD的好处 TDD好处其实很简单： 帮你整理需求 帮你设计接口（空想的话很容易设计出屎） 帮你做regression和给以后重构做准备 提高程序健壮性 TDD会鼓励你对现有代码，更频繁，更敏捷地进行改变它带给你的是，更少的regression，更少的debuggingtime，以及更多的勇气来refactor 是tdd重新让我编程的信心和乐趣。我不爱用眼睛看检查运行结果，只要改动之后，一运行看到一长排的勾我就去冲杯香飘飘喝吧喝吧，喝了睡觉去了 过度测试是存在。但一些看似过度的testmethod确实揪出了bug。国内中小公司(没去过大公司，不知道啥情况)从上到下对测试总是抗拒的态度。他们会迷惑如何在需求变更中控制缺陷，却不愿试着作任何改变。整天鼓吹熬夜搬砖的人是没法沟通的:(。所以总是测试不够，而非过度 要会单元测试，没有deadline的威胁，就是时间要足够适合思路发散常常迷糊的人，让人有安全感，能确定想法落实了可以灵活一些，比较高层的feature在确保接口可测试的前提下，没必要完全tdd。 TDD是否已死先不说，很多程序员连写出基本的整洁代码都做不到，还能指望他先写测试吗？写代码绝对是个技术活，而不是体力活。所以，写代码需要不断修炼，比如code dojo, code kata 至于是否用TDD方式写代码，倒不一定。如果程序员的思维转变，写代码之前先考虑到测试用例、测试场景，也是一个很大的转变，即测试先行。 我觉得TDD不火的原因是它对developer的素质要求非常高。新手看到TDD会欢欣鼓舞，但是他们没有能力来实践。老手们在项目的压力下，早就麻木了，先写case还不如写好代码再补case呢，很多东西我还没时间想清楚，怎么写case？不如先写个小功能先，边写边改，等稳定下来再补case. 所以对老手来说也需要不断练习，才能熟悉TDD. 其实我们的目的是为了快速的交付有价值，有质量的产品或者服务，赢得公司的生存和发展空间。为了达到这个目的，我们有很多种的手段。但手段不是目的。有很多盲目推崇TDD的所谓敏捷专家，其实是把手段当做目的，而忽略了问题的本质 首先理清一个价值观问题，是方法论为生产力服务还是生产力为方法论服务TDD的错误在于，他没有尊重程序员尊重开发实际，让非生产代码通知生产代码 TDD 力量和问题都源自 test first。要能 test first，写代码之前要想得更清楚；代码得要有良好的可测试性，而为了可测试性要做一些不直接产生效益的工作；两者都既能推动思考，也能限制思考。TDD 是正确的思想：程序员要保证代码的正确性，和不完美的实践：程序员写测试。 目前我们团队也在想办法推行TDD，但是不是标准的TDD，而仅仅是测试先行，并且不用mock这样做可以在实现业务代码之前对于自己的程序要实现什么有一个清晰的认识，而且写程序的过程也变成了“跑通我的单元测试”的过程，这样更加有目标和针对性，当你看到你写完的业务代码能跑通单元测试的时候，是否有种游戏过关的成就感呢？等到全员都逐渐适应这种测试先行的做法，再“得寸进尺”，多要求一点点。 测试先行，怎么和开发做交互呢？什么时间调用开发的方法？测试先行是说在实现业务逻辑前先写完单元测试，此时的单元测试肯定不通，之后再逐渐针对测试完善业务代码，最后跑通测试的时候业务代码也就完成了。不是让测试人员先测的意思 TDD解决了：1）我要开始写代码了，我从哪开始。 搞个main，还是搞个test2）我不知道那个家伙的代码写的怎么样，以后会不会捅个篓子，要求他TDD好了。CodeReview的时候也轻松点。飞机上写几个小时代码，下来编译一遍过还没有bug的人。你跳出来说，他没有tdd，他LowB，那你是不是有毛病。总之一句话，各种方法论都是解决一个问题——人不行。 软件开发说到底还是抽象和逻辑的艺术，TDD只是一种辅助开发手段，并不会减少因为开发人员素质不过硬或者工期短赶工而在开发过程中产生的抽象和逻辑问题。从来没听说过历史上哪位编程高手是因为什么方法论而练成的，人家是数据结构、算法、抽象和逻辑能力真的强大。对了，除了TDD，那什么敏捷、XP、结对、DDD等等，所有抛开实际抽象和逻辑问题的方法论，都是垃圾。 更重要的是 基础的是 数据结构算法 抽象 逻辑能力 TDD在什么情况下最有效？ 一个老系统， 老系统有还不错的test case 有很多相关系统依赖老系统 老系统要推翻重做 先阐明观点，TDD没死，只是存活着在一些技术及配合要求比较高的团队，并且是挑业务的。我在互联网行业摸打滚爬了蛮久，历经各种项目，包括PC、游戏、云存储、电商等项目，TDD也是我这几年年一直在推动的事情，大部分失败了，也有些收获，这里大致把所了解以及个人见解说下。拿我所熟悉的互联网行业来说吧，其他传统软件行业经历时间太早，离当前较远，就不乱说了。现在互联网大都流行敏捷开发，其模式大家可自行度娘，但是真正做到的貌似没有，最少我没见过或者听过，很难用定性的词语来形容（语文不好），用个相似度来说吧，当前BAT公司排序为BTA（还是个人见解），用我个人的说法就是作坊式开发，忽略很多流程，只留下骨干的评审、开发、用例评审、转测、回归发布的流程。这个模式特点就是快，从需求提出到发布上线，一般都是一两周的时间，现有三周才能开发完成的业务。当然这里也有提出异议，说我太片面了，不过我说的大部分的互联网公司业务，保守估计60%的比例吧。解释完了互联网公司的开发模式，接下来我们回到TDD，至于TDD的概念，我就不科普了，自行度娘。其中TDD有一个特点非常明确，基本上可以作为是否做到的标签。这就是测试架构先于开发完成，并可对开发完成大部分模块进行测试（个人的理解，标准定义自行百度）。为了达到这个目的，我们搬出几个要素出来：时间、人、效果、方式。时间：什么时候完成，项目时间大约多久可以做TDD，TDD占项目时间大约多少比例合适。人：谁来做，一个人的项目我这里不谈，只谈多人协作项目，开发做还是测试来做？效果：要达成什么效果，以什么为合格的TDD的指标，功能覆盖？代码覆盖率？方式：要怎么做，开发一套自动化框架，还是用先协商接口用单测来完成，这里特别要提出的是，需要考虑后期维护的代价。 TDD 推行的最大问题在于，大多数程序员还不会「写测试用例」和「重构」。我认为推行TDD主要在两个方面努力，即意识和能力（好像任何事情都是这两方面哈）。意识方面主要是：认识到自己原有编程方法的不足；搞清楚TDD的价值所在，如何弥补原有方法的不足；心态开放，勇于尝试新鲜事物，不要浅尝辄止，要持续改进。意识和能力没有先后关系，而是在不断学习和实践过程中同时提高。在这篇文章中，我更想谈的是能力。我见到初接触TDD的人常犯下面的错误：在声明测试方法后，便开始写实现代码；写完“所有”的测试代码才开始写实现；一次实现过多的代码（超出当前测试覆盖的业务）；从不重构；测试实现细节而不是接口行为；TDD真是看起来容易，做起来难。 graph LR Red--&gt;Green Green--&gt;Refactor Refactor--&gt;Red 上面这个图一目了然，但其实每一步都是对能力有要求的：红测试先行并不是说不需要思考，直接开始写代码。在开始写代码之前要进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断循环去实现。测试代码其实是产品代码的“用户”，在写测试代码时你就要考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实我们就是在做设计，而且设计以代码来体现，比在脑袋中空想要更直观。很多人不懂“意图式编程”，总是习惯先实现一个东西，再去调用它。而测试先行就要求先使用，再实现。这样能少走很多弯路，减少返工。无法把测试前置的原因往往在于，测试的是「实现」，也就是你写的是「白盒」测试。这样的测试根本没有价值，重构的时候会成为维护负担。而好的做法是测试「做什么」，而不是「怎么做」。绿以最快的速度让测试变绿，意味着我们通常用最直接但可能并不优雅的方式，比如复制代码。然后小步重构，直到符合简单设计的原则：通过所有测试每个概念都被清楚地表达没有重复没有多余的东西难的是要让实现刚好满足当前的测试，不做过度的设计，不写多余的代码。因为如果你写多了，除了引入复杂性以外，多的那部分就没有测试能覆盖到。或者你后面的测试写出来就能直接变绿，你就没办法按TDD的节奏进行下去了。重构首先要能识别坏味道，一些低级的Smell，很容易识别，比如：Magic Number，重复代码，太大的类，太长的方法，命名等。但更高级的如Feature Envy，Lazy Class等就比较难以识别。只要识别到Smell，知道用什么手法去重构，剩下的就比较简单了，现代的IDE，尤其是JetBrains的产品，对重构的支持非常强大，几乎都可以用快捷键完成。选对工具非常重要，善假于物能极大提高开发效率。但也不能过分依赖工具，要明白每一个手法背后的原理。所以推荐每个想要实践TDD的开发者，一定要先读《重构》。最后我想说：TDD不是银弹，不可能适合所有的场景，但这不应该成为我们拒绝它的理由。也不要轻易否定TDD，如果要否定，起码要在认真实践过之后。 TDD教程总览 TDD的理解和讲解 基线描述 能够讲出来科学的TDD步骤，和TDD的三个主要的状态掌握mock技巧，能够讲出几种mock的场景了解SetUp的作用会写TestCase给出题目可以驱动着写出来细节如下： 能够讲出来科学的TDD步骤，和TDD的三个主要的状态 正确的TDD的步骤至少包含下面的几个点，写一个TestCase，运行，得到期望的失败，写实现，重构","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"基础数据结构","slug":"基础数据结构","date":"2017-12-21T11:21:07.000Z","updated":"2018-06-14T02:56:38.000Z","comments":true,"path":"2017/12/21/基础数据结构/","link":"","permalink":"http://yoursite.com/2017/12/21/基础数据结构/","excerpt":"","text":"数据结构，数据存储的方法，包括数据对象，和操作集，不包括具体实现。具体实现是算法 数组检索简单，增删难 集合Set，不重复的数组 链表增删简单，检索难。插入删除内存和时间消耗小，查询消耗大，适合插入多，查询少的情景 广义表：是线性表的推广，元素可以是另一个广义表 多重链表：节点可能属于多个链表，双向链表不是多重链表。树和图就是用多重链表实现 稀疏矩阵用多重链表存储。 栈先进后出 表达式求值，递归，函数调用，深度优先搜索，回溯算法 具有一定操作约束的线性表 栈的实现一维数组和一个记录栈顶元素位置的变量 链表实现，从头部插入 队列也是一种受限制的线性表，先进先出 普通线性表在所有位置都可以增删，堆栈只在顶部增删，队列只在头尾增删 用链表实现的时候，因为链表的尾部不能执行删除操作，所以队列的头部只能是链表的头部 典型问题 优先队列 循环队列","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"算法笔记","slug":"算法笔记","date":"2017-12-21T11:20:45.000Z","updated":"2018-06-14T03:01:04.000Z","comments":true,"path":"2017/12/21/算法笔记/","link":"","permalink":"http://yoursite.com/2017/12/21/算法笔记/","excerpt":"","text":"复杂度计算时间复杂度的方法数循环次数：循环的嵌套 均摊分析：(1+n)/2，一次性的操作平均到整体 递归式:主定理 常见的时间复杂度1:基本运算，+,-,*,/,%,寻址 logn：二分查找 根号n:枚举约数，少见 n:线性查找，很多时候算法的下限就是n，因为数据的读入的复杂度就已经是n了 nlogn：归并排序，快速排序的期望复杂度，基于比较排序的算法下界 n的平方：朴素最近点对，冒泡排序，选择排序 n的三次方：Floyd最短路径，普通矩阵乘法 2的n次方：枚举全部的子集 n的阶乘：枚举全排列 排序算法搜索算法","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"cs总结","slug":"cs总结","date":"2017-12-21T11:20:37.000Z","updated":"2018-06-14T02:56:48.000Z","comments":true,"path":"2017/12/21/cs总结/","link":"","permalink":"http://yoursite.com/2017/12/21/cs总结/","excerpt":"","text":"基础熟悉# 列表解析 result = (item.value for item in array when item.name is &#39;test&#39;) # 前十个全局属性(变量) globals = (name for name of window)[0...10] # 对象解析 ages = for key, value of Object &quot;#{key} is #{value}&quot; # 定义函数 square = (x) -&gt; x * x # body... # 定义的时候有括号，调用的时候没括号 # 数组 song = [ &#39;do&#39; &#39;re&#39; &#39;mi&#39; &#39;fa&#39; &#39;so&#39; ] # 对象 singers = brother: name:&#39;max&#39; age:11 sister: name:&#39;ida&#39; age:9 s-sister: name:&#39;haha&#39; age:2 # if else if one and/or/is/not two # body... else # body... # 三元判断 date = if one and two then value else other # 函数链式调用 $ &#39;body&#39; .click (e) -&gt; $ &#39;.box&#39; .fadeIn &#39;fast&#39; .addClass &#39;show&#39; .css &#39;background&#39;, &#39;white&#39; # 回调写法和胖箭头函数 Account = (customer,cart) -&gt; @customer = customer @cart = cart $(&#39;.shapping_cart&#39;) .on &#39;click&#39;, (event) =&gt; @customer.purchase @cart # promise写法 sleep = (ms) -&gt; new Promise (resolve) -&gt; window.setTimeout resovle,ms # async写法 直接写在普通函数里，阻塞的执行 # 类的写法 class Animal constructor: (@name) -&gt; move:(meters) -&gt; alert @name + &quot; moved #{meters}m.&quot; # body... 命令行编译命令， coffee -c -o targetfolder filename 先是两个参数，然后是目标文件夹，最后是编译的文件 数组 数组换行可以省略一个逗号，那就都换行吧，彻底抛弃逗号 直接加尾巴截取数组，还可以直接用来赋值[0...10] 对象 对象的花括号用缩进代替 函数函数的区别， 定义的时候有括号，调用的时候没括号,调用的时候没有参数也需要括号 函数没有大括号，用箭头识别，箭头左边小括号里放参数，右边是函数体 函数默认返回函数体最后一个表达式的值，可以省略return 空return取消return 变量不需要声明，所以函数名也不需要声明 默认参数 胖箭头函数，作用只是绑定this？ 需要返回一个绑定this的函数的时候使用 async函数直接把await写在普通函数里 词法作用域和变量安全词法作用域变量安全 函数的所有 CoffeeScript 结果都被一个匿名函数包裹 (function(){ ... })(); 这层安全的封装, 加上自动生成的 var 关键字,使得不小心污染全局命名空间很难发生. 因为被包裹了，用顶层变量, 需要将其作为赋值在 window 上, 或者在 CommonJS 里的 exports 上. 存在操作符(existential operator)可以帮你写出一个可靠的方式找到添加位置; 比如你的目标是同时满足 CommonJS 和浏览器: exports ? this4. 判断语句 一个判断一个赋值的判断简写 name = value if condition 普通写法,和js相比就是省略了条件的小括号和函数体的大括号 三元判断符 name = if condition then rightvalue else wrongvalue unless: 不是… ，就执行，是就跳过 return 哈哈哈 unless 嘿嘿嘿 //如果不是嘿嘿嘿，就返回哈哈哈 //如果是嘿嘿嘿，就跳过往下执行 //作用：满足嘿嘿嘿才能往下执行 //干嘛不用if？ if else 和unless都可以，看个人喜好 变参变参函数定义,参数后加上… 变参函数调用,函数调用后加上… 循环和推导式for in遍历数组item-operation for item in 数组 两个参数 for in 循环的参数，第一个是值，i是index 加上判断 item-operation for item in 数组 when item isnt value by控制循环的跨度 for of 遍历对象#遍历所有键值对 ages = for key,value of yearsOld &quot;#{child is #{age}&quot; #遍历自有非继承键值对 for own key,value of yearsOld #遍历gegerator用from while和until# 满足条件就一直执行 buy() while supply &gt; demand # 满足条件就不执行了 sell() until supply &gt; demand for in + do配合起来，对每一个满足条件的元素执行操作 alias CoffeeScript JavaScript is === isnt !== not ! and &amp;&amp; or ture,yes,on true false,no,off false @,this this a in b [].indexOf.call(b,a) &gt;=0 a of b a in b for a form b for (a of b) a ** b Math.pow(a,b) a // b Math.floor(a/b) a %% b (a % b + b) % b 存在性操作符?name # 只要不是null或者undefined就返回true speed ?= 15 # 当speed为null或者undefined的时候执行赋值 自己的总结 没有冒号 没有括号，用换行和缩进控制层级 数组的省略写法 编译之后给module.exports外面套一层自执行函数对导出模块没有影响 if判断里面没有默认return 问题控制返回值，不想让它包裹一层然后返回，可以写return 那么对async函数有影响 资料coffeescript编码风格指南 不喜欢的地方 关于语义化的思考 调用函数的时候，前面一个参数较复杂，后面一个参数需要仔细辨别，没有括号直观3.","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[]},{"title":"设计需求分析与方案选择","slug":"设计需求分析与方案选择","date":"2017-12-21T11:01:49.000Z","updated":"2018-06-14T02:56:03.000Z","comments":true,"path":"2017/12/21/设计需求分析与方案选择/","link":"","permalink":"http://yoursite.com/2017/12/21/设计需求分析与方案选择/","excerpt":"","text":"设计师的基本思路是，解决了什么问题，为什么要这样解决 了解问题比提供解决方案重要 设计方案不能令人满意的原因 没有细致的沟通==业务需求==，一直改方案，没有自己的观点 没有仔细的分析==用户需求==，只是简单的进行页面排版 没有对==用户体验路径==进行仔细分析，缺乏一个好的方式引导用户使用 业务需求 = 业务目的 + 业务目标业务目的：为什么要做这块业务，当中存在哪些问题业务目标：做了这块业务之后，产品期望得到怎样的结果 用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标谁在什么时候有什么样的行为，目标是什么 用户体验路径搞清楚用户在使用前，使用中，使用后的各个接触点，确保设计方案能够形成闭环 需求分析四步一 分析业务需求业务需求 = 业务目的 + 业务目标业务目的：为什么要做这块业务，当中存在哪些问题业务目标：做了这块业务之后，产品期望得到怎样的结果 目的是达到了某个目标之后想要做的事情，也就是实现目标的真正动机 例： 业务需求 业务目的 业务目标 注册 通过登记用户信息，以方便产品进行用户管理 提高注册页面的转化率 提供用户注册是一个业务需求，提高注册转化率是它的业务目标。当我们提高了注册转化率，就能获得更多的注册用户数，从而实现有效进行用户管理的目的。 互联网产品常见的目标（提升/降低） 类别 常见目标 产品类 PV，UV，用户数，转化率，留存率，活跃度等等 市场类 传播量，市场份额，各种排名等 品牌类 服务认知，品牌认知，品牌忠诚度等等 营收类 销售量，销售额，利润率，ROI等等 制定具体的目标时，要符合smart原则S:specific，具体M:measurable，可衡量A:attainable，可实现R:relevant，有关联T:time-based，有时限 没有目标导致的结果 方案的讨论容易发散 方案的评估缺乏评判标准 方案的效果无法衡量4. 了解目的和目标之后二 分析用户需求用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标谁在什么时候有什么样的行为，目标是什么 三 分解关键因素用户的动机，担忧，障碍 实现业务目标的关键因素 创造动机，促进用户行为 排除担忧，排除行为前的担忧 解决障碍，解决行为中的障碍 四 归纳设计需求，明确设计策略结果将业务目标，用户目标转化成有效的解决方案 技巧如何将==业务目标==转化为==用户行为==，即通过引导用户的使用来帮助产品实现目标 从设计==用户行为==到设计==用户界面==：用户行为决定了用户界面，用户界面页导致了用户会出现什么样的行为 如何选择解决方案","categories":[{"name":"产品","slug":"产品","permalink":"http://yoursite.com/categories/产品/"}],"tags":[]},{"title":"用户调研思考","slug":"用户调研思考","date":"2017-12-21T11:00:33.000Z","updated":"2018-06-14T02:55:35.000Z","comments":true,"path":"2017/12/21/用户调研思考/","link":"","permalink":"http://yoursite.com/2017/12/21/用户调研思考/","excerpt":"","text":"目的拿到小房东手里的房源信息 目标让更多的小房东使用我们的房屋租赁管理工具 问题 远一点这是一个怎样的市场 市场上的房子是什么样的？种类及比例 市场上的房东是什么样的？种类及比例 市场上的租客是什么样的？种类及比例 未来几年内，房子，房东，租客又是什么样的？ 目标用户手里有几套房的，自己运营的房东 这群人有多少？他们有多少房？直接决定我们能做成多大的平台。 个体户足够多才能形成平台，平台足够大才能吸引大房东。 了解这样的个体户。 问题 近我们的目标用户是什么样的人？手里有房子需要租出去的人 我们的功能帮助所有需要把房租出去的人解决问题 他们的数量这决定了我们的平台第一阶段能够有多大 用户画像 一房东，二房东 业余，全职 房子少，房子多 个人，团队 用过工具，没用过工具 学习能力强，不强 使用设备 常用APP 痛点，品牌偏好 不同的产品，用来描述用户的角度有所不同，即用户画像的内容纬度会有所不同 ==场景故事== 时间，地点，干什么 一般会有3~6个用户 ==用户画像==：通过用户的目标，行为，观点，基本信息等，对其真实特征进行勾勒，一般会得到3~6个画像/人物角色，每个画像代表一群真实的人 就像小说里的角色，都是作者观察生活总结出来的典型 画像之后调研比例，形成定量用户画像 他们的日常生活对于工具的需求如何？面向小房东的管理工具？房屋租赁管理的基本需求我们的工具能在多大程度上帮助他们总结这是一个4.6万亿的市场。有前景。","categories":[{"name":"产品","slug":"产品","permalink":"http://yoursite.com/categories/产品/"}],"tags":[]},{"title":"用研笔记","slug":"用研笔记","date":"2017-12-21T10:53:06.000Z","updated":"2018-06-14T02:55:47.000Z","comments":true,"path":"2017/12/21/用研笔记/","link":"","permalink":"http://yoursite.com/2017/12/21/用研笔记/","excerpt":"","text":"用户研究概述==用户研究员的能力==，技术技能和非技术技能 技术技能 用户研究能力 人机交互能力 产品分析能力 一，用户研究能力针对产品开发的不同阶段，能够灵活运用各种调研方法，权衡利弊，制定适合的用户研究方案 能够输出高质量的用户调研报告，为产品设计提出合理化建议 用户研究能力包括： 定量分析能力 定性分析能力 定量分析能力： 数据的敏感度 数据分析能力 可熟练使用各类定量研究方法 掌握各类定量研究方法的应用场景及优缺点 独立完成分析的能力 定性分析能力： 对常见定性研究方法，可熟练使用 对各个研究方法有自己的心得体会，掌握技巧 掌握各类定性研究方法的应用场景及优缺点 独立执行研究的能力 二，人机交互能力 熟练掌握人机交互的理论知识 熟悉掌握各终端设计规范 有良好的用户体验意识 可通过用户研究，发现产品设计中的不足，并能提供设计改善建议 三，产品分析能力 对所应聘行业非常了解，有充分准备 对所应聘行业的竞品非常熟悉 对所应聘部门的产品非常熟悉，并有自己的见解 有良好的产品感 热爱互联网产品，对于新兴产品有好奇心，保持对互联网产品的关注和体验 非技术技能 沟通技巧 好奇心 学习能力 敏锐力 用户研究方法论工作中会用到的知识与技能 一，基本研究方法 研究设计，采集工具 数据的获取：外部数据，内部数据 二，统计学知识 基础统计方法 高级统计学方法 数据挖掘（了解，可拓展学习） 基础统计分析主要方法 集中趋势 离散趋势 分布特征 推论统计 相关分析 适用场景 日常数据的初步加工分析 简单分析变量间关系 需要快速输出结果 进行简单分析 要求用研岗要求掌握，相关岗位建议掌握 高级统计方法主要方法 聚类 回归 主成分 因子分析 判别分析 对应分析 多维尺度分析 生存分析 路径分析 结构方程 适用场景 对数据进行深挖掘和分析 分析变量间的关系 趋势预测，用户细分等 要求用研岗要求掌握，相关岗位了解 数据挖掘方法主要方法 神经网络 决策树 适用场景 可实现实时，自动化分析 具备自适应和自学习性 要求拓展学习 三，数据分析思路及框架 常用的分析框架 基于理论的分析模型 比如： 宏观的行业分析框架 微观的分析用户需求 用户满意度 品牌认知 转化 留存的分析框架 四，分析工具及软件 Excel SPSS，专业数据分析软件，比Excel高阶 SPSS modeler， R语言， Amos（拓展学习），LISREL，Python 五，图表制作 基本图表制作 数据可视化 六，报告撰写及演示 PPT制作，演讲能力 七，行业及业务领域知识行业领域知识互联网，垂直细分行业知识 业务相关知识 产品经理 设计 运营 市场营销相关知识 专业知识 用户体验 经济学 心理学 社会学 市场营销等 八，数据洞察和落地 通过数据给出有用的建议 落地跟进 用户定位与需求分析用户研究的‘用户’是谁？用户的定义狭义的用户：产品的使用者 广义的用户还有业务方 用户研究的意义 graph TD a((业务方-所服务产品))--&gt;b((用户研究-桥梁)) b--&gt;c((用户方-产品的目标用户)) 不是简单的将用户的需求告诉业务方，而是要考虑业务方为什么要提供这个产品/功能 业务方也是有需求的 了解双方的需求 测试评估提升用户体验用户体验优化设计目的&amp;内容：使产品更好用易用，产生更大的用户价值 生命是数据分析案例分析：数据分析如何驱动体验优化==用户分群与追踪研究==用户行为来自于用户动机（目标） 用户使用我们的产品（用户行为）产生用户态度 当前时间点下的用户情况 用户画像例子，考霸族简单描述 人生阶段：毕业生 自驱力：强 基本信息姓名，职业，年龄，家庭状况，互联网使用习惯 个性特征学习目的学习习惯付费经历及态度用户画像方法简介 定性用户画像，简单快速 定量用户画像 方法选择的原则 选择定性还是定量取决于 用户画像的受众是谁？设计师?产品经理？ 希望用户画像结果来支持什么类型的决定 打算花多少时间和钱 用户画像的特点 越早越好，方向准确比行动重要 任何阶段都可以，任何阶段都有用，迟到比旷工好 不断迭代更新，用户会变化 从用户研究到商业分析用户研究为什么要学习商业分析 产品人要具有大局观理解用户只是基础，最终的目的都是创造商业价值，所以要懂商业分析 商业与用户价值的平衡豆瓣：过于重视用户体验而轻视商业发展 百度：过于重视商业发展而忽视用户体验 微信：取得用户体验和商业价值的平衡 在==正确的时机==找到产品在==商业价值和用户体验间的平衡点==至关重要 商业价值和用户价值的平衡就是 产品诉求和用户诉求的平衡 一名成功的用户研究员，需要研究和考量外部市场因素，驱动产品在商业价值和用户体验中取得平衡点 创业公司中人员配置的不完备","categories":[{"name":"产品","slug":"产品","permalink":"http://yoursite.com/categories/产品/"}],"tags":[]}]}