{"meta":{"title":"Benny's Notebook","subtitle":"","description":"","author":"Benny","url":"https://benny233.github.io"},"pages":[{"title":"timeline","date":"2018-06-06T10:06:07.000Z","updated":"2018-06-06T10:06:07.000Z","comments":true,"path":"timeline/index.html","permalink":"https://benny233.github.io/timeline/index.html","excerpt":"","text":""},{"title":"gallery","date":"2018-06-06T10:04:39.000Z","updated":"2018-06-06T10:04:39.000Z","comments":true,"path":"gallery/index.html","permalink":"https://benny233.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-06T10:05:44.000Z","updated":"2018-06-06T10:05:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://benny233.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"又又一个梦","slug":"又又一个梦","date":"2019-12-03T02:51:47.000Z","updated":"2019-12-03T08:15:11.446Z","comments":true,"path":"2019/12/03/又又一个梦/","link":"","permalink":"https://benny233.github.io/2019/12/03/又又一个梦/","excerpt":"","text":"昨天晚上从电影院回来，洗漱一下就早早上床躺着了，没看书直接睡，想要修正最近混乱的作息。然而，十一点，十二点，一点，两点，我越来越清醒了。甚至还有些激动，因为我想到一个女生了。感觉我和她特别合得来，不知道是不是我的错觉，想要找她确认一下。这样写看起来一点也不激动，实际上我连孩子叫什么都想好了。想着想着，我终于睡着了。做了一个梦，梦到的却是另一个女生。梦的内容忘记了，我们在嬉戏打闹来着，很开心很开心，所以才记得这个梦。 后来又做了第二个梦，我去了一个城市里的野生动物园。很多动物，大的，小的，凶猛的，温顺的。都是放养状态，没有围栏，游客也在里面。我旁边有头豹子，不咬人。稍远处有头杂色狼，也不咬人，但我很讨厌它，想过去揍它一顿。刚走几步，一头大狮子吼叫着蹦出来，它的设定是动物园里唯一的捕食者。周围的动物们都慌了，豹子首先夺路而逃，我也跑路了。跑到一个农田里，灰棕色的土地上有一排排灰棕色的作物，一个奶奶正在收割。旁边有个灌溉渠道，走过去的时候看见里面有只毛毛虫，深绿色，肥肥的，在蠕动，有蛇那么长。尾巴搭在田埂上像响尾蛇那样晃动。真尼玛恶心啊。这种厌恶应该是刻在基因里的，因为看到它的瞬间厌恶感就非常强烈。震惊，恐惧，恶心。把蛇和毛毛虫结合到一起，我真是个天才，恶心到家了。 睡醒前又做了第三个梦。一个小学时很讨厌的二流子过来挑衅，我抓起他的腿带着他旋转一圈，等把他转到高处再往地上摔。像小时候抓青蛙钓龙虾一样，可怜的青蛙被我们抓住了，并拢抓住两条岔开的腿，猛的往地上一摔，啪。青蛙的脑袋、内脏在瞬间受到剧烈的震荡，生命消逝了。没有约束的小孩子可能会很残忍，我不该那么对待青蛙，也不该那样对待同学。我应该盯着他的眼睛，用气势战胜他。毕竟打架是违法的，杀人要坐牢。 十点半终于清醒了，今天继续早睡，调整作息。","categories":[{"name":"写作","slug":"写作","permalink":"https://benny233.github.io/categories/写作/"}],"tags":[]},{"title":"又一个梦","slug":"又一个梦","date":"2019-12-01T09:51:47.000Z","updated":"2019-12-01T16:16:57.973Z","comments":true,"path":"2019/12/01/又一个梦/","link":"","permalink":"https://benny233.github.io/2019/12/01/又一个梦/","excerpt":"","text":"昨晚又多梦，其中一个是便携飞行器带着我在一个大工地里飞行。飞行器结构简洁，下面是圆柱状的手柄，上面是个小圆盘。和以往的飞行梦一样，我有点恐高。虽然很想飞高，但是不敢。工地上面垂下来很多线，我在这些线里小心翼翼的穿行，担心撞到工人或者其他。怕被骂。 从大工地飞出来一会儿就是一条弯曲的小河。从视野的左上方流入，在视野的中间拐一个大弯，再从视野的右上方流出。于是，我的梦里有了一个河湾，以及河两岸大片绿油油的菜园。 河湾突出的地方有一片干净细腻的沙滩，沙滩的边缘静谧地矗立着五座高矮不一蓝顶的白塔。塔身释放着柔和、梦幻的氛围，像古朴通透的玉。看到它的瞬间，我知道了它的名字，小蓝帽。 美好的景色就在眼前，关键我还能飞，那我肯定要飞到河面上去静静的感受、呼吸这美好。刚好前面有三个女生也要去，于是我们同行赏景。景色更美了。 把梦写下来的时候想起白塔从哪里来了。睡前看的书里提到，1891年芝加哥举办世界博览会，为此新建的建筑群叫做白城。它的墙面涂有黄麻纤维灰浆，干燥后酷似白色的大理石。 “成千上万参观白城的美国人自豪地感到，美国文化已经成年。它们正向世界表明，尽管美国文明乳臭未干，犹如吵吵闹闹的毛头小伙子，美国人照样有对永恒之美的憧憬” 这段在书的第一章，看完我就关灯准备睡了。可是最近睡眠习惯被我搅乱了，睡不着，于是我起来又跳着看了最后一章。它总结道，“1890年代的作家做了他们的工作，尽管他们做完了就都悄然逝去。这就是，他们开始使美国习惯于下列事实：一是，内在的分裂要比地理上的分裂来得大；二是，一种致力于商业和技术的文明为它自身建立了一种源自商业和技术的道德观；三是，性体验是普通人类环境的一个基本部分，而不是各种既定社会制度中一个讳莫如深的部分。” 这段总结触动我的地方之一是它的第三点，美国人在一百多年前就能够把性体验作为生活的一个基本部分加以讨论，而我对性还处于一种迷惑、矛盾的状态中。","categories":[{"name":"写作","slug":"写作","permalink":"https://benny233.github.io/categories/写作/"}],"tags":[]},{"title":"css基础","slug":"css基础","date":"2019-11-04T06:50:28.000Z","updated":"2019-11-04T06:50:57.442Z","comments":true,"path":"2019/11/04/css基础/","link":"","permalink":"https://benny233.github.io/2019/11/04/css基础/","excerpt":"","text":"简介语法选择器 属性声明； 属性声明 = 属性名：属性值； 属性值语法：比如 margin：[&lt;length&gt;|&lt;percentage&gt;|&lt;auto&gt;]{1,4} 包含三种 基本元素：length percentage auto 这些关键词 组合符号：[|] 这些符号 数量符号：1，4 1 基本元素 关键字 auto，solid，bold 类型 基本类型 length percentage color 组合类型 ‘padding-width’ color-stop 符号 / , 分隔属性值 Inherit, initial 2 组合符号 空格 必须有，且顺序固定 &amp;&amp; &amp;&amp; 必须有，顺序无所谓 || 双分隔符 underline||overline 至少出现一个 | 单分隔符 |transparent 只能出现一个 [] 优先组合 3 数量符合 数量符合 &lt;&gt; 只能出现一次 数量符号 + 能出现一次或多次 数量符合 ？ 可以出现，也可以不出现 数量符号 {} {2,4} 可以出现4次，最少出现2次 数量符合 * 任意次 空格隔开 数量符号 # 一次或多次 逗号隔开 @规则语法@media 设备满足条件，样式才生效 @keyframes 动画中间步骤 @font-face 引入外部字体 私有属性加前缀 选择器就是表达式，选中想要描述的标签 一、基本选择器 序号 示例 含义 选择器类型 特点 1 * 通用元素选择器，匹配任何元素 通用选择器 2 E 标签选择器，匹配所有使用E标签的元素 标签选择器 控制一类标签 3 .info class选择器，匹配所有class属性中包含info的元素 类别选择器 控制自定义的一类标签 4 #footer id选择器，匹配所有id属性等于footer的元素 id选择器 准确 5 [disabled]\\ [type=button] 具有某种属性，比如disabled。 id选择器是其特例 #footer{}=[id=button]{} 属性选择器 ~= 属性中包含，类选择器是其特例 .sports{}=[class~=sports]{} 属性 属性值首尾字符匹配，包含 属性 6 a:visited 标签加状态 伪类 实例： * { margin:0; padding:0; } p { font-size:2em; } .info { background:#ff0; } p.info { background:#ff0; } p.info.error { color:#900; font-weight:bold; } #info { background:#ff0; } p#info { background:#ff0; } 伪类选择器标签加状态 link，visited,hover,active disabled enable checked first-child nth-child(even) only-child 不常见： 伪元素选择器::first-letter {}第一个元素 ::first-line{}第一行 ::before {content: xxx} ::after ::selection 组合选择器规则后代选择器.xxx p{} 后代包括多级 子选择器.xxx&gt;p{} 子只有一层 兄弟选择器 h2+p{} 相邻兄弟选择器 选中h2标签后的这个p标签 h2~p{} 通用兄弟选择器 选中h2标签后所有的p标签 选择器分组逗号分隔开 继承body{font-family: “xxx”} 会被子元素继承 自动继承的属性 color font text list-style … 非继承属性 background Border Position 选择器优先级 优先级相同就 CSS层叠优先级：高覆盖低的 相同属性：后面覆盖前面的 不同属性：合并 改变优先级 改变顺序 覆盖 提升选择器优先级 改变选择器的写法 加高优先级 标签变类 类变id !important .tip{color: blue !important} 文本文字形状文字大小 font-size [number|percentage] 字体 font-family 加粗 font-weight 斜体 font-style (段落 )行距 line-height 百分比和数字写法的继承关系不一样 数字写法背书关系直接继承 这5个属性可以缩写为font这一个属性 下面两个实例是无效的 文本颜色color 文本位置水平对齐text-align:left right center jusitfy 垂直对齐vertical-align: 上标，下标和居中 其他文本缩进：text-indent 文本格式：white-space 换行是否保留 空格是否合并 自动换行 pre-wrap用的多 保留换行和空格，自动换行 单词换行：word-warp word-break overflow-wrap 文字阴影：text-shadow 下划线：text-decoration 光标形状：cursor 文本溢出：text-overflow 强制继承：属性值inherit 不换行，超出部分用省略号替代 123text-overflow: ellipsis;overflow:hidden;white-space: nowrap; 盒模型 标准盒模型的长宽属性只作用于content IE盒模型包括 content + padding + border margin 边缘 页边空白 margin合并问题相邻合并取大值 父元素和首尾合并 border 边线 :width style color ​ border-width ​ border-style ​ border-color padding 内衬 content 内容 border-radius 可以设8个值 overflow 盒溢出 box-sizing 我们可以简单的理解，当box-sizing为content-box时，我们使用的是W3C盒模型，当box-sizing为border-box时，我们使用的是IE盒模型 ​ content+padding+border box-shadow 阴影不占空间 outline： width style color 不占空间 border外 详情请看 背景background-color 颜色 最底层 background-image 图片 先写的在上面 background-repeat 背景平铺 nackground-attachment 背景跟随内容滚动 background-position 背景定位 linear-gradient 线性渐变 radial-gradient 径向渐变 还能加repeat background-origin: border-box|pading-box|content-box 背景原点 background-clip 裁剪盒子的背景 content padding border background-size 简写里的两个box是origin和clip 如果只写一个，那么两个box为同一个值 简写 布局简介元素的摆放模式 display设置元素的显示方式 block :块级元素 ​ 1 宽度默认为父元素宽度 ​ 2 可设置宽高 ​ 3 换行显示 ​ 默认block元素 div p hx ul form… inline：行内元素 ​ 1 默认宽度为内容宽度 ​ 2 不可设置宽高 ​ 3 同行显示 ​ 4 元素内换行 ​ 默认inline元素 span a label cite em… inline-block 从行内元素修改一下 ​ 1 内容宽度 ​ 2 可设置宽高 ​ 3 同行显示 ​ 4 整块换行 ​ 默认inline-block input textarea select button ​ vertical-align:middle 垂直居中有问题 none：设置元素不显示，位置没有了,从display的字面意思来理解就是根本就不放上去 ​ visibility位置还在 flex: 弹性容器，看下面的flex弹性布局 相关布局模式块级元素水平居中 123456&lt;div&gt; &lt;div class=\"content\"&gt;content area&lt;/div&gt;&lt;/div&gt;.content&#123;margin: auto; width:978px; &#125;左右外边距为auto就行了 居中导航 容器 text-align:center 里面 display：inline-block position设置定位方式 position 设置参照物 ​ static 默认 ​ relative 相对定位 ​ 1 仍在文档流中 ​ 2 参照物为元素本身 ​ 常用来改变元素的层级 ​ 作为绝对定位元素的参照物 ​ absolute 绝对定位 ​ 1 默认宽度为内容宽度 ​ 2 脱离文档流 ​ 3 参照物为第一个定位祖先/根元素(html) ​ 用一个相对定位的元素包裹绝对定位的元素 ​ fixed ​ 1 默认宽度为内容宽度 ​ 2 脱离文档流 ​ 3 参照物为视窗 top right bottom left 设置位置 z-index 设置层级 相关布局模式轮播头图 叠加 父元素relative 子元素absolute 固定顶栏 top-bar{position: fixed} body{margin-top:xxxpx} 遮罩 盖住页面 123456789.mask&#123; position: fixed; top:0; left:0; z-index;999; width:100%; height:100%;&#125; 三行自适应布局 头尾固定，中间自适应 1234header&#123;position: absolute;top: 0px;left: 0;width: 100%; height: 100px;background-color: indianred;&#125;.container&#123;position: absolute;top: 100px;bottom: 100px;left: 0px;right: 0px;overflow: auto;&#125; 没有设置宽高 ，让浏览器来计算.contents&#123;height: 100px;&#125;footer&#123;position: absolute;bottom: 0;left: 0;width: 100%;height: 100px;background-color: lemonchiffon;&#125; floatnone 默认 right ​ 1 默认宽度为内容宽度 ​ 2 脱离文档流 ​ 3 向指定方向一致移动，移到父元素的边界（不是完全脱离） float的元素在同一文档流，行内 对元素，脱离文档流；对内容，在文档流 ​ clear应用于后续元素 清除浮动元素对后续元素的影响。float元素从当前父元素浮动出来可能会对父元素后续的元素造成影响。 123456789.clearfix:after&#123; content:\".\"; display:block; clear:both; height:0; overflow:hidden; visibility:hidden;&#125;这里用不可见的.来清除浮动 把浮动的效果控制在父元素内 两列布局 块级元素同行显示 在文档流中 flex父元素 position:flex 弹性元素是在其文档流中的子元素。不包括position: absolute 和非子后代元素。注意float元素也在文档流中 方向（容器） flex-flow​ flex-direction 排列方向 row row-reverse colunm column-reverse ​ flex-wrap 是否换行 ​ flex-flow 是direction和wrap的缩写 ​ order 改变单个元素的排列顺序 弹性（元素）flex​ flex-grow 分配剩余空间的比例 先计算basis再从剩余空间分配 ​ flex-shrink 分配缺少空间的比例 初始值为1，平均分配，为0不分配，也就是不收缩了 ​ flex-basis 弹性元素的初始宽（横向排列）或高（纵向排列） ​ 缩写为flex：grow||shrink||basis 对齐（容器）​ justify-content: 主轴方向的对齐方式 ​ align-items: 容器辅轴上的对齐方式 ​ align-content：容器 辅轴 多行的行对齐方式 ​ align-self：单个元素在辅轴上的对齐方式 三行两列自适应 12 ### 变形transform 调用变形函数 transform: function() 函数有 rotate旋转 translate移动 scale伸缩 skew倾斜 transform-origin 设定变形原点 perspective 设定人眼的距离来表现透视效果 perspective-origin 设定人眼的角度来表现透视效果 translate3d 加入了z轴的transform transform-style backface-visibility 变形之后的背面的可见性 动画transition transition-property 产生动画效果的属性 transition-durantion 动画效果持续的时间 transition-timing-function 动画速度变换控制 transition-delay 动画开始延时时间 animation animation-name 自运行多帧动画 文档流什么是文档流？ ​ 将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。 ​ 只有三种情况会使得元素脱离文档流，分别是：浮动、绝对定位和相对定位。 元素种类display属性 块级元素 block 行内元素 inline 可以通过css修改 块级可以包含块级和行内，行内只能包含文本和行内块级占据一整行空间，行内占据自身宽度空间，在同一行里可以放很多宽高设置、内外边距的差异 块级元素(block-level)12345div h1 h2 h3 h4 h5 h6 p hrform ul dl ol pre tableli dd dt tr td thdiv,标题，表单，段落，列表，表格块级元素是占据一整行的空间的 行类元素（inline-level）1234em strong span a br img button input label select textareacode script块级元素可以包含块级元素和行内元素，行内元素只能包含行内元素和文本","categories":[{"name":"前端","slug":"前端","permalink":"https://benny233.github.io/categories/前端/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://benny233.github.io/tags/基础/"},{"name":"CSS","slug":"CSS","permalink":"https://benny233.github.io/tags/CSS/"}]},{"title":"html基础","slug":"html基础","date":"2019-11-04T06:48:47.000Z","updated":"2019-11-04T06:51:11.675Z","comments":true,"path":"2019/11/04/html基础/","link":"","permalink":"https://benny233.github.io/2019/11/04/html基础/","excerpt":"","text":"全局属性所有的标签都有的属性 id class style title 标签们 文档章节标签 body 用户内容 header 章节头部，标题，logo，搜索 nav 导航 整站导航和页面内导航 aside 侧边栏，广告，工具 article 主体内容，独立的，可重复的结构，比如论坛的一个帖子，博客的一篇文章。可以嵌套 section 表示article中的一部分 footer 版权，链接 hx 文本标签 超链接 a 链接，内部锚点 email 强调 em strong em是语义的强调， strong是重要性的强调 strong比em更强烈 行内容器 span 没有语义，结合样式来操作 换行 br 其他文本标签 引用 cite，表示引用的出处 q ，简短的一段文字 代码 code 格式化 b 粗体，但是并不强调，比如摘要中的关键字，产品的名称 i 斜体，比如技术术语 组合内容标签 分区 div 段落 p 列表 ul ol dl 其他组合内容标签 pre 格式化的内容，会保留换行符和空格 blockquote，大块的引用 嵌入资源标签 img iframe 嵌入第三方的页面或者广告，js的环境是隔离的，操作互不影响。比如云音乐下面的播放器，和上方的页面互不影响 object 嵌入外部资源，比如pdf阅读插件，还有flash插件播放视频（以前） embed 同上 video h5标签支持，不需要插件了 audio 其他嵌入资源标签 图 canvas 基于像素，利用脚本来绘制图像 性能高场景复杂的 比如实时数据展示 和游戏 svg 矢量图 高保真静态图形图像 热点区域 图像的不同部分跳转到不同的链接 map area 表格标签 Table thead tbody tfoot tr th td 表单标签 数据交互 form包裹 重要属性 action method fieldset 给表单分区 legend 分区标题 Input 基本数据输入单元 重要属性type name value Button Select 下拉框 textarea label 提示 重要属性 for","categories":[{"name":"前端","slug":"前端","permalink":"https://benny233.github.io/categories/前端/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://benny233.github.io/tags/基础/"},{"name":"HTML","slug":"HTML","permalink":"https://benny233.github.io/tags/HTML/"}]},{"title":"HTTP基础","slug":"HTTP基础","date":"2019-10-14T03:43:22.000Z","updated":"2019-10-14T03:46:10.529Z","comments":true,"path":"2019/10/14/HTTP基础/","link":"","permalink":"https://benny233.github.io/2019/10/14/HTTP基础/","excerpt":"","text":"HTTP基础网络模型OSI模型7层应用层：各种应用软件，包括 Web 应用。 标识层：数据格式标识，基本压缩加密功能。 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。 传输层：端到端传输数据的基本功能；如 TCP、UDP。 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。 物理层：底层数据传输，如网线；网卡标准。 三次握手和四次挥手 为什么要三次握手？ 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了. 为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手(服务端验证) 为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手(客户端验证) socket它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 socket与TCP创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。 但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。 报文格式一个 HTTP 请求报文由请求行（request line）、请求头部（header）、空行和请求数据四部分组成 第一行必须是一个请求行（request line），用来说明请求类型、要访问的资源以及所使用的 HTTP 版本 紧接着是一个头部（header）小节，用来说明服务器要使用的附加信息 之后是一个空行 再后面可以添加任意的其他数据（称之为主体：body） 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文类似， 状态行 响应报头 空行 响应数据 1234&lt;state&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP特性CORS跨域请求的限制与解决，预请求验证需服务器支持跨域 缓存头Cache-Control，Expires，Last-Modified和Etag cookie和sessioncookie和session JWTcookie和session可以实现有状态(服务端保存session)的用户认证，但是扩展性不好 JWT实现无状态(服务端不保存session)，从而容易实现扩展 HTTP长连接Keep-alive Keep-alive的应用 HTTPS原理 实操 HTTP2[服务器推送](","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://benny233.github.io/tags/基础/"},{"name":"网络","slug":"网络","permalink":"https://benny233.github.io/tags/网络/"}]},{"title":"Redis基础","slug":"Redis基础","date":"2019-10-10T08:29:35.000Z","updated":"2019-10-10T08:29:54.058Z","comments":true,"path":"2019/10/10/Redis基础/","link":"","permalink":"https://benny233.github.io/2019/10/10/Redis基础/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://benny233.github.io/tags/基础/"},{"name":"数据库","slug":"数据库","permalink":"https://benny233.github.io/tags/数据库/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2019-10-10T06:57:39.000Z","updated":"2019-10-10T08:29:01.512Z","comments":true,"path":"2019/10/10/MySQL基础/","link":"","permalink":"https://benny233.github.io/2019/10/10/MySQL基础/","excerpt":"","text":"整理自掘金小册《MySQL是怎样运行的》，还有高频面试一百问，MySQL优化面试，MySQL重要知识点 图片都来自前者。 一 索引认识索引mysql按照记录的主键值从小到大，分页存储。记录之间组成单向链表，页之间组成双向列表。 主键查询是在页目录中用二分法定位到页，然后在页中遍历到指定记录。 类似看书的时候查目录。 不是主键也没有建立索引就是遍历查找所有记录。很慢，所以需要索引。 简单理解一下存储结构是下面这样 上面那一页就是索引页，专门存放目录项记录 实际情况是下面这样，一棵B+树。实际记录都存放在B+树最底层的节点(叶子节点)上。 名字很奇怪的聚簇索引说的就是这(叶子节点是实际记录)，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。 上面是按照主键排列的，可以实现主键的快速查找。想要实现其他条件的快速查找就要重新排列了，这就是建索引。按照索引列排列，建一颗B+树。 不同的是，叶子节点不是真实记录，只有对应的主键值，所以需要去聚簇索引中再找一次。这个操作叫回表，以时间换空间。比聚簇索引(主键索引)多了一个回表操作，所以也叫二级索引(辅助索引) 使用索引建立索引高频查询字段适合建立索引 联合索引需要注意联合索引中的顺序. 索引不生效的情况 使用不等于查询, 列参与了数学运算或者函数 在字符串like时左边是通配符.类似于’%aaa’. 当mysql分析全表扫描比使用索引快的时候不使用索引. 当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引. 二 设计优化使用自增主键没有主键也建议添加一个自增主键，新的记录会按顺序添加到前一个记录的后面 uuid写入近似于随机(因为是按照字符来排序的)，插来插曲效率低 使用NOT NULL理由很多，不用就完事了 定长比非定长查询效率高选择小的数据类型注释写好点单表字段不宜过多二三十个是极限了 冗余字段我倾向多一点冗余，减少连表查询，也不使用子查询 三 查询优化慢查询的原因是查询条件没有命中索引? 是load了不需要的数据列? 还是数据量太大? 所以优化也是针对这三个方向来的, 首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写. 分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引. 如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表. 四 事务事务的英文是transaction，其实本义是交易，买卖的意思。事务不够直观 需要符合AICD特性的一个或多个数据库操作称为事务 A atomicity 原子性：不可分割，要么做要么不做，不存在中间状态 I isolation 隔离性：本次操作不受其他操作影响 C consistency 一致性：符合现实世界的约束，比如你在银行里只有5块钱，不可能取出6块钱来 D durability 持久性：操作产生的状态转换是稳定的 事务的状态1 活动的（active） 操作正在执行 2 部分提交的（partially committed） 最后一个操作执行完成，刷新到磁盘前 3 失败的（failed） 1或2执行失败后 4 中止的（aborted） 失败之后需要回滚 ，回滚后 5 提交的（committed） 2提交成功后 还没用到，写支付的时候再来吧 五 锁有并发事务的时候通过锁来保证访问的次序。 需要的时候再来吧。 六 其他explain小册总结得很好，就不copy了","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://benny233.github.io/tags/基础/"},{"name":"数据库","slug":"数据库","permalink":"https://benny233.github.io/tags/数据库/"}]},{"title":"阿里云效搭建单机自动化部署系统","slug":"阿里云效搭建单机自动化部署系统","date":"2019-10-04T16:24:29.000Z","updated":"2019-10-10T08:12:30.970Z","comments":true,"path":"2019/10/05/阿里云效搭建单机自动化部署系统/","link":"","permalink":"https://benny233.github.io/2019/10/05/阿里云效搭建单机自动化部署系统/","excerpt":"","text":"本来想搭一套k8s，一劳永逸，奈何坑太大，个子太矮，没趟过去。 那就用云效吧。根据文档操作，再稍作修改，就阔以了。 主要用在测试环境，生产的灰度发布等等高级功能还没探索。 一先按照这个文档走下流程 在文档中的部署配置这一步之前增加一步镜像构建的操作，这一步会产出制品(用来部署)，部署操作里拿到制品才能进行。 镜像的标签写死，我写的latest，后面会用到。 二部署机器可以用非阿里云的机器，阿里云牛逼。 部署配置： 下载路径空着， 执行用户是root 部署脚本参考 123docker stop xxx # 先把上一版本的容器停掉，因为启动的时候带了--rm参数，所以容器会自动删除docker rmi $imageId # 然后把老镜像删掉，前面把标签写死就是为了这里能删掉老镜像docker run --name xxx --rm -d -p 3000:3000 $imageId # 最后拉取镜像，跑起来 三机器上面需要docker login，还有一些代码库，镜像库的细节，摸索一下就会了。 OK，推送代码就能触发自动部署了，倍儿爽","categories":[{"name":"运维","slug":"运维","permalink":"https://benny233.github.io/categories/运维/"}],"tags":[]},{"title":"周打卡-1","slug":"周打卡1","date":"2019-06-04T09:51:47.000Z","updated":"2019-12-01T08:31:45.381Z","comments":true,"path":"2019/06/04/周打卡1/","link":"","permalink":"https://benny233.github.io/2019/06/04/周打卡1/","excerpt":"","text":"有些事情需要长期投入在这里通过周打卡的形式记录之后抽出来做一个打卡的功能","categories":[{"name":"周打卡","slug":"周打卡","permalink":"https://benny233.github.io/categories/周打卡/"}],"tags":[]},{"title":"Linux常用命令","slug":"Linux命令手册","date":"2018-08-09T03:35:09.000Z","updated":"2019-10-10T08:22:10.085Z","comments":true,"path":"2018/08/09/Linux命令手册/","link":"","permalink":"https://benny233.github.io/2018/08/09/Linux命令手册/","excerpt":"","text":"基本操作12345678ps -a| grep name# 查看指定程序的进程id#用于显示tcp，udp的端口和进程等相关情况netstat -tunlp# 切换用户su name","categories":[{"name":"手册","slug":"手册","permalink":"https://benny233.github.io/categories/手册/"}],"tags":[]},{"title":"部署流程","slug":"部署流程","date":"2018-07-09T15:39:07.000Z","updated":"2019-10-09T10:32:30.630Z","comments":true,"path":"2018/07/09/部署流程/","link":"","permalink":"https://benny233.github.io/2018/07/09/部署流程/","excerpt":"","text":"项目写好了。有一台服务器。 服务器基本配置登录1ssh username@ip 这是是root用户，权限太大不安全。 新建用户123456新建用户 adduser name 给sudo权限 vim /etc/sudoers在root ALL=(ALL)ALL这一行下增加name ALL=(ALL)ALL 简化登录本机.zshrc文件给命令配置别名1alias tx=&quot;ssh name@ip&quot; 无密码登录和git\b仓库配置秘钥原理一样。123456781. 两边都要有生成秘钥ssh-keygen -t rsa -C “email”2. 服务器保存本地公钥echo pubkey &gt;&gt; .ssh/authorized_keys3. 重启服务器sshservice ssh restart 安全措施123456789101. 修改端口文件/etc/ssh/sshd_config port属性,换成其他端口2. 关闭root密码登录\bPermitRootLogin属性，换成without-password3. 重启ssh4. 还可以配置iptables nginx配置端口代理在/etc/nginx/nginx.conf中添加12# 让nginx加载配置文件include /etc/nginx/conf.d/*.conf; 然后在/etc/nginx/conf.d文件夹下新建配置文件name-port.conf1234567891011121314151617upstream dappdemo &#123; server localhost:3000;&#125;server &#123; listen 80; server_name 127.0.0.1; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://dappdemo; proxy_redirect off; &#125;&#125; 匹配到server_name的流量转发到proxy_pass 项目配置安装docker123451. 安装dockerwget -qO- https://get.docker.com/ | sh2. 检验docker是否被正确安装sudo docker run hello-world 从仓库拉取代码 服务器连接仓库教程 git clone 生成镜像根据dockerfile新建一个镜像123docker build -t yourname/imagename:tag .docker build -t benny/dapp:latest . 新建容器并启动用了Makefile12345678910pjName := dappdemodocker: docker run \\ --name $&#123;pjName&#125; \\ --rm \\ -ti \\ -p 3000:3000 \\ benny/dapp:0.1 \\ /bin/bash 1make docker 启动应用npm run start，使用pm2管理进程 123456789101112131415161718192021pm2 start pm2.json===================================&#123; &quot;apps&quot;: [ &#123; &quot;name&quot;: &quot;ico-dapp&quot;, &quot;script&quot;: &quot;./server.js&quot;, &quot;out_file&quot;: &quot;./logs/out.log&quot;, &quot;error_file&quot;: &quot;./logs/error.log&quot;, &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;, &quot;instances&quot;: 0, &quot;exec_mode&quot;: &quot;cluster&quot;, &quot;max_memory_restart&quot;: &quot;500M&quot;, &quot;merge_logs&quot;: true, &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;production&quot; &#125; &#125; ]&#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://benny233.github.io/categories/运维/"}],"tags":[]},{"title":"Nginx笔记","slug":"Nginx笔记","date":"2018-07-09T14:44:54.000Z","updated":"2019-10-09T10:31:42.702Z","comments":true,"path":"2018/07/09/Nginx笔记/","link":"","permalink":"https://benny233.github.io/2018/07/09/Nginx笔记/","excerpt":"","text":"基本信息nginx是web服务器，性能高，并发性好。 可以用作代理服务器。 正向：直接转发 反向：分发请求 基本操作nginx -s reload 重新加载 问题这和用程序起一个服务有什么区别呢？语言自带类库实现的服务器比较简单。nginx是专业的，更强大。 为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。 功能动静态资源分离运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。 负载均衡当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理 实现打点计数用到了服务器功能，和日志功能。 服务器只返回一个像素的gif图，很高效。 日志路径为”/usr/local/Cellar/nginx/1.15.0/logs” nginx.conf12345server &#123; location = /report &#123; empty_gif; &#125;&#125; 实现负载均衡和端口代理nginx运行在80端口，将请求分发到对应的端口上 /etc/nginx/conf.d/name-port.conf 把入口的流量转发到dappdemo 1234567891011121314151617181920212223242526upstream dappdemo &#123; server 127.0.0.1:3000;# down 表示单前的 server 暂时不参与负载 server 127.0.0.1:8083 down;# weight 默认为 1 weight 越大，负载的权重就越大。 server 127.0.0.1:8084 weight=3; # backup 其它所有的非 backup 机器 down 或者忙的时候，请求 backup机器。所以这台机器压力会最轻 server 127.0.0.1:8002 backup; &#125;server &#123; listen 8080;# 匹配的入口 server_name 127.0.0.1; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://dappdemo; proxy_redirect off; &#125;&#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://benny233.github.io/categories/运维/"}],"tags":[]},{"title":"非暴力沟通","slug":"非暴力沟通","date":"2018-07-03T05:10:00.000Z","updated":"2019-12-01T08:30:18.755Z","comments":true,"path":"2018/07/03/非暴力沟通/","link":"","permalink":"https://benny233.github.io/2018/07/03/非暴力沟通/","excerpt":"","text":"核心观点沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配 暴力行为的背后，往往隐藏着人性本恶的价值取向。接受人性本善的价值取向，暴力因素就会远离。 交流如何变成暴力行为道德批判用自己的价值观给别人贴标签。这种标签实际上反应了我们的需要和价值观。贴完标签，偏见就产生了，偏见会阻碍交流。 进行比较比较也是一种评判。强迫别人参加一场比赛，然后判他输。 回避责任这是一种表达方式的问题。“不得不做”是一种回避责任的表达方式，需要换成负责任的方式。 强人所难字面意思。对别人的要求往往暗含威胁。 暴力行为的背后行为只是表面原因，问题的根源是对自己和世界的看法。比如优胜劣汰，人性本恶。 优胜劣汰在社会运作的规则之一，但我们的生活不是。在社会中我们不得不去竞争，比输了很正常，要能够接受。尽人事，听天命，实在是智慧之言。很多情况下，让我懊恼的失败都是没有“尽人事”。 这个世界好人有很多，坏人也不少，好人可能也做过坏事，坏人大概率也不是彻头彻尾的坏。沟通的时候应该采用“无罪推定”原则，重大利益面前还是“有罪推定”吧。小亏吃了也没啥，大亏万万不能吃。有些场景本来就是暴力的战争，非暴力适用的场景是沟通。 非暴力沟通要素技能是需要练习的，沟通这项技能有四个要素，观察、感受、需要和 请求。通过四要素的逻辑来组织语言，语言结构就不再是随意的、任性的甚至是暴力的，而是一种平等的、尊重的语言。 比如，你给我一份重要文件，中午出去吃饭我把他放在桌子上了，没有收起来。你看见了然后生气的说：“我给你这么重要的文件，你怎么随便扔在桌子上？” 用非暴力沟通的方式来组织语言就是这样的： 观察：我看到你把文件放在桌子上 感受：我郑重交给你的重要文件，你却随意仍在桌子上，我感到失望 需要：保管好文件，尊重我的嘱咐 请求：保管好文件 经过组织后的语言是这样的：我看见刚才交给你的重要文件没有放在桌子上没有收起来(观察)，我担心不安全(感受)，重要的文件应该妥善保管(需要、请求)","categories":[{"name":"综合能力","slug":"综合能力","permalink":"https://benny233.github.io/categories/综合能力/"}],"tags":[]},{"title":"Fabric基础笔记","slug":"Fabric基础笔记","date":"2018-07-01T05:20:59.000Z","updated":"2018-07-01T05:22:25.000Z","comments":true,"path":"2018/07/01/Fabric基础笔记/","link":"","permalink":"https://benny233.github.io/2018/07/01/Fabric基础笔记/","excerpt":"","text":"项目概述Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。 为了适用于不同的场合，采用模块化架构，提供可切换和可扩展的组件，包括 共识算法 加密安全 数字资产 记录仓库 智能合约 身份鉴权 Fabric克服了比特币等公有链项目的缺陷，如吞吐量低、无隐私性、无最终确定性以及共识算法低效等，使得用户能够方便地开发商业应用 应用场景超级账本的一个重要的设计原则是“用例驱动”(use case driven),所有的功能都有对应的用例需求。Farbic主要针对以下几种用例 金融资产管存资产上链后，权益人可以直接访问资产数据，而无需经过传统的中间人，可大幅度提高效率和节约成本。另外资产附加自动执行的业务规则后，可以进一步降低运营成本。 与公有链应用的较大区别是，金融资产及其相关的交易、业务规则通常是保密的。 公司行为上市公司发起的有关公司证券的事件一般和股东有关，需要股东做适时的回应。事件的完整信息需要及时传递给股东。股东作出决定后，该结果会实时处理货结算。整个过程应保护股东的隐私，确保投资者的决定不受外界影响 供应链在供应链中，所有的参与者都通过区块链记录、追踪和共享各种数据，例如原材料来源、零部件检测结果以及货物的出处等。数据上链，并贯穿货物的生产、运输和销售等环节，从而提供深度回溯查询等核心功能。 主数据管理在很多行业里，不同的组织之间往往共享一些主数据(master data)。例如，不同移动运营商之间，需要共同维护一份发射基站地理位置的数据。通过区块链来保证数据的质量和完整性。 分享经济分享经济是指将闲置或没有被充分利用的实物资源分享出来，有偿供陌生人暂时使用的一种商业模式。最需要解决的是陌生人之间的信任问题，即资源的提供方和资源的租用者，如何在缺乏信任的基础上安全地完成交易。目前的主要手段是通过分享经济平台来确保信任度。区块链将是一种去信任的方式，不使用任何中间平台，便可达到各方参与者可靠交易的目的 项目架构 身份服务权限区块链与\b公链最大的区别就是具有身份识别能力。参与者都有明确的身份信息，身份服务管理着系统中各种实体、参与者和对象的身份信息。 策略服务Fabric的许多功能需要用策略(policy)方式驱动,因此有独立的策略服务来提供系统的策略配置和管理功能。包括访问控制、授权、身份的注册、验证、隐私和保密、共识策略等。 区块链服务提供构建分布式账本最基础的\b能力，实现数据传输、共识达成等底层功能，并且提供发布/订阅的事件管理框架，分布式账本内部的各种事件可通知到外部监听的应用。主要包含四个组件 P2P协议组件主要提供区块链节点之间直接双向通信的能力，包括流式数据传输、流控制、多路复用等方面。 分布式账本组件\b维护区块链数据。该组件性能直接影响整个网络的吞吐量，因此需要较高的处理效率 共识管理组件在各种公式算法之上定义里\b抽象的接口，可以根据场景切换公式算法 账本存储组件链外存储大文件 智能合约服务为合约代码提供安全的运行环境以及合约的声明周期管理 网络与部署Fabric网络由\b4类节点组成 \b身份服务节点负责发放和管理用户的身份，具体来说就是在注册、交易、传输过程中使用的各类数字证书，以及区块链相关的\b秘钥 验证节点创建和校验交易，并且维护智能合约的状态。在执行\b交易时，一般需要和其他多数的验证节点达成共识(取决于共识算法),然后才能更新本地的账本数据。每个\b验证节点在本地都保存一份账本的\b副本。 非验证节点主要是接受客户端的请求，组装交易，并发往验证节点处理，从这个角度看，非验证节点像交易预处理器，并不负责交易的实际执行。为了加速客户端的查询响应速度，非验证节点在本地也保留一份账本数据的拷贝 应用节点\b主要提供用户端的后台服务，在\b收到请求后，\b把交易请求直接发往(或经由非验证节点转发)验证节点处理 部署由于节点部署的多样性，\b应该\b考虑通信延迟、网络故障、节点失效、网络恢复等因素 交易的执行交易(transaction)分两种:部署智能合约，执行智能合约 部署步骤： 客户端通过API\b提交代码给验证节点 验证节点确认代码有效 \b验证节点同步\b到其他节点 执行步骤： \b\b客户端发送执行请求\b给验证节点 验证\b节点收到请求后，向本地账本发送启动交易的指令 验证节点创建隔离的运行环境，启动应用(智能合约)代码 应用执行过程中，更新本地账本的状态 应用\b完成后，验证节点想本地账本确认交易 验证节点向\b其他验证节点广播交易","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"智能合约基础笔记","slug":"智能合约基础笔记","date":"2018-06-30T09:25:46.000Z","updated":"2018-06-30T09:26:13.000Z","comments":true,"path":"2018/06/30/智能合约基础笔记/","link":"","permalink":"https://benny233.github.io/2018/06/30/智能合约基础笔记/","excerpt":"","text":"智能合约简介什么是智能合约 法律角度，智能合约是否是一个真正意义上的合约还有待确认 计算机科学角度，智能合约是一种计算机协议，一旦制定和部署就能实现自我执行(self-executing)和自我验证(self-verifying)，而且不再需要人为的干预 技术角度，一种计算机程序，能够自主执行合约相关的操作，并产生相应的可验证的证据，来说明执行合约操作的有效性 例如，银行账户的存取款可以用合约来替代，以及任何需要记录信息的场合 智能合约的历史 20世纪七八十年代，人们提出了让计算机代替人类进行商业市场管理的想法。 九十年代，研究数字合约和数字货币的Nick Szabo提出了“智能合约” 08年比特币出现，借由其背后的区块链技术，智能合约飞速发展 Nick Szabo对智能合约的定义智能合约是一个由计算机处理的、可执行合约条款的交易协议。其总体目标是能够满足普通的合约条件，例如支付、抵押、保密甚至强制执行，并最小化恶意或意外事件发生的可能性、以及最小化对信任中介的需求。智能合约所要达到的相关经济目标包括降低合约欺诈所造成的损失，降低仲裁和强制执行所产生的成本以及其他交易成本等。 优点 高效的实时更新 准确执行 较低的认为干预风险 去中心化权威 较低的运行成本风险 现实中的合同出现漏洞可以协商或者通过法律和仲裁解决，智能合约的漏洞执行后无法修补 智能合约的自我验证特性导致隐私性低 以太坊智能合约详解合约操作流程 启动一个节点 编写合约 编译 部署，矿工确认。得到地址与接口 使用web3.js接口调用合约以太坊上的账户两类账户，公用一个空间地址。 外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。 合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含四个部分 随机数，用于确定每笔交易只能被处理一次的计数器 账户目前的以太币余额 账户的合约代码（如果有的话） 账户的存储（默认为空） 钥匙文件 账户通过私钥和公钥确定 账户地址是公钥的最后20个字节 账户地址和私钥密文存储在钥匙文件keyfile中 私钥总是处于加密状态，秘钥是创建账户时输入的密码 通过秘钥和keyfile中的私钥密文才能得到私钥，进行交易 要确保备份好keyfile和秘钥创建账户12345678安装客户端brew install ethereum创建账户geth account new同步区块geth 账户的备份~/Library/Ethereum/keystore/keyfile这是账户数据，备份好 Gas为防止用户恶意部署无限循环运行的合约，合约执行的每一步都需要支付费用，就是gas。 Gas花销Gascost：针对具体操作是不变的。保证每种操作所需的计算资源保持不变 Gas价格Gasprice：每个gas所需的以太币。由用户控制，价格高的确认快。并且随以太币的市值波动，以保证运行智能合约所需的真实花费不会出现大幅度变化 Gasfee：Gascost*Gasprice，真实费用，单位是以太币 消息和交易消息合约账户有能力向其他合约账户发送消息，它是一个虚拟的对象，不会具体的存储在以太坊的区块链内，可以看做一个函数调用的过程 类似于比特币的交易，主要有3点不同： 以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建 以太坊消息可以选择包含数据 如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念 交易指外部所有账户将一个经过签名的数据包发送到另一个账户的过程，这个过程中产生的账户状态变化被存储到区块链上 交易包含： 消息的接受者 用于确认发送者的签名 以太币账户余额 要发送的数据 STARTGAS，通过需要支付的燃料来对计算步骤进行限制 GASPRICE，每一计算步骤需要支付给矿工的燃料 以太坊虚拟机Gas的消耗 最常见的，执行特定的内部抽象操作。例如运行SHA3散列运算 进行一个从属的消息调用或合约创建时，例如执行CREATE、CALL、CALLCODE操作 增加账户内存使用量 内存使用计费机制鼓励用户使用较少的内存。执行账户内存清理操作不消耗GAS，还会得到折扣。 虚拟机运行环境 以太坊网络状态 合约剩余GAS 当前代码合约地址 合约发起者地址 Gasprice 交易的输入数据 执行合约交易的账户地址 合约账户的余额 用于执行虚拟机代码所需的数组 目前区块的数据头 目前执行的CALL操作和CREATE操作的数量 区块链系统状态的验证每产生一个新的有效区块，以太坊系统需要以下几个步骤将该区块加入权威区块链上 验证新区快的ommer区块的有效性。验证叔区块？ 验证新区快所包含交易的有效性，即所有交易所花费的GAS是否与新区块链中标记的花费量一致，并且每笔交易一一对应 给该区块和ommer区块的矿工发放奖励 验证新区快的工作量证明，连接主链，然后将整个系统更新 智能合约操作钱包部署Mist或者Eth Wallet 命令行部署通过web3.js的API在命令行部署","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"Makefile笔记","slug":"makefile手册","date":"2018-06-29T13:43:39.000Z","updated":"2019-10-10T08:23:10.468Z","comments":true,"path":"2018/06/29/makefile手册/","link":"","permalink":"https://benny233.github.io/2018/06/29/makefile手册/","excerpt":"","text":"根据指定的Shell命令进行构建的工具 http://www.ruanyifeng.com/blog/2015/02/make.html 123456789101112131415161718pjName := wordpress# 变量docker: docker run \\ --name $&#123;pjName&#125; \\# 容器名 --rm \\# 停止运行后自动删除当前容器 -ti \\# t for terminal,i for interact -v $$(pwd):/var/www/html \\# 映射当前目录到容器指定目录 -p 3000:3000 \\# 映射端口到容器端口 mooxe/node \\ /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell","categories":[{"name":"运维","slug":"运维","permalink":"https://benny233.github.io/categories/运维/"}],"tags":[]},{"title":"Docker笔记","slug":"Docker笔记","date":"2018-06-29T13:42:43.000Z","updated":"2019-10-10T08:20:59.985Z","comments":true,"path":"2018/06/29/Docker笔记/","link":"","permalink":"https://benny233.github.io/2018/06/29/Docker笔记/","excerpt":"","text":"可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行 http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html update：K8s的pod才可以理解为虚拟机，容器其实就是一个进程，被修饰过，有点特殊的进程。 命令docker pull 获取image docker build 创建image docker images 列出image docker run 运行container，跑一个项目123456789101112131415 docker run \\ --name $&#123;pjName&#125; \\# 容器名 --rm \\# 停止运行后自动删除当前容器 -ti \\# t for terminal,i for interact -v $$(pwd):/var/www/html \\# 映射当前目录到容器指定目录 -p 3000:3000 \\# 映射端口到容器端口 mooxe/node \\ /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell docker ps 列出container，项目们 -a 列出隐藏的 docker rm 删除container docker rmi 删除image docker cp 在host和container之间拷贝文件 docker commit 保存改动为新的image dockerfileFROM: base image RUN: 执行命令 ADD： 添加文件 COPY： 拷贝文件 CMD： 执行命令，打包完成之后 EXPOSE： 暴露端口 WORKDIR： 指定路径 MAINTAINER: 维护者 ENV: 设定环境变量 ENTRYPOINT: 容器入口 USER: 指定用户 VOLUME: mount point 123456789101112131415161718192021# 可以指定依赖的node镜像的版本 node:&lt;version&gt;，如果不指定，就会是最新的FROM node:8.6.0# 创建工作目录，对应的是应用代码存放在容器内的路径WORKDIR /usr/src/app# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)COPY package.json *.lock .# 只安装dependencies依赖# node镜像自带yarnRUN yarn --only=prod --registry=https://registry.npm.taobao.org# 把其他源文件复制到工作目录COPY . .# 替换成应用实际的端口号EXPOSE $&#123;app_port&#125;# 这里根据实际起动命令做修改CMD [ \"npm\", \"start\" ] 1234touch Dockerfiledocker build -t hello_docker .使用.目录下的dockerfile文件创建一个叫做hello_docker的镜像， 使用docker步骤安装docker下载镜像1234&lt;!-- 拉取镜像 --&gt;docker image pull imagename&lt;!-- 查看镜像 --&gt;docker images 创建镜像docker commit将指定容器保存为新的镜像12docker commit &lt;Container ID&gt; &lt;Name&gt;:&lt;Tag&gt;docker commit fldhsa5342hkjhs bitcoin:0.1 根据dockerfile创建镜像1docker build -t imagename . 生成容器image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。12345# 运行镜像 docker run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash# 删除容器 docker rm [containerID] -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 保存镜像","categories":[{"name":"运维","slug":"运维","permalink":"https://benny233.github.io/categories/运维/"}],"tags":[]},{"title":"区块链基础知识","slug":"区块链","date":"2018-06-29T10:33:53.000Z","updated":"2018-06-29T10:34:22.000Z","comments":true,"path":"2018/06/29/区块链/","link":"","permalink":"https://benny233.github.io/2018/06/29/区块链/","excerpt":"","text":"区块链简介 去中心化的方式建立信任，不需要大机构的背书。 区块链定义：基于区块链技术形成的公共数据库(公共账本) 区块链技术：多个参与方之间基于现代密码学、分布式一致性协议、点对点网络通信技术和智能合约编程语言等形成的数据交换、处理和存储的技术组合。同时，仍在不断发展和演化中。 区块链分类从参与方的角度来分，可以分为公共链、联盟链和私有链。从链与链的关系的角度来分，可以分为主链和侧链。不同区块链还可以形成网络，网络总链与链的互联互通。产生互联链Interchain的概念 公共链对外公开，用户不用注册就能匿名参与。比特币和以太坊都是公链。也叫非许可链Permissionless Blockchain。 公链适用于虚拟货币、面向大众的电子商务、互联网金融等B2C、C2C或C2B场景 联盟链联盟链Consortium Blockchain，仅限联盟成员参与。读写权限、参与记账权限按照联盟规则来制定。也叫做许可链Permissioned Blockchain.例如有四十多家银行参与的R3和Linux基金会支持的超级账本Hyperleder。 联盟链适用于机构间的交易、结算或清算等B2B场景。 私有链私有组织使用，区块链上的读写权限、参与记账权限按私有组织股则来制定。应用场景一般是企业内部的应用，如数据库管理、审计。把制度写在区块链上。还有政府的一些应用，比如政府的预算和执行，或者政府的行业统计数据。 私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范内部和外部对数据的安全攻击。 Coin Science的Multichain平台提供一个在企业内部快速部署私链的解决方案。可以用于去中心化交易所、数据库同步、货币结算、债券发行和P2P交易、消费行业积分奖励机制等场景。 侧链侧链是能和比特币区块链交互，并与比特币挂钩的区块链。主链不易改动。比特币每秒只能确认7笔交易，通过侧链Side Chains提升效率，扩展比特币功能是一个有效的做法。例如闪电网络把交易放在侧链，只有在做清算时才用上主链。矿工打包少了，回报就少了。 互联链针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种协议连接起来。可以类比互联网 区块链的价值与应用区块链技术是一揽子技术，根据业务需要可以针对性的组合和创新。价值很多，很大，这个需要慢慢理解，放一放，先上手技术。 区块链技术基本概念数据区块区块结构分为区块头和区块体 挖矿矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历\b尝试来寻找一个随机数，使得新区快加上随机数的哈希值满足一定的难度条件。找到了就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。然后\b把新节点广播出去。 挖矿与分叉问题穷举\b随机数算法，把上个区块的哈希值加上十分钟内的全部交易单打包，再加上一个随机数，算出一个256\b位的字符串哈希值，输入的随机数nonce使哈希值满足一定条件就获得这个区块的交易记账权。 后续矿工总是选择累计工作量证明最大的区块链。结果就是自动抛弃分叉处的短链。 时间戳与不可篡改性时间戳是歌灵位置时间到现在的总秒数，通常是一个字符序列，唯一标识某一刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时间。 时间戳技术很简单，但意义重大，极大的增强了不可篡改性 分布式数据库可以理解为一个分布式数据库 UTXO交易模式比特币就是UTXO，交易UTXO + 区块链 = 比特币系统 哈希函数Merkle树双花 双花如何发生？ 花了一次，还没有上链的时候再花一次 如何避免 时间戳+UTXO+数字签名 P2P网络P2P网络是一种在peer(对等者)之间分配任务和工作负载的分布式架构，是对等计算模型在应用层形成的一种组网或网络形式。 每个节点\b均承担网络路由，验证数据区块等功能。根据存储数据量分为全节点和轻节点。 全节点存储了所有区块链数据，数据校验不需要别的节点，硬件成本高。 \b轻节点只存储部分，需要别的数据时通过建议支付验证(Simplified Payment Verification, SPV)向临近节点请求数据来完成验证更新 加密算法非对称加密算法(椭圆曲线加密算法，ECC) 数字签名数字签名就是在信息后加上一段内容，作为发送者的证明并且证明信息没有被篡改 要传送的信息先经过哈希得到一个值，\b再用私钥加密得到签名。对信息进行\b两次操作得到签名。 接受方通过发送方的公钥解密，然后对信息哈希，然后比对，验证需要三步。 公钥锁定比特币，私钥解锁，拥有私钥才能使用。 比特币的隐私模型\b匿名性好一截。进行交易不需要身份信息。 框架与特点框架简介 网络层 两个部分，P2P网络和TCP/IP协议。P2P网络提供了更好的安全性，\b任何一个节点\b被攻击都不会影响整个网络 数据层 \b三个部分，公共总账本，共识算法，密码学。在数据层面上，区块链就是一个只能追加、不可更改的分布式数据库系统，是一个分布式账本。通过公式算法保持账本的一致性。通过密码学的签名和哈希算法来确保这个账本不可篡改、不能作为，并且可追溯。 \b同时带有经济激励的工作量证明机制，\b使得即使拥有51%算力的人也不会损害自身利益去发起攻击 应用层 三个部分，可编程货币，可编程金融，可编程社会 区块链平台提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方上。因此，智能合约可以降低合约建立、执行和仲裁中所涉及的中间机构成本。 架构特点 去中心化 可靠数据库 开源可编程 集体维护 安全可信 准匿名性区块链运作的核心技术区块链的连接区块头中上一区块的哈希值用来实现区块的连接，区块头中的随机数用来实现挖矿机制共识机制1 PoW工作量证明 优点： 完全去中心化，节点自由进出 缺点： 浪费大量资源，挖矿激励机制导致矿池算力集中，不去中心化了。更大的问题是，\bPoW机制达成共识的周期长，每秒智能作7笔交易，不适合商业应用 2 PoS \bProof of Stake，权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。拥有代币越多的节点获得记账权的概率越大。为了平衡会引入其他机制。 优点： 一定程度上缩短了共识达成的时间，降低了资源浪费 缺点： 破坏者攻击网络的成本低。拥有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性 3 DPoS 股份授权机制，类似于董事会投票。持股人投票选出一定数量的见证人，见证人生成区块。持股人可以随时通过投票更换这些见证人。 优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证 缺点： 选举固定数量的见证人作为记账候选人有可能不适用与完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。 4 分布式一致性算法基于传统的分布式技术。有解决拜占庭将军问题的拜占庭容错算法，如PBFT。还有解决非拜占庭问题的分布式一致性算法(Pasox, Raft)。 目前联盟链和私有链场景中常使用。 优点： 实现妙计的快速共识机制，保证一致性 缺点： 去中心化程度不如公链上的共识机制，更适合多方参与的多中心商业模式 解锁脚本交易的输出其实是指向一个脚本，而不是地址。它类似一套规则，约束着接收方怎样才能划掉这个输出上锁定的资产。 交易的合法性也依赖于脚本。锁定脚本和解锁脚本。 比特币的脚本机制相对简单，不能实现复杂的逻辑。但为后来者们提供了可编程区块链的原型。 交易规则交易优先级Merkle证明Merkle树的重要使用场景是快速支付验证。轻节点只下载区块头，数据大小为80字节。 能证明包含的交易，但无法证明任何当前的状态。 以太坊中有三棵树，分别对应交易transactions，收据recipts和状态State RLPRecursive Length Prefix，递归长度前缀编码，是以太坊中对象序列化的一个主要编码方式。先放着 区块链交易流程 交易的生成：新交易创建 交易的传播：交易通过P2P网络传播 工作量证明：交易验证 整个网络节点验证：3的验证结果在P2P网络中传播 记录到区块链：交易写入账本","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"比特币基础知识","slug":"比特币","date":"2018-06-29T10:32:34.000Z","updated":"2018-06-29T10:34:40.000Z","comments":true,"path":"2018/06/29/比特币/","link":"","permalink":"https://benny233.github.io/2018/06/29/比特币/","excerpt":"","text":"基础比特币特性硬通货跨境交易 易携带只需一个私钥 私密性 只暴露钱包地址 非法应用 无货币超发通货紧缩 去中心化，P2P分布式的数字货币系统 共识机制 - POW工作量证明 非对称密码学，公钥私钥 区块链作为账本 简单理解比特币就是UTXO，交易UTXO + 区块链 = 比特币系统 POW共识机制proof of work通过挖矿保证我是个善意的节点，并获得生成区块，和在这个区块里记账的权利 区块的生成和连接 比特币由挖矿而产生，通过计算出一个算计数字nonce 生成的BTC被记录在矿工名下，通过矿工的公钥的哈希值锁定 交易的输出被称为UTXO，unspent transaction output,未花费交易 比特币钱包余额就是根据众多UTXO计算出来的 新区块通过包含前一个区块头部的哈希值建立链接关系。 区块链有时会产生临时的分叉而生成两条链，最终较短的链将被舍弃 UTXO的生成和销毁交易包含三项， 交易的输入，UTXO指针 交易的输出，UTXO 解锁脚本，私钥签名，公钥 比特币架构比特币前端钱包保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。 签名、钱包加密、备份、密钥导入、导出。 钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。 非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。 决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。 根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。 移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。 桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易 互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。 纸钱包，字面意思 HTTP/JSON RPC APIAPI，给外部提供查询余额，支付和转账的接口 命令行工具bitcoin-cli基于API开发的命令行工具 比特币浏览器bx比命令行工具更强大的工具 图形开发工具Qt比特币核心是Qt开发的，是比特币使用最广的客户端 比特币节点后端比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。 区块链管理区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。 下载区块链，先下区块头，再并发下载区块体 接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。 区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了 重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易区块验证比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。 脚本是基于堆栈的一些命令。 内存池管理mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。 内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。 邻节点管理当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。 发现邻节点的方法。 用DNS种子查询DNS。比特币核心带有5个DNS种子 把一个已知的邻节点作为种子节点。共识管理比特币的关键是在陌生P2P环境监理共识机制。 比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。 比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。 规则管理比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理 密码模块crypto模块主要是处理比特币地址。 私钥产生公钥。公钥经过几步产生地址 SHA256哈希处理 RIPEMD160哈希处理得到一个160位的结果 Base58Check编码 Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误 签名模块比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。 secp256k1曲线比其他曲线具有更高的性能。 脚本引擎基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。这样设计是不希望矿工有能力提交一个可能有死循环的脚本。 比特币作为一个虚拟货币系统，这样的设计已经足够。 挖矿中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。 CPU&gt;GPU&gt;FPCA&gt;ASIC HTTP/JSON RPC 服务端提供接口来控制比特币节点 Berkeley DB和LevelDB数据库Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。 LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。 P2P网络管理在P2P网络上实现和其他邻接点的通信功能 ZMQ队列管理采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"区块链中的密码学技术","slug":"区块链中的密码学技术","date":"2018-06-29T10:10:10.000Z","updated":"2018-06-29T10:10:30.000Z","comments":true,"path":"2018/06/29/区块链中的密码学技术/","link":"","permalink":"https://benny233.github.io/2018/06/29/区块链中的密码学技术/","excerpt":"","text":"哈希算法一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认证。 在比特币系统中，基于寻找给定前缀的SHA256哈希值，设计了工作量证明的共识机制 哈希算法的性质与应用抗碰撞性就是 两个信息具有相同的哈希值是不可能的 原像不可逆不能根据哈希值推导出原值 难题友好性没有便捷的方式去产生一个特定要求的哈希值，只能穷举。 哈希指针链用于验证信息是否发生改变。区块链可以看做一类使用哈希指针的链表。 Merkle树一类基于哈希值的二叉树或多叉树。区块链中的Merkle树是二叉树，用于存储交易信息。 叶子： 数据块的哈希值 节点： 孩子节点的哈希值 用于检测数据副本的一致性，以减少传输的数据量。 公钥密码算法椭圆曲线密码算法secp256k1椭圆曲线椭圆曲线签名与验证签名先放一放，现在不感兴趣。等需要的时候再来学","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"敏捷编码","slug":"敏捷编码","date":"2018-06-23T15:35:05.000Z","updated":"2019-10-09T10:42:50.481Z","comments":true,"path":"2018/06/23/敏捷编码/","link":"","permalink":"https://benny233.github.io/2018/06/23/敏捷编码/","excerpt":"","text":"本文为《敏捷开发修炼之道》中敏捷编码一章的总结 介绍随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行正确的代码编写方式。 代码要清晰地表达意图 用代码沟通 动态评估取舍 增量式编程 保持简单 编写内聚的代码 告知，不要询问 根据契约进行替换 代码要清晰地表达意图PIE(Program Intently and Expressively)原则，意图清晰，表达明确 充分语义化，尽量不看定义也能明白 使用方法名传达意向，方法参数名帮助读者理解背后的想法 正确的使用和命名异常 使用语言特性提升表现力 好的编码规范可以让代码容易理解，同时减少不必要的注释和文档 编写清晰而不是讨巧的代码，比如位移操作可读性就不好 想象一年后的自己来阅读代码，读一次就能明白 有意图的编程不是创建更多的类或者类型，这不是过分抽象的理由 使用合适的耦合。例如，通过散列表进行松耦合。散列表存储紧密耦合的组件没有明确的表示意图 用代码沟通读代码的方式：先阅读注释，然后快速浏览代码。从而理解它做了什么，为什么这么做 建立代码文档有两种方式，利用代码本身以及利用注释来沟通代码之外的事情 适当的注释和良好的代码能让人快速理解代码。知道代码的意图，结果和需要注意的地方。 优雅清晰的代码优雅的代码易于辨识和理解，简洁，第一眼看上去就知道它的用处 变量名运用正确 空格使用得当 逻辑分离清晰 表达式简洁 清晰的执行路径 好名字 好名字向读者传递大量信息，不好的名字无法传递信息，糟糕的名字传递错误的信息 遵循习惯用法。比如i表示循环索引量，s表示字符串 适当的注释 克制在方法体内部的注释。 为读者指定一条正确的代码访问路线图 为代码中的每个类或模块添加一个短小的描述，说明目的以及要求 对于类中的每个方法，可能要说明四点。目的，输入，输出和异常 注释不能替代优秀的代码 在代码可以传递意图的地方不要使用注释 解释代码做了什么的注释用处不大。注释要说明为什么这样做 重写方法时，保留描述原有方法意图和约束的注释 动态评估取舍错误观点：性能、生产力、优雅、成本、以及上市时间，在软件开发过程中都是至关重要的因素，每一项都必须达到最理想状态正确观点：如果性能表现足够了，就把注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化 由用户或者利益相关者来评估性能是否足够，界面是否吸引人 即使不能面面俱到，你也应该得到最重要的东西——客户认为有价值的特性 如果现在要投入额外的资源和精力是为了将来可能得到的好处，那么要确认投入一定要得到回报 真正的高性能系统，从一开始设计时就在向这个方向努力 过早的优化是万恶之源 增量式编程在很短的编辑/构建/测试循环中编写代码，可以创建更加清晰、简单、易于维护的代码 采取增量式编程，会更倾向于创建更小的方法和更具内聚性的类 如果构建和测试花费的时间过长，你就不会经常运行它们了。要保证测试可以快速运行 在编译和测试中，停下来想一想，并暂时远离代码细节，这是保证不会偏离正确方向的好办法 要像重构代码一样重构测试，并且经常重构测试 保持简单 不要过度设计 开发可以工作的、最简单的解决方案。就是没有一行多余代码，并且仍能交付全部功能 使用模式、原则和高难度技术要有明确的目的 代码几乎总可以得到进一步精炼，但是到了某个点之后，再做改进就不会带来实质性的好处了。这时就改停下来去做其他的事情了 强行让代码变得优雅与过早优化一样，会产生恶劣的影响 简单不是在功能上妥协 简单不是单纯的代码量少，要兼顾可读性 一个人认为简单的东西，可能对另一个人意味着复杂 编写内聚的代码内聚性用来评价一个组件中成员的功能相关性。内聚性高说明各成员共同完成了一个或一组功能特性 好处： 稳定，维护成本低 可重用性高 责任清晰，易跟踪，易修改 方法： 在创建一个类的时候，想一下，这个类的功能是否与其他类的功能相似 让类的功能尽量集中，组件尽量小，避免创建很大的类 拆分太小也不行。 告知，不要询问作为某段代码的调用者，开发人员绝不应该基于被调用对象的状态来做任何决策，更不能改变该对象的状态，这是被调用对象的责任。在对象之外替他做决策，违反了封装原则，而且为bug提供了土壤。 这一条我没理解。想象不出场景 根据契约进行替换替换组件代码，其他代码无感知 通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。委托比继承灵活","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[]},{"title":"合作的进化","slug":"合作的进化","date":"2018-06-17T12:41:59.000Z","updated":"2019-12-01T08:30:13.413Z","comments":true,"path":"2018/06/17/合作的进化/","link":"","permalink":"https://benny233.github.io/2018/06/17/合作的进化/","excerpt":"","text":"博弈论经典之作。罗小蔓解读。 囚徒困境从个人利益来说，背叛比合作好。从共同利益来说，合作比背叛好。“重复囚徒困境”就是背叛还是合作的选择会进行多次 一报还一报策略一句话总结就是，合作就奖励，背叛就惩罚。 它有四个优点。 善良性：在一开始主动释放善意 报复性：坚持自己的原则，对合作和背叛都给与相应的回报 宽容性：对给背叛者改正的机会 清晰性：通过善意与规则清楚地传达合作意愿 利益追逐自身利益是个体的本能，因此想要鼓励合作的产生，最好的办法就是让合作带来的利益大于背叛能够带来的。 如果想要委婉一些或者降低成本，可以增加合作的步骤，给双方制造更多互相报复的机会，避免一锤子买卖。忌惮于对方的报复，就会更倾向于合作。 信誉信誉不只有诚信度，还包括行事风格，是宽容大度的老好人还是报复心中的小心眼。老好人容易吸引爱占便宜的坏蛋。 良好的信誉既能吸引好的合作方，也会警告哪些爱占便宜的人与你保持距离 促进合作的条件 增加未来对现在的影响，增加基础频率 提高合作收益，未来收益大于眼前收益的2/3 塑造信誉，一报还一报 维持合作的方法 不要嫉妒 不刷小聪明 对合作和背叛都要给与回报","categories":[{"name":"综合能力","slug":"综合能力","permalink":"https://benny233.github.io/categories/综合能力/"}],"tags":[]},{"title":"iterm快捷键总结","slug":"iterm手册","date":"2018-06-04T15:38:02.000Z","updated":"2019-10-10T08:22:16.563Z","comments":true,"path":"2018/06/04/iterm手册/","link":"","permalink":"https://benny233.github.io/2018/06/04/iterm手册/","excerpt":"","text":"iterm2的快捷键总结 标签新建tab：⌘ + t 切换 tab： ⌘+←, ⌘+→ ​ ⌘+{, ⌘+} ​ ⌘ + Num 切换全屏：⌘ + enter 关闭tab：⌘ + w 分屏切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分； 切换Tab中的pane：⌘ + [ / ] 按方向切换 pane：⌘+Option+方向键 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原 关闭panel：⌘ + w 全局智能查找，支持正则查找：⌘+f 全屏展示所有的 tab，可以搜索：⌘+Option+e 自动填充：⌘ + ； 命令补全提示 打开最近目录： ⌘ + alt + / 窗口太多，快速定位到光标所在位置：⌘ + / 鼠标所在行高亮显示： ⌘ + alt + ； ⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作 ⌘+Shift+h弹出历史记录窗口 快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了 双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。 按住⌘键可以拖拽选中的字符串 可以点击 url：调用默认浏览器访问该网址 可以点击文件：调用默认程序打开文件 如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行 点击文件夹：在 finder 中打开该文件夹 标记设置标记：⌘ + shift + m 跳转到上个标记：⌘ + shift + j 多个标记切换：⌘ + shift + arrow(上下) 其他置空屏幕: clear ​ ctrl + l ​ ⌘ + k 清空屏幕: command + k/r 字体调大: command + + 字体调小: command + - 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 从光标处删至字首/尾：ctrl + w / k","categories":[{"name":"手册","slug":"手册","permalink":"https://benny233.github.io/categories/手册/"}],"tags":[]},{"title":"区块链架构","slug":"区块链架构","date":"2018-05-26T14:47:23.000Z","updated":"2018-06-29T10:07:43.000Z","comments":true,"path":"2018/05/26/区块链架构/","link":"","permalink":"https://benny233.github.io/2018/05/26/区块链架构/","excerpt":"","text":"基本定义这里有一段很好的关于架构的讲述，就不完整的抄了 架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构、组成的组件以及组件之间的关联关系。动态层面主要规范组件的行为以及组件之间的交互协议。根据系统的架构，可以界定系统的功能特性和非功能特性。功能特性是特点，非功能特性是不可缺少的共性部分。 架构设计要考虑不断变化和恒久不变的两方面。 一个有长久生命力的系统都有一个设计高明的架构，其精髓在于架构能支持系统功能的变化、发展、演化，允许系统功能不断变化，也就是架构必须提供灵活性。 而系统对易用性、安全性、稳定性和性能却应该是恒久不变的，因此IT架构的设计必须强调非功能特性，其中 开放性 可扩展性 可移植性 可维护性 灵活性 安全性 性能(响应时间、吞吐率、并发数) 1.0 例如比特币，支撑虚拟货币应用，也就是与转账、汇款和数字化支付相关的密码学货币应用。 2.0 2.0支撑智能合约应用，合约是经济、市场和金融的区块链应用的基石。2.0应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。 3.0 超越货币、金融和市场的范围的去中心化应用，特别是在政府、健康、科学、文化和艺术领域的应用。 比特币架构比特币前端钱包保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。 签名、钱包加密、备份、密钥导入、导出。 钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。 非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。 决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。 根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。 移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。 桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易 互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。 纸钱包，字面意思 HTTP/JSON RPC APIAPI，给外部提供查询余额，支付和转账的接口 命令行工具bitcoin-cli基于API开发的命令行工具 比特币浏览器bx比命令行工具更强大的工具 图形开发工具Qt比特币核心是Qt开发的，是比特币使用最广的客户端 比特币节点后端比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。 区块链管理区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。 下载区块链，先下区块头，再并发下载区块体 接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。 区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了 重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易区块验证比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。 脚本是基于堆栈的一些命令。 内存池管理mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。 内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。 邻节点管理当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。 发现邻节点的方法。 用DNS种子查询DNS。比特币核心带有5个DNS种子 把一个已知的邻节点作为种子节点。共识管理比特币的关键是在陌生P2P环境监理共识机制。 比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。 比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。 规则管理比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理 密码模块crypto模块主要是处理比特币地址。 私钥产生公钥。公钥经过几步产生地址 SHA256哈希处理 RIPEMD160哈希处理得到一个160位的结果 Base58Check编码 Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误 签名模块比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。 secp256k1曲线比其他曲线具有更高的性能。 脚本引擎基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。这样设计是不希望矿工有能力提交一个可能有死循环的脚本。 比特币作为一个虚拟货币系统，这样的设计已经足够。 挖矿中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。 CPU&gt;GPU&gt;FPCA&gt;ASIC HTTP/JSON RPC 服务端提供接口来控制比特币节点 Berkeley DB和LevelDB数据库Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。 LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。 P2P网络管理在P2P网络上实现和其他邻接点的通信功能 ZMQ队列管理采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。 以太坊架构核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。 账户设计两种账户。外部所有账户EOA和合约账户。 以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。 合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。 区块链设计Merkle Patricia树 PoW机制Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。 计算和图灵完备EVM高级语言以太坊P2P网络节点间使用RLPx协议，Dapp间用Whisper协议 事件合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。 3.0 超越货币，金融范围的区块链应用超宇货币和金融范围，特别是政府、健康、科学、工业、文化和艺术的应用支持广义资产、广义交换、支持行业应用。支持行业应用意味着具备企业级属性。其中安全性最突出。同时对网络和共识算法的性能、每秒交易数TPS都有比较高的要求。可以不是完全去中华的架构，最有可能是在不同场景下的混合架构。 通用架构典型应用自动化采购智能化物联网应用供应链自动化管理虚拟资产兑换、转移产权登记互联链架构剖析不同链的价值转移","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"共识算法详解","slug":"共识算法详解","date":"2018-05-26T12:14:43.000Z","updated":"2018-06-29T10:07:38.000Z","comments":true,"path":"2018/05/26/共识算法详解/","link":"","permalink":"https://benny233.github.io/2018/05/26/共识算法详解/","excerpt":"","text":"共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点 共识算法的假设条件有以下几种， 故障模型： 非拜占庭故障/拜占庭故障 通信模型： 同步/异步 通信网络连接： 节点间直连数 信息发送者身份： 实名/匿名 通信通道稳定性： 通道可靠/不可靠 消息认证性： 认证消息/非认证消息 由于应用场景的不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，私有链和联盟链对一致性、正确性要求更高，一般采用强一致性的共识算法。公有链对一致性和正确性通常没法做到百分之百，通常采用最终一致性Eventual Consistency的共识算法。 拜占庭容错技术拜占庭将军问题拜占庭容错系统实用的拜占庭容错系统Raft协议Raft基础leader选举记账过程PoW一句话解释，根据投入的算力来选择记账节点 会导致算力浪费 穷举法找到一个符合要求的哈希值。 工作量证明函数区块难度值PoW的过程基于PoW的共识记账关于比特币PoW能否解决拜占庭将军的问题PoS一句话解释，根据拥有的货币数量来算则记账节点 会导致中心化 用户证明拥有某些数量的货币(即对货币的权益) PoS的应用点点币结合币龄 随机区块选择NXT和blackcoin采用随机方法预测下一合法区块，使用公式查找与权益大小结合的最小哈希值 基于权益速度的选择Reddcoin引入权益速度证明，即鼓励钱币的流动而非囤积。通过给币龄引入指数衰减函数，使得币龄不会超过2币月 DPoS股份授权证明机制 Delegated Proof of Stake,期望通过引入一个技术民主层来减少中心化的负面影响 持股人投票选出见证人。见证人按序生成区块。 Ripple共识算法基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。 参与投票节点的身份是事先知道的，因此算法的效率比PoW高，交易的确认只需要几秒钟。这点也决定了它只适合权限链。 容忍20%的拜占庭错误 Ripple的网络结构Ripple共识算法小蚁共识机制PoW、PoS、DPoS确定谁有记账权。小蚁侧重于解决如何限制记账人权利的问题。这种记账机制被称为中性记账。记账人只有选择是否参加的权利，而不能改变交易数据，不能认为排除某笔交易，也不能对交易排序。 总结PoW安全性和公平性强一些。PoS和DPoS更环保高效。 PoW和PoS比较适合公共链环境，PBFT和Raft适合联盟链和私有链的分布式环境。 比特币的PoW机制是一种概念性的拜占庭协议，能在一定程度上解决拜占庭问题，而PoS等其他机制 并没有严格分析其在拜占庭协议方面的属性。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"以太坊笔记","slug":"以太坊","date":"2018-05-25T10:12:03.000Z","updated":"2018-06-29T10:07:33.000Z","comments":true,"path":"2018/05/25/以太坊/","link":"","permalink":"https://benny233.github.io/2018/05/25/以太坊/","excerpt":"","text":"以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。比特币没有账户的概念，只有UTXO。需要计算。 以太坊架构智能合约部署在以太坊虚拟机上，通过虚拟机和RPC接口和底层区块链进行交互 核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。 账户设计两种账户。外部所有账户EOA和合约账户。 以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。 合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。 区块链设计Merkle Patricia树 PoW机制Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。 计算和图灵完备EVM高级语言以太坊P2P网络节点间使用RLPx协议，Dapp间用Whisper协议 事件合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。 以太坊技术以太坊核心概念EVM由许多互联的计算机组成。程序按照EVM定义的方式运行在其上。任何人都可以为所有权、交易格式和状态转换函数创建商业逻辑 账户两类账户，公用一个空间地址。 外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。 合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。 以太坊的账户包含四个部分 随机数，用于确定每笔交易只能被处理一次的计数器 账户目前的以太币余额 账户的合约代码（如果有的话） 账户的存储（默认为空） 消息类似于比特币的交易，主要有3点不同： 以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建 以太坊消息可以选择包含数据 如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念 交易指存储从外部账户发出的消息的签名数据包。交易包含： 消息的接受者 用于确认发送者的签名 以太币账户余额 要发送的数据 STARTGAS，通过需要支付的燃料来对计算步骤进行限制 GASPRICE，每一计算步骤需要支付给矿工的燃料 Gas每笔交易都会被收取一定数量的Gas，其目的是限制交易执行所需要的工作量，同时为交易的执行支付费用。 存储、主存和栈每个账户都有一块永久内存区域，成为存储，key-value形式。存储的读写开销比主存和栈大。合约只能对自己的存储进行读写。 第二个内存区叫主存，合约执行每次消息调用时都有一块新的被清除过的主存。 EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈的区域内执行。 指令集EVM指令集被可以保持在最小规模，以尽可能的避免可能导致共识问题的而错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作还有条件跳转和无条件跳转。 此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 消息调用合约通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，目标，数据负载，以太币，Gas和返回数据。 事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会一次产生更多的消息调用。 代码调用和库callcode是一种特殊的消息调用。加载来自目标地址的代码将在发起调用的合约上下文中运行。用来实现库。 以太坊状态转换一个交易发生时，从一个状态转换到下一个状态 以太坊客户端go语言客户端Geth 客户端浏览器Mist 以太坊智能合约智能合约由尼克萨博提出，几乎与互联网同龄。但一直没有可信的执行环境，以太坊首先实现了区块链和智能合约的完整契合。 以太坊这方面的特性有： 图灵完备性 价值意识(value-awareness) 区块链意识(blockchain-awareness) 多状态开发语言以太坊有四种专用语言： Serpent(Python) Solidity(Js) Mutan(Go) LLL(Lisp) 图灵完备，可以解决所有的计算问题。但是半图灵完备，因为通过对计算量设置上限来避免图灵完备语言的无法停机的问题。 代码执行以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的。可以访问三种存储空间。 堆栈 内存，可无限扩展的字节队列 合约的长期存储，一个秘钥/数值的存储堆栈与内存计算结束就重置，长期存储会保持。以太坊的去中心化应用什么是DappDapp由智能合约和客户端代码构成。类似于后端和前端。智能合约跑在区块链上。 应用举例","categories":[{"name":"区块链","slug":"区块链","permalink":"https://benny233.github.io/categories/区块链/"}],"tags":[]},{"title":"TDD笔记","slug":"TDD笔记","date":"2017-12-21T11:22:36.000Z","updated":"2019-10-09T10:43:05.489Z","comments":true,"path":"2017/12/21/TDD笔记/","link":"","permalink":"https://benny233.github.io/2017/12/21/TDD笔记/","excerpt":"","text":"12345678graph TD需求提出--&gt;抽象出模型抽象出模型--&gt;转化出测试用例转化出测试用例--&gt;TDD:定义接口测试接口抽象出模型--&gt;|not TDD|codeTDD:定义接口测试接口--&gt;提交PR并讨论提交PR并讨论--&gt;codecode --&gt;整合 自己写测试的心得普通写代码就是直接撸，写成啥是啥，错了就改正确的写测试就是 先想好接口，根据接口来写测试用例，最后再写代码去通过测试这就叫谋而后动 今天跟了一个测试教程学会了测试语言describe it before after(mocha) expect(supettest) 在egg中写测试这是应用的单元测试，不是插件和框架的单元测试 内置的egg-bin模块，这个模块已经内置了所有测试所需要的好用的模块。包括：Mocha、co-mocha、power-assert，istanbul测试mock辅助模块egg-mock 第一步，编写测试基础讲解第二步 配置测试在==package.json==中配置==script.test==12345&#123; \"scripts\":&#123; \"test\":\"egg-bin test\" &#125;&#125; 第三步 启动测试1npm test 打开TDD的正确姿势 TDD是什么tested dirven development,测试驱动开发 TDD的核心做好需求分析和设计，将==需求==拆解 为什么要测试，什么时候测试因为错误不可避免，要排除错误减少损失测试越早越好，因为错误绝大部分错误是在早期引入的，发现在中后期错误造成的损失随着时间呈现指数级的增长，越早发现，成本越低。这是软件测试的作用 测试驱动开发的作用：测试是根据需求来的，测试用例就是各个需求点，只要通过测试，模块的行为就能确保正确。在修改的时候做测试也能确保没有修改出错误。 测试的概念单元测试：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。就是该部分能否正常工作 测试用例：进行单元测试使用的例子 单元测试不通过说明要么有bug，要么测试用例不正确 测试正确说明，对该函数的修改没有对原来的行为造成影响。 测试驱动，是测试的什么？测试个模块的接口检验是否满足规定的需求，找出与预期的差异 测试效果的指标提高测试覆盖率，测试效率 测试的误区盲目追求覆盖率 测试的工具mochamocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。 使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。 mocha的特点主要有： 既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一； 可以自动运行所有测试，也可以只运行特定的测试； 可以支持before、after、beforeEach和afterEach来编写初始化代码。 describe包裹it们 第一个参数是测试的名字 第二个参数是一个函数，函数里是it it是各个测试用例 第一个参数是测试用例的描述 第二个参数是一个函数，函数体就是测试的内容，assert们 supertest网络测试构造请求，expect断言 判断回复 node自带断言库 assert如何写好测试所有人都假设TDD以后软件质量一定提高到最高境界了，但是测试代码也是代码，也有合理不合理的问题，也有价值与维护成本，不好的测试代码会降低效率那么如何写好测试代码呢 测试的核心是“可测试“，可测试意味着好的代码架构，写出可测试代码是优良测试的必要条件。 测试驱动开发不是测试人员驱动。这种开发方法完全是开发人员自行实施的，要点在于开发功能之前先开发该功能的测试程序，当然一开始测试程序的结果是失败的，然后去实现功能，让测试结果成功通过测试驱动也不是测试驱动项目运转 因为国内大多数程序员写的代码粒度太粗，无法测试。 编写测试的原则是，一次只测一种情况，且测试代码要非常简单。 TDD和时间的关系 如果时间够，自然可以TDD。如果时间不够，有人可以tdd，测试先行，不代表真的要先写测试。tdd像一种工具或者流程，其背后有它自己的思维，掌握了思维，没有按流程出招，或许就表示tdd已死了吧。如果楼主是指形式或者招式，那么其在某些情况下还是继续存活的。比如时间足够，而程序员足够热爱它 TDD只是一个概念，时间允许的话每个重要的方法业务都写单元测试，涉及正确性测试，边界测试，错误测试等等。之后代码有改动再跑单元测试就可以了。这样开发会节省挺多时间。 和时间的关系，写测试要消耗时间这是一个问题，很多公司的迭代周期比较短，比如半个月。那么如何搞TDD呢 TDD的好处 TDD好处其实很简单： 帮你整理需求 帮你设计接口（空想的话很容易设计出屎） 帮你做regression和给以后重构做准备 提高程序健壮性 TDD会鼓励你对现有代码，更频繁，更敏捷地进行改变它带给你的是，更少的regression，更少的debuggingtime，以及更多的勇气来refactor 是tdd重新让我编程的信心和乐趣。我不爱用眼睛看检查运行结果，只要改动之后，一运行看到一长排的勾我就去冲杯香飘飘喝吧喝吧，喝了睡觉去了 过度测试是存在。但一些看似过度的testmethod确实揪出了bug。国内中小公司(没去过大公司，不知道啥情况)从上到下对测试总是抗拒的态度。他们会迷惑如何在需求变更中控制缺陷，却不愿试着作任何改变。整天鼓吹熬夜搬砖的人是没法沟通的:(。所以总是测试不够，而非过度 要会单元测试，没有deadline的威胁，就是时间要足够适合思路发散常常迷糊的人，让人有安全感，能确定想法落实了可以灵活一些，比较高层的feature在确保接口可测试的前提下，没必要完全tdd。 TDD是否已死先不说，很多程序员连写出基本的整洁代码都做不到，还能指望他先写测试吗？写代码绝对是个技术活，而不是体力活。所以，写代码需要不断修炼，比如code dojo, code kata 至于是否用TDD方式写代码，倒不一定。如果程序员的思维转变，写代码之前先考虑到测试用例、测试场景，也是一个很大的转变，即测试先行。 我觉得TDD不火的原因是它对developer的素质要求非常高。新手看到TDD会欢欣鼓舞，但是他们没有能力来实践。老手们在项目的压力下，早就麻木了，先写case还不如写好代码再补case呢，很多东西我还没时间想清楚，怎么写case？不如先写个小功能先，边写边改，等稳定下来再补case. 所以对老手来说也需要不断练习，才能熟悉TDD. 其实我们的目的是为了快速的交付有价值，有质量的产品或者服务，赢得公司的生存和发展空间。为了达到这个目的，我们有很多种的手段。但手段不是目的。有很多盲目推崇TDD的所谓敏捷专家，其实是把手段当做目的，而忽略了问题的本质 首先理清一个价值观问题，是方法论为生产力服务还是生产力为方法论服务TDD的错误在于，他没有尊重程序员尊重开发实际，让非生产代码通知生产代码 TDD 力量和问题都源自 test first。要能 test first，写代码之前要想得更清楚；代码得要有良好的可测试性，而为了可测试性要做一些不直接产生效益的工作；两者都既能推动思考，也能限制思考。TDD 是正确的思想：程序员要保证代码的正确性，和不完美的实践：程序员写测试。 目前我们团队也在想办法推行TDD，但是不是标准的TDD，而仅仅是测试先行，并且不用mock这样做可以在实现业务代码之前对于自己的程序要实现什么有一个清晰的认识，而且写程序的过程也变成了“跑通我的单元测试”的过程，这样更加有目标和针对性，当你看到你写完的业务代码能跑通单元测试的时候，是否有种游戏过关的成就感呢？等到全员都逐渐适应这种测试先行的做法，再“得寸进尺”，多要求一点点。 测试先行，怎么和开发做交互呢？什么时间调用开发的方法？测试先行是说在实现业务逻辑前先写完单元测试，此时的单元测试肯定不通，之后再逐渐针对测试完善业务代码，最后跑通测试的时候业务代码也就完成了。不是让测试人员先测的意思 TDD解决了：1）我要开始写代码了，我从哪开始。 搞个main，还是搞个test2）我不知道那个家伙的代码写的怎么样，以后会不会捅个篓子，要求他TDD好了。CodeReview的时候也轻松点。飞机上写几个小时代码，下来编译一遍过还没有bug的人。你跳出来说，他没有tdd，他LowB，那你是不是有毛病。总之一句话，各种方法论都是解决一个问题——人不行。 软件开发说到底还是抽象和逻辑的艺术，TDD只是一种辅助开发手段，并不会减少因为开发人员素质不过硬或者工期短赶工而在开发过程中产生的抽象和逻辑问题。从来没听说过历史上哪位编程高手是因为什么方法论而练成的，人家是数据结构、算法、抽象和逻辑能力真的强大。对了，除了TDD，那什么敏捷、XP、结对、DDD等等，所有抛开实际抽象和逻辑问题的方法论，都是垃圾。 更重要的是 基础的是 数据结构算法 抽象 逻辑能力 TDD在什么情况下最有效？ 一个老系统， 老系统有还不错的test case 有很多相关系统依赖老系统 老系统要推翻重做 先阐明观点，TDD没死，只是存活着在一些技术及配合要求比较高的团队，并且是挑业务的。我在互联网行业摸打滚爬了蛮久，历经各种项目，包括PC、游戏、云存储、电商等项目，TDD也是我这几年年一直在推动的事情，大部分失败了，也有些收获，这里大致把所了解以及个人见解说下。拿我所熟悉的互联网行业来说吧，其他传统软件行业经历时间太早，离当前较远，就不乱说了。现在互联网大都流行敏捷开发，其模式大家可自行度娘，但是真正做到的貌似没有，最少我没见过或者听过，很难用定性的词语来形容（语文不好），用个相似度来说吧，当前BAT公司排序为BTA（还是个人见解），用我个人的说法就是作坊式开发，忽略很多流程，只留下骨干的评审、开发、用例评审、转测、回归发布的流程。这个模式特点就是快，从需求提出到发布上线，一般都是一两周的时间，现有三周才能开发完成的业务。当然这里也有提出异议，说我太片面了，不过我说的大部分的互联网公司业务，保守估计60%的比例吧。解释完了互联网公司的开发模式，接下来我们回到TDD，至于TDD的概念，我就不科普了，自行度娘。其中TDD有一个特点非常明确，基本上可以作为是否做到的标签。这就是测试架构先于开发完成，并可对开发完成大部分模块进行测试（个人的理解，标准定义自行百度）。为了达到这个目的，我们搬出几个要素出来：时间、人、效果、方式。时间：什么时候完成，项目时间大约多久可以做TDD，TDD占项目时间大约多少比例合适。人：谁来做，一个人的项目我这里不谈，只谈多人协作项目，开发做还是测试来做？效果：要达成什么效果，以什么为合格的TDD的指标，功能覆盖？代码覆盖率？方式：要怎么做，开发一套自动化框架，还是用先协商接口用单测来完成，这里特别要提出的是，需要考虑后期维护的代价。 TDD 推行的最大问题在于，大多数程序员还不会「写测试用例」和「重构」。我认为推行TDD主要在两个方面努力，即意识和能力（好像任何事情都是这两方面哈）。意识方面主要是：认识到自己原有编程方法的不足；搞清楚TDD的价值所在，如何弥补原有方法的不足；心态开放，勇于尝试新鲜事物，不要浅尝辄止，要持续改进。意识和能力没有先后关系，而是在不断学习和实践过程中同时提高。在这篇文章中，我更想谈的是能力。我见到初接触TDD的人常犯下面的错误：在声明测试方法后，便开始写实现代码；写完“所有”的测试代码才开始写实现；一次实现过多的代码（超出当前测试覆盖的业务）；从不重构；测试实现细节而不是接口行为；TDD真是看起来容易，做起来难。 1234graph LRRed--&gt;GreenGreen--&gt;RefactorRefactor--&gt;Red 上面这个图一目了然，但其实每一步都是对能力有要求的：红测试先行并不是说不需要思考，直接开始写代码。在开始写代码之前要进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断循环去实现。测试代码其实是产品代码的“用户”，在写测试代码时你就要考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实我们就是在做设计，而且设计以代码来体现，比在脑袋中空想要更直观。很多人不懂“意图式编程”，总是习惯先实现一个东西，再去调用它。而测试先行就要求先使用，再实现。这样能少走很多弯路，减少返工。无法把测试前置的原因往往在于，测试的是「实现」，也就是你写的是「白盒」测试。这样的测试根本没有价值，重构的时候会成为维护负担。而好的做法是测试「做什么」，而不是「怎么做」。绿以最快的速度让测试变绿，意味着我们通常用最直接但可能并不优雅的方式，比如复制代码。然后小步重构，直到符合简单设计的原则：通过所有测试每个概念都被清楚地表达没有重复没有多余的东西难的是要让实现刚好满足当前的测试，不做过度的设计，不写多余的代码。因为如果你写多了，除了引入复杂性以外，多的那部分就没有测试能覆盖到。或者你后面的测试写出来就能直接变绿，你就没办法按TDD的节奏进行下去了。重构首先要能识别坏味道，一些低级的Smell，很容易识别，比如：Magic Number，重复代码，太大的类，太长的方法，命名等。但更高级的如Feature Envy，Lazy Class等就比较难以识别。只要识别到Smell，知道用什么手法去重构，剩下的就比较简单了，现代的IDE，尤其是JetBrains的产品，对重构的支持非常强大，几乎都可以用快捷键完成。选对工具非常重要，善假于物能极大提高开发效率。但也不能过分依赖工具，要明白每一个手法背后的原理。所以推荐每个想要实践TDD的开发者，一定要先读《重构》。最后我想说：TDD不是银弹，不可能适合所有的场景，但这不应该成为我们拒绝它的理由。也不要轻易否定TDD，如果要否定，起码要在认真实践过之后。 TDD教程总览 TDD的理解和讲解 基线描述 能够讲出来科学的TDD步骤，和TDD的三个主要的状态掌握mock技巧，能够讲出几种mock的场景了解SetUp的作用会写TestCase给出题目可以驱动着写出来细节如下： 能够讲出来科学的TDD步骤，和TDD的三个主要的状态 正确的TDD的步骤至少包含下面的几个点，写一个TestCase，运行，得到期望的失败，写实现，重构","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[]},{"title":"基础数据结构","slug":"基础数据结构","date":"2017-12-21T11:21:07.000Z","updated":"2018-06-14T02:56:38.000Z","comments":true,"path":"2017/12/21/基础数据结构/","link":"","permalink":"https://benny233.github.io/2017/12/21/基础数据结构/","excerpt":"","text":"数据结构，数据存储的方法，包括数据对象，和操作集，不包括具体实现。具体实现是算法 数组检索简单，增删难 集合Set，不重复的数组 链表增删简单，检索难。插入删除内存和时间消耗小，查询消耗大，适合插入多，查询少的情景 广义表：是线性表的推广，元素可以是另一个广义表 多重链表：节点可能属于多个链表，双向链表不是多重链表。树和图就是用多重链表实现 稀疏矩阵用多重链表存储。 栈先进后出 表达式求值，递归，函数调用，深度优先搜索，回溯算法 具有一定操作约束的线性表 栈的实现一维数组和一个记录栈顶元素位置的变量 链表实现，从头部插入 队列也是一种受限制的线性表，先进先出 普通线性表在所有位置都可以增删，堆栈只在顶部增删，队列只在头尾增删 用链表实现的时候，因为链表的尾部不能执行删除操作，所以队列的头部只能是链表的头部 典型问题 优先队列 循环队列","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[]},{"title":"算法笔记","slug":"算法笔记","date":"2017-12-21T11:20:45.000Z","updated":"2019-10-09T10:42:55.380Z","comments":true,"path":"2017/12/21/算法笔记/","link":"","permalink":"https://benny233.github.io/2017/12/21/算法笔记/","excerpt":"","text":"复杂度计算时间复杂度的方法数循环次数：循环的嵌套 均摊分析：(1+n)/2，一次性的操作平均到整体 递归式:主定理 常见的时间复杂度1:基本运算，+,-,*,/,%,寻址 logn：二分查找 根号n:枚举约数，少见 n:线性查找，很多时候算法的下限就是n，因为数据的读入的复杂度就已经是n了 nlogn：归并排序，快速排序的期望复杂度，基于比较排序的算法下界 n的平方：朴素最近点对，冒泡排序，选择排序 n的三次方：Floyd最短路径，普通矩阵乘法 2的n次方：枚举全部的子集 n的阶乘：枚举全排列 排序算法搜索算法","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[]},{"title":"cs总结","slug":"cs总结","date":"2017-12-21T11:20:37.000Z","updated":"2018-06-14T02:56:48.000Z","comments":true,"path":"2017/12/21/cs总结/","link":"","permalink":"https://benny233.github.io/2017/12/21/cs总结/","excerpt":"","text":"基础熟悉1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 列表解析result = (item.value for item in array when item.name is 'test')# 前十个全局属性(变量)globals = (name for name of window)[0...10]# 对象解析ages = for key, value of Object \"#&#123;key&#125; is #&#123;value&#125;\"# 定义函数square = (x) -&gt; x * x # body... # 定义的时候有括号，调用的时候没括号# 数组song = [ 'do' 're' 'mi' 'fa' 'so']# 对象singers = brother: name:'max' age:11 sister: name:'ida' age:9 s-sister: name:'haha' age:2# if elseif one and/or/is/not two # body...else # body...# 三元判断date = if one and two then value else other# 函数链式调用$ 'body'.click (e) -&gt; $ '.box' .fadeIn 'fast' .addClass 'show' .css 'background', 'white'# 回调写法和胖箭头函数Account = (customer,cart) -&gt; @customer = customer @cart = cart $('.shapping_cart') .on 'click', (event) =&gt; @customer.purchase @cart# promise写法sleep = (ms) -&gt; new Promise (resolve) -&gt; window.setTimeout resovle,ms# async写法直接写在普通函数里，阻塞的执行# 类的写法class Animal constructor: (@name) -&gt; move:(meters) -&gt; alert @name + \" moved #&#123;meters&#125;m.\" # body... 命令行编译命令，1coffee -c -o targetfolder filename 先是两个参数，然后是目标文件夹，最后是编译的文件 数组 数组换行可以省略一个逗号，那就都换行吧，彻底抛弃逗号 直接加尾巴截取数组，还可以直接用来赋值1[0...10] 对象 对象的花括号用缩进代替 函数函数的区别， 定义的时候有括号，调用的时候没括号,调用的时候没有参数也需要括号 函数没有大括号，用箭头识别，箭头左边小括号里放参数，右边是函数体 函数默认返回函数体最后一个表达式的值，可以省略return 空return取消return 变量不需要声明，所以函数名也不需要声明 默认参数 胖箭头函数，作用只是绑定this？ 需要返回一个绑定this的函数的时候使用 async函数直接把await写在普通函数里 词法作用域和变量安全词法作用域变量安全 函数的所有 CoffeeScript 结果都被一个匿名函数包裹 1(function()&#123; ... &#125;)(); 这层安全的封装, 加上自动生成的 var 关键字,使得不小心污染全局命名空间很难发生. 因为被包裹了，用顶层变量, 需要将其作为赋值在 window 上, 或者在 CommonJS 里的 exports 上. 存在操作符(existential operator)可以帮你写出一个可靠的方式找到添加位置; 比如你的目标是同时满足 CommonJS 和浏览器: exports ? this4. 判断语句 一个判断一个赋值的判断简写 1name = value if condition 普通写法,和js相比就是省略了条件的小括号和函数体的大括号 三元判断符 1name = if condition then rightvalue else wrongvalue unless: 不是… ，就执行，是就跳过 12345return 哈哈哈 unless 嘿嘿嘿//如果不是嘿嘿嘿，就返回哈哈哈//如果是嘿嘿嘿，就跳过往下执行//作用：满足嘿嘿嘿才能往下执行//干嘛不用if？ if else 和unless都可以，看个人喜好 变参变参函数定义,参数后加上… 变参函数调用,函数调用后加上… 循环和推导式for in遍历数组1item-operation for item in 数组 两个参数 1for in 循环的参数，第一个是值，i是index 加上判断1item-operation for item in 数组 when item isnt value by控制循环的跨度 for of 遍历对象12345678#遍历所有键值对ages = for key,value of yearsOld &quot;#&#123;child is #&#123;age&#125;&quot;#遍历自有非继承键值对for own key,value of yearsOld#遍历gegerator用from while和until1234# 满足条件就一直执行buy() while supply &gt; demand# 满足条件就不执行了sell() until supply &gt; demand for in + do配合起来，对每一个满足条件的元素执行操作 alias CoffeeScript JavaScript is === isnt !== not ! and &amp;&amp; or ture,yes,on true false,no,off false @,this this a in b [].indexOf.call(b,a) &gt;=0 a of b a in b for a form b for (a of b) a ** b Math.pow(a,b) a // b Math.floor(a/b) a %% b (a % b + b) % b 存在性操作符12345?name# 只要不是null或者undefined就返回truespeed ?= 15# 当speed为null或者undefined的时候执行赋值 自己的总结 没有冒号 没有括号，用换行和缩进控制层级 数组的省略写法 编译之后给module.exports外面套一层自执行函数对导出模块没有影响 if判断里面没有默认return 问题控制返回值，不想让它包裹一层然后返回，可以写return 那么对async函数有影响 资料coffeescript编码风格指南 不喜欢的地方 关于语义化的思考 调用函数的时候，前面一个参数较复杂，后面一个参数需要仔细辨别，没有括号直观3.","categories":[{"name":"技术","slug":"技术","permalink":"https://benny233.github.io/categories/技术/"}],"tags":[]},{"title":"设计需求分析与方案选择","slug":"设计需求分析与方案选择","date":"2017-12-21T11:01:49.000Z","updated":"2018-06-14T02:56:03.000Z","comments":true,"path":"2017/12/21/设计需求分析与方案选择/","link":"","permalink":"https://benny233.github.io/2017/12/21/设计需求分析与方案选择/","excerpt":"","text":"设计师的基本思路是，解决了什么问题，为什么要这样解决 了解问题比提供解决方案重要 设计方案不能令人满意的原因 没有细致的沟通==业务需求==，一直改方案，没有自己的观点 没有仔细的分析==用户需求==，只是简单的进行页面排版 没有对==用户体验路径==进行仔细分析，缺乏一个好的方式引导用户使用 业务需求 = 业务目的 + 业务目标业务目的：为什么要做这块业务，当中存在哪些问题业务目标：做了这块业务之后，产品期望得到怎样的结果 用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标谁在什么时候有什么样的行为，目标是什么 用户体验路径搞清楚用户在使用前，使用中，使用后的各个接触点，确保设计方案能够形成闭环 需求分析四步一 分析业务需求业务需求 = 业务目的 + 业务目标业务目的：为什么要做这块业务，当中存在哪些问题业务目标：做了这块业务之后，产品期望得到怎样的结果 目的是达到了某个目标之后想要做的事情，也就是实现目标的真正动机 例： 业务需求 业务目的 业务目标 注册 通过登记用户信息，以方便产品进行用户管理 提高注册页面的转化率 提供用户注册是一个业务需求，提高注册转化率是它的业务目标。当我们提高了注册转化率，就能获得更多的注册用户数，从而实现有效进行用户管理的目的。 互联网产品常见的目标（提升/降低） 类别 常见目标 产品类 PV，UV，用户数，转化率，留存率，活跃度等等 市场类 传播量，市场份额，各种排名等 品牌类 服务认知，品牌认知，品牌忠诚度等等 营收类 销售量，销售额，利润率，ROI等等 制定具体的目标时，要符合smart原则S:specific，具体M:measurable，可衡量A:attainable，可实现R:relevant，有关联T:time-based，有时限 没有目标导致的结果 方案的讨论容易发散 方案的评估缺乏评判标准 方案的效果无法衡量4. 了解目的和目标之后二 分析用户需求用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标谁在什么时候有什么样的行为，目标是什么 三 分解关键因素用户的动机，担忧，障碍 实现业务目标的关键因素 创造动机，促进用户行为 排除担忧，排除行为前的担忧 解决障碍，解决行为中的障碍 四 归纳设计需求，明确设计策略结果将业务目标，用户目标转化成有效的解决方案 技巧如何将==业务目标==转化为==用户行为==，即通过引导用户的使用来帮助产品实现目标 从设计==用户行为==到设计==用户界面==：用户行为决定了用户界面，用户界面页导致了用户会出现什么样的行为 如何选择解决方案","categories":[{"name":"产品","slug":"产品","permalink":"https://benny233.github.io/categories/产品/"}],"tags":[]},{"title":"用户调研思考","slug":"用户调研思考","date":"2017-12-21T11:00:33.000Z","updated":"2018-06-14T02:55:35.000Z","comments":true,"path":"2017/12/21/用户调研思考/","link":"","permalink":"https://benny233.github.io/2017/12/21/用户调研思考/","excerpt":"","text":"目的拿到小房东手里的房源信息 目标让更多的小房东使用我们的房屋租赁管理工具 问题 远一点这是一个怎样的市场 市场上的房子是什么样的？种类及比例 市场上的房东是什么样的？种类及比例 市场上的租客是什么样的？种类及比例 未来几年内，房子，房东，租客又是什么样的？ 目标用户手里有几套房的，自己运营的房东 这群人有多少？他们有多少房？直接决定我们能做成多大的平台。 个体户足够多才能形成平台，平台足够大才能吸引大房东。 了解这样的个体户。 问题 近我们的目标用户是什么样的人？手里有房子需要租出去的人 我们的功能帮助所有需要把房租出去的人解决问题 他们的数量这决定了我们的平台第一阶段能够有多大 用户画像 一房东，二房东 业余，全职 房子少，房子多 个人，团队 用过工具，没用过工具 学习能力强，不强 使用设备 常用APP 痛点，品牌偏好 不同的产品，用来描述用户的角度有所不同，即用户画像的内容纬度会有所不同 ==场景故事== 时间，地点，干什么 一般会有3~6个用户 ==用户画像==：通过用户的目标，行为，观点，基本信息等，对其真实特征进行勾勒，一般会得到3~6个画像/人物角色，每个画像代表一群真实的人 就像小说里的角色，都是作者观察生活总结出来的典型 画像之后调研比例，形成定量用户画像 他们的日常生活对于工具的需求如何？面向小房东的管理工具？房屋租赁管理的基本需求我们的工具能在多大程度上帮助他们总结这是一个4.6万亿的市场。有前景。","categories":[{"name":"产品","slug":"产品","permalink":"https://benny233.github.io/categories/产品/"}],"tags":[]},{"title":"用研笔记","slug":"用研笔记","date":"2017-12-21T10:53:06.000Z","updated":"2018-06-14T02:55:47.000Z","comments":true,"path":"2017/12/21/用研笔记/","link":"","permalink":"https://benny233.github.io/2017/12/21/用研笔记/","excerpt":"","text":"用户研究概述==用户研究员的能力==，技术技能和非技术技能 技术技能 用户研究能力 人机交互能力 产品分析能力 一，用户研究能力针对产品开发的不同阶段，能够灵活运用各种调研方法，权衡利弊，制定适合的用户研究方案 能够输出高质量的用户调研报告，为产品设计提出合理化建议 用户研究能力包括： 定量分析能力 定性分析能力 定量分析能力： 数据的敏感度 数据分析能力 可熟练使用各类定量研究方法 掌握各类定量研究方法的应用场景及优缺点 独立完成分析的能力 定性分析能力： 对常见定性研究方法，可熟练使用 对各个研究方法有自己的心得体会，掌握技巧 掌握各类定性研究方法的应用场景及优缺点 独立执行研究的能力 二，人机交互能力 熟练掌握人机交互的理论知识 熟悉掌握各终端设计规范 有良好的用户体验意识 可通过用户研究，发现产品设计中的不足，并能提供设计改善建议 三，产品分析能力 对所应聘行业非常了解，有充分准备 对所应聘行业的竞品非常熟悉 对所应聘部门的产品非常熟悉，并有自己的见解 有良好的产品感 热爱互联网产品，对于新兴产品有好奇心，保持对互联网产品的关注和体验 非技术技能 沟通技巧 好奇心 学习能力 敏锐力 用户研究方法论工作中会用到的知识与技能 一，基本研究方法 研究设计，采集工具 数据的获取：外部数据，内部数据 二，统计学知识 基础统计方法 高级统计学方法 数据挖掘（了解，可拓展学习） 基础统计分析主要方法 集中趋势 离散趋势 分布特征 推论统计 相关分析 适用场景 日常数据的初步加工分析 简单分析变量间关系 需要快速输出结果 进行简单分析 要求用研岗要求掌握，相关岗位建议掌握 高级统计方法主要方法 聚类 回归 主成分 因子分析 判别分析 对应分析 多维尺度分析 生存分析 路径分析 结构方程 适用场景 对数据进行深挖掘和分析 分析变量间的关系 趋势预测，用户细分等 要求用研岗要求掌握，相关岗位了解 数据挖掘方法主要方法 神经网络 决策树 适用场景 可实现实时，自动化分析 具备自适应和自学习性 要求拓展学习 三，数据分析思路及框架 常用的分析框架 基于理论的分析模型 比如： 宏观的行业分析框架 微观的分析用户需求 用户满意度 品牌认知 转化 留存的分析框架 四，分析工具及软件 Excel SPSS，专业数据分析软件，比Excel高阶 SPSS modeler， R语言， Amos（拓展学习），LISREL，Python 五，图表制作 基本图表制作 数据可视化 六，报告撰写及演示 PPT制作，演讲能力 七，行业及业务领域知识行业领域知识互联网，垂直细分行业知识 业务相关知识 产品经理 设计 运营 市场营销相关知识 专业知识 用户体验 经济学 心理学 社会学 市场营销等 八，数据洞察和落地 通过数据给出有用的建议 落地跟进 用户定位与需求分析用户研究的‘用户’是谁？用户的定义狭义的用户：产品的使用者 广义的用户还有业务方 用户研究的意义 123graph TDa((业务方-所服务产品))--&gt;b((用户研究-桥梁))b--&gt;c((用户方-产品的目标用户)) 不是简单的将用户的需求告诉业务方，而是要考虑业务方为什么要提供这个产品/功能 业务方也是有需求的 了解双方的需求 测试评估提升用户体验用户体验优化设计目的&amp;内容：使产品更好用易用，产生更大的用户价值 生命是数据分析案例分析：数据分析如何驱动体验优化==用户分群与追踪研究==用户行为来自于用户动机（目标） 用户使用我们的产品（用户行为）产生用户态度 当前时间点下的用户情况 用户画像例子，考霸族简单描述 人生阶段：毕业生 自驱力：强 基本信息姓名，职业，年龄，家庭状况，互联网使用习惯 个性特征学习目的学习习惯付费经历及态度用户画像方法简介 定性用户画像，简单快速 定量用户画像 方法选择的原则 选择定性还是定量取决于 用户画像的受众是谁？设计师?产品经理？ 希望用户画像结果来支持什么类型的决定 打算花多少时间和钱 用户画像的特点 越早越好，方向准确比行动重要 任何阶段都可以，任何阶段都有用，迟到比旷工好 不断迭代更新，用户会变化 从用户研究到商业分析用户研究为什么要学习商业分析 产品人要具有大局观理解用户只是基础，最终的目的都是创造商业价值，所以要懂商业分析 商业与用户价值的平衡豆瓣：过于重视用户体验而轻视商业发展 百度：过于重视商业发展而忽视用户体验 微信：取得用户体验和商业价值的平衡 在==正确的时机==找到产品在==商业价值和用户体验间的平衡点==至关重要 商业价值和用户价值的平衡就是 产品诉求和用户诉求的平衡 一名成功的用户研究员，需要研究和考量外部市场因素，驱动产品在商业价值和用户体验中取得平衡点 创业公司中人员配置的不完备","categories":[{"name":"产品","slug":"产品","permalink":"https://benny233.github.io/categories/产品/"}],"tags":[]}]}