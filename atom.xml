<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benny&#39;s Notebook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iloverainbow.top/"/>
  <updated>2019-12-01T08:33:34.941Z</updated>
  <id>https://iloverainbow.top/</id>
  
  <author>
    <name>Benny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>又一个梦</title>
    <link href="https://iloverainbow.top/2019/12/01/%E5%8F%88%E4%B8%80%E4%B8%AA%E6%A2%A6/"/>
    <id>https://iloverainbow.top/2019/12/01/又一个梦/</id>
    <published>2019-12-01T09:51:47.000Z</published>
    <updated>2019-12-01T08:33:34.941Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚又多梦，其中一个是便携飞行器带着我在一个大工地里飞行。飞行器结构简洁，下面是圆柱状的手柄，上面是个小圆盘。和以往的飞行梦一样，我有点恐高。虽然很想飞高，但是不敢。工地上面垂下来很多线，我在这些线里小心翼翼的穿行，担心撞到工人或者其他。怕被骂。</p><p>从大工地飞出来一会儿就是一条弯曲的小河。从视野的左上方流入，在视野的中间拐一个大弯，再从视野的右上方流出。于是，我的梦里有了一个河湾，以及河两岸大片绿油油的菜园。</p><p>河湾突出的地方有一片干净细腻的沙滩，沙滩的边缘静谧地矗立着五座高矮不一蓝顶的白塔。塔身释放着柔和、梦幻的氛围，像古朴通透的玉。看到它的瞬间，我知道了它的名字，小蓝帽。</p><p>美好的景色就在眼前，关键我还能飞，那我肯定要飞到河面上去静静的感受、呼吸这美好。刚好前面有三个女生也要去，于是我们同行赏景。景色更美了。</p><p>把梦写下来的时候想起白塔从哪里来了。睡前看的书里提到，1891年芝加哥举办世界博览会，为此新建的建筑群叫做白城。它的墙面涂有黄麻纤维灰浆，干燥后酷似白色的大理石。</p><p>“成千上万参观白城的美国人自豪地感到，美国文化已经成年。它们正向世界表明，尽管美国文明乳臭未干，犹如吵吵闹闹的毛头小伙子，美国人照样有对永恒之美的憧憬”</p><p>这段在书的第一章，看完我就关灯准备睡了。可是最近睡眠习惯被我搅乱了，睡不着，于是我起来又跳着看了最后一章。它总结道，“1890年代的作家做了他们的工作，尽管他们做完了就都悄然逝去。这就是，他们开始使美国习惯于下列事实：一是，内在的分裂要比地理上的分裂来得大；二是，一种致力于商业和技术的文明为它自身建立了一种源自商业和技术的道德观；三是，性体验是普通人类环境的一个基本部分，而不是各种既定社会制度中一个讳莫如深的部分。”</p><p>这段总结触动我的地方之一是它的第三点，美国人在一百多年前就能够把性体验作为生活的一个基本部分加以讨论，而我到现在对性还处于一种迷惑、矛盾的状态中。在中文互联网的各个角落里，有很多大胆刺激的性体验的描述，健康的、扭曲的、有爱的、背德的，很多很多。而在公共舆论环境里呢，每次明星出轨都能掀起全网的关注。</p><p>可能这也和政府的互联网管制策略有关，你们在网上就讨论下明星花边吧，不能讨论的东西就不要说了。看完花边继续为房子奋斗，你们不奋斗，怎么实现我的中国梦。微博，热搜能够花钱买，也能花钱撤。百度，什么都能竞价排名。华为，加班加到死。阿里，996是一种福报。为什么是福报呢，因为你不愿意996，大把的人愿意。</p><p>员工在公司面前很渺小，公司在政府面前也很渺小。写到这里我才想起来，我身处社会主义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚又多梦，其中一个是便携飞行器带着我在一个大工地里飞行。飞行器结构简洁，下面是圆柱状的手柄，上面是个小圆盘。和以往的飞行梦一样，我有点恐高。虽然很想飞高，但是不敢。工地上面垂下来很多线，我在这些线里小心翼翼的穿行，担心撞到工人或者其他。怕被骂。&lt;/p&gt;
&lt;p&gt;从大工地飞出
      
    
    </summary>
    
      <category term="写作" scheme="https://iloverainbow.top/categories/%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>css基础</title>
    <link href="https://iloverainbow.top/2019/11/04/css%E5%9F%BA%E7%A1%80/"/>
    <id>https://iloverainbow.top/2019/11/04/css基础/</id>
    <published>2019-11-04T06:50:28.000Z</published>
    <updated>2019-11-04T06:50:57.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>选择器 属性声明；</p><p>属性声明 = 属性名：属性值；</p><h4 id="属性值语法："><a href="#属性值语法：" class="headerlink" title="属性值语法："></a>属性值语法：</h4><p>比如  </p><p><code>margin：[&lt;length&gt;|&lt;percentage&gt;|&lt;auto&gt;]{1,4}</code></p><p>包含三种</p><ol><li><p>基本元素：length percentage auto 这些关键词</p></li><li><p>组合符号：[|] 这些符号</p></li><li><p>数量符号：1，4</p></li></ol><h5 id="1-基本元素"><a href="#1-基本元素" class="headerlink" title="1 基本元素"></a>1 基本元素</h5><ul><li>关键字<ul><li>auto，solid，bold</li></ul></li><li>类型<ul><li>基本类型 length percentage color</li><li>组合类型  ‘padding-width’  color-stop </li><li>符号 / , 分隔属性值</li><li>Inherit, initial</li></ul></li></ul><h5 id="2-组合符号"><a href="#2-组合符号" class="headerlink" title="2 组合符号"></a>2 组合符号</h5><ul><li><p>空格</p><p><font-size>  <font-family></font-family></font-size></p><p>必须有，且顺序固定</p></li><li><p>&amp;&amp;</p><p><length>&amp;&amp;<color></color></length></p><p>必须有，顺序无所谓</p></li><li><p>|| 双分隔符</p><p>underline||overline</p><p>至少出现一个</p></li><li><p>| 单分隔符</p><p><color>|transparent </color></p><p>只能出现一个</p></li><li><p>[]</p><p>优先组合</p></li></ul><h5 id="3-数量符合"><a href="#3-数量符合" class="headerlink" title="3 数量符合"></a>3 数量符合</h5><ul><li><p>数量符合 &lt;&gt;</p><p><length> 只能出现一次</length></p></li><li><p>数量符号 +</p><p>能出现一次或多次</p></li><li><p>数量符合 ？</p><p>可以出现，也可以不出现 </p></li><li><p>数量符号  {}</p><p><lenght>{2,4} 可以出现4次，最少出现2次</lenght></p></li><li><p>数量符合 * 任意次  空格隔开</p></li><li><p>数量符号 # 一次或多次 逗号隔开</p></li></ul><h4 id="规则语法"><a href="#规则语法" class="headerlink" title="@规则语法"></a>@规则语法</h4><p>@media 设备满足条件，样式才生效</p><p>@keyframes 动画中间步骤</p><p>@font-face 引入外部字体</p><p>私有属性加前缀</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>就是表达式，选中想要描述的标签</p><p><strong>一、基本选择器</strong></p><table><thead><tr><th>序号</th><th>示例</th><th>含义</th><th>选择器类型</th><th>特点</th></tr></thead><tbody><tr><td>1</td><td><strong>*</strong></td><td>通用元素选择器，匹配任何元素</td><td>通用选择器</td><td></td></tr><tr><td>2</td><td><strong>E</strong></td><td>标签选择器，匹配所有使用E标签的元素</td><td>标签选择器</td><td>控制一类标签</td></tr><tr><td>3</td><td><strong>.info</strong></td><td>class选择器，匹配所有class属性中包含info的元素</td><td>类别选择器</td><td>控制自定义的一类标签</td></tr><tr><td>4</td><td><strong>#footer</strong></td><td>id选择器，匹配所有id属性等于footer的元素</td><td>id选择器</td><td>准确</td></tr><tr><td>5</td><td>[disabled]\</td><td>[type=button]</td><td>具有某种属性，比如disabled。   id选择器是其特例 #footer{}=[id=button]{}</td><td>属性选择器</td><td></td></tr><tr><td></td><td>~=</td><td>属性中包含，类选择器是其特例 .sports{}=[class~=sports]{}</td><td>属性</td><td></td></tr><tr><td></td><td>属性值首尾字符匹配，包含</td><td></td><td>属性</td><td></td></tr><tr><td>6</td><td>a:visited</td><td>标签加状态</td><td>伪类</td></tr></tbody></table><p>实例：</p><blockquote><p>* { margin:0; padding:0; }</p><p>p { font-size:2em; }</p><p>.info { background:#ff0; }</p><p>p.info { background:#ff0; }</p><p>p.info.error { color:#900; font-weight:bold; }</p><p>#info { background:#ff0; }</p><p>p#info { background:#ff0; }</p></blockquote><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>标签加状态</p><p>link，visited,hover,active  disabled  enable checked </p><p>first-child nth-child(even)</p><p>only-child </p><p>不常见：</p><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>::first-letter {}第一个元素</p><p>::first-line{}第一行</p><p>::before {content: xxx}</p><p>::after </p><p>::selection</p><h4 id="组合选择器规则"><a href="#组合选择器规则" class="headerlink" title="组合选择器规则"></a>组合选择器规则</h4><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h5><p>.xxx p{}   后代包括多级</p><h5 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h5><p>.xxx&gt;p{}  子只有一层</p><h5 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h5><p> h2+p{} 相邻兄弟选择器  选中h2标签后的这个p标签</p><p>h2~p{} 通用兄弟选择器 选中h2标签后所有的p标签</p><h4 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h4><p>逗号分隔开</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>body{font-family: “xxx”} 会被子元素继承</p><p>自动继承的属性</p><p>color</p><p>font</p><p>text</p><p>list-style</p><p>…</p><p>非继承属性</p><p>background</p><p>Border</p><p>Position </p><h4 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h4><p> <img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/notes/%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7.png" alt=""></p><p>优先级相同就</p><h4 id="CSS层叠"><a href="#CSS层叠" class="headerlink" title="CSS层叠"></a>CSS层叠</h4><p>优先级：高覆盖低的</p><p>相同属性：后面覆盖前面的</p><p>不同属性：合并</p><h4 id="改变优先级"><a href="#改变优先级" class="headerlink" title="改变优先级"></a>改变优先级</h4><ol><li><p>改变顺序 覆盖</p></li><li><p>提升选择器优先级  改变选择器的写法 加高优先级 标签变类 类变id</p></li><li><p>!important </p><p><code>.tip{color: blue !important}</code></p></li></ol><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><h5 id="文字形状"><a href="#文字形状" class="headerlink" title="文字形状"></a>文字形状</h5><p>文字大小 font-size [number|percentage]</p><p>字体 font-family</p><p>加粗  font-weight</p><p>斜体 font-style</p><p>(段落 )行距 line-height    百分比和数字写法的继承关系不一样 数字写法背书关系直接继承 </p><p>这5个属性可以缩写为font这一个属性</p><p>下面两个实例是无效的</p><p> <img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/font%E5%86%99%E6%B3%95.png" alt=""></p><h5 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h5><p>color</p><h5 id="文本位置"><a href="#文本位置" class="headerlink" title="文本位置"></a>文本位置</h5><p>水平对齐<strong>text-align</strong>:left right center jusitfy</p><p>垂直对齐<strong>vertical-align</strong>: 上标，下标和居中</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>文本缩进：<strong>text-indent</strong></p><p>文本格式：<strong>white-space</strong> 换行是否保留 空格是否合并 自动换行  pre-wrap用的多 保留换行和空格，自动换行</p><p>单词换行：<strong>word-warp</strong> <strong>word-break</strong>   overflow-wrap</p><p>文字阴影：<strong>text-shadow</strong></p><p>下划线：<strong>text-decoration</strong></p><p>光标形状：<strong>cursor</strong></p><p>文本溢出：<strong>text-overflow</strong></p><p>强制继承：属性值<strong>inherit</strong></p><p><strong>不换行，超出部分用省略号替代</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p><img src="https://image-static.segmentfault.com/123/226/1232267381-5af307f9ebe47" alt="盒模型"></p><p>标准盒模型的长宽属性只作用于content</p><p>IE盒模型包括 content + padding + border</p><p>margin 边缘 页边空白  margin合并问题相邻合并取大值  父元素和首尾合并 </p><p>border 边线  :width style color</p><p>​        border-width</p><p>​        border-style</p><p>​        border-color</p><p>padding 内衬</p><p>content  内容</p><p>border-radius  可以设8个值</p><p>overflow 盒溢出 </p><p><strong>box-sizing</strong>  我们可以简单的理解，当<code>box-sizing</code>为<code>content-box</code>时，我们使用的是W3C盒模型，当<code>box-sizing</code>为<code>border-box</code>时，我们使用的是IE盒模型</p><p>​    content+padding+border</p><p>box-shadow 阴影不占空间 </p><p>outline： width style color 不占空间  border外</p><p><a href="https://juejin.im/post/59ef72f5f265da4320026f76" target="_blank" rel="noopener">详情请看</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>background-color 颜色 最底层</p><p>background-image 图片 先写的在上面 </p><p>background-repeat 背景平铺</p><p>nackground-attachment 背景跟随内容滚动</p><p>background-position 背景定位</p><p>linear-gradient 线性渐变</p><p>radial-gradient 径向渐变</p><p>还能加repeat</p><p>background-origin: border-box|pading-box|content-box 背景原点</p><p>background-clip 裁剪盒子的背景  content padding border</p><p>background-size </p><p>简写里的两个box是origin和clip 如果只写一个，那么两个box为同一个值</p><p><strong>简写</strong></p><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/%E8%83%8C%E6%99%AF%E5%86%99%E6%B3%95.png" alt=""></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>元素的摆放模式</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>设置元素的显示方式</p><p><strong>block</strong> :块级元素</p><p>​    1 宽度默认为父元素宽度</p><p>​    2 可设置宽高</p><p>​    3 换行显示</p><p>​    默认<strong>block</strong>元素   div p hx ul form…</p><p><strong>inline</strong>：行内元素</p><p>​    1 默认宽度为内容宽度</p><p>​    2 不可设置宽高</p><p>​    3 同行显示 </p><p>​    4 元素内换行</p><p>​    默认<strong>inline</strong>元素  span a label cite em…</p><p><strong>inline-block</strong> 从行内元素修改一下</p><p>​    1 内容宽度</p><p>​    2 <strong>可设置宽高</strong></p><p>​    3 同行显示</p><p>​    4 <strong>整块换行</strong></p><p>​    默认<strong>inline-block</strong> input textarea select button</p><p>​    vertical-align:middle 垂直居中有问题</p><p><strong>none</strong>：设置元素不显示，位置没有了,从display的字面意思来理解就是根本就不放上去</p><p>​    visibility位置还在</p><p><strong>flex</strong>: 弹性容器，看下面的flex弹性布局</p><h3 id="相关布局模式"><a href="#相关布局模式" class="headerlink" title="相关布局模式"></a>相关布局模式</h3><p><strong>块级元素水平居中</strong>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>content area<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.content&#123;margin: auto; width:978px; &#125;</span><br><span class="line">左右外边距为auto就行了</span><br></pre></td></tr></table></figure><p><strong>居中导航</strong></p><p>容器 text-align:center</p><p>里面 display：inline-block</p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>设置定位方式</p><p><strong>position  设置参照物</strong></p><p>​    <strong>static</strong> 默认</p><p>​    <strong>relative</strong> 相对定位 </p><p>​        1 仍在文档流中 </p><p>​        2 参照物为元素本身 </p><p>​        常用来改变元素的层级</p><p>​        作为绝对定位元素的参照物</p><p>​    <strong>absolute</strong> 绝对定位</p><p>​        1 默认宽度为内容宽度</p><p>​        2 脱离文档流</p><p>​        3 参照物为第一个定位祖先/根元素(html)</p><p>​                用一个相对定位的元素包裹绝对定位的元素</p><p>​    <strong>fixed</strong></p><p>​        1 默认宽度为内容宽度</p><p>​        2 脱离文档流</p><p>​        3 参照物为视窗</p><p><strong>top right bottom left 设置位置</strong></p><p><strong>z-index 设置层级</strong></p><h3 id="相关布局模式-1"><a href="#相关布局模式-1" class="headerlink" title="相关布局模式"></a>相关布局模式</h3><p><strong>轮播头图</strong></p><p>叠加 父元素relative 子元素absolute</p><p><strong>固定顶栏</strong></p><p>top-bar{position: fixed}</p><p>body{margin-top:xxxpx}</p><p><strong>遮罩</strong></p><p>盖住页面</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mask</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  z-index;999;</span><br><span class="line">  <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span><br><span class="line"> </span><br><span class="line">  <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三行自适应布局</strong></p><p>头尾固定，中间自适应</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span>&#123;<span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">0px</span>;<span class="attribute">left</span>: <span class="number">0</span>;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: indianred;&#125;</span><br><span class="line"><span class="selector-class">.container</span>&#123;<span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">100px</span>;<span class="attribute">bottom</span>: <span class="number">100px</span>;<span class="attribute">left</span>: <span class="number">0px</span>;<span class="attribute">right</span>: <span class="number">0px</span>;<span class="attribute">overflow</span>: auto;&#125; 没有设置宽高 ，让浏览器来计算</span><br><span class="line"><span class="selector-class">.contents</span>&#123;<span class="attribute">height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;<span class="attribute">position</span>: absolute;<span class="attribute">bottom</span>: <span class="number">0</span>;<span class="attribute">left</span>: <span class="number">0</span>;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: lemonchiffon;&#125;</span><br></pre></td></tr></table></figure><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p><strong>none</strong> 默认</p><p><strong>right</strong></p><p>​    1 默认宽度为内容宽度</p><p>​    2 脱离文档流</p><p>​    3 向指定方向一致移动，移到父元素的边界（不是完全脱离）</p><p>float的元素在同一文档流，行内</p><p>对元素，脱离文档流；对内容，在文档流</p><p>​    </p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>应用于后续元素 清除浮动元素对后续元素的影响。float元素从当前父元素浮动出来可能会对父元素后续的元素造成影响。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">overflow</span>:hidden;</span><br><span class="line"><span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line">这里用不可见的.来清除浮动 把浮动的效果控制在父元素内</span><br></pre></td></tr></table></figure><p><strong>两列布局</strong></p><p>块级元素同行显示</p><p>在文档流中</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>父元素 position:flex  弹性元素是在其文档流中的子元素。不包括position: absolute 和非子后代元素。注意float元素也在文档流中</p><h4 id="方向（容器）-flex-flow"><a href="#方向（容器）-flex-flow" class="headerlink" title="方向（容器） flex-flow"></a><strong>方向</strong>（容器） flex-flow</h4><p>​    <strong>flex-direction</strong>  排列方向 row row-reverse colunm column-reverse</p><p>​    <strong>flex-wrap</strong> 是否换行</p><p>​    <strong>flex-flow</strong> 是direction和wrap的缩写</p><p>​    <strong>order</strong>  改变<strong>单个元素</strong>的排列顺序</p><h4 id="弹性（元素）flex"><a href="#弹性（元素）flex" class="headerlink" title="弹性（元素）flex"></a><strong>弹性</strong>（元素）flex</h4><p>​     <strong>flex-grow</strong> 分配剩余空间的比例 先计算basis再从剩余空间分配</p><p>​    <strong>flex-shrink</strong> 分配缺少空间的比例  初始值为1，平均分配，为0不分配，也就是不收缩了</p><p>​    <strong>flex-basis</strong> 弹性元素的初始宽（横向排列）或高（纵向排列）</p><p>​    <strong>缩写为flex：grow||shrink||basis</strong></p><h4 id="对齐（容器）"><a href="#对齐（容器）" class="headerlink" title="对齐（容器）"></a><strong>对齐</strong>（容器）</h4><p>​    <strong>justify-content</strong>: 主轴方向的对齐方式</p><p>​    <strong>align-items</strong>: <strong>容器</strong>辅轴上的对齐方式</p><p>​    <strong>align-content</strong>：容器 辅轴 多行的行对齐方式</p><p>​    <strong>align-self</strong>：<strong>单个元素</strong>在辅轴上的对齐方式</p><p><strong>三行两列自适应</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>### </p><h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><p><strong>transform</strong></p><p>调用变形函数</p><p>transform: <strong>function()</strong></p><p>函数有 </p><p>rotate旋转</p><p>translate移动</p><p>scale伸缩</p><p>skew倾斜</p><p><strong>transform-origin</strong></p><p>设定变形原点</p><p><strong>perspective</strong></p><p>设定人眼的距离来表现透视效果</p><p><strong>perspective-origin</strong></p><p>设定人眼的角度来表现透视效果</p><p><strong>translate3d</strong></p><p>加入了z轴的transform</p><p><strong>transform-style</strong></p><p><strong>backface-visibility</strong></p><p> 变形之后的背面的可见性</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><strong>transition</strong></p><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/transtion%E5%86%99%E6%B3%95.png" alt=""></p><p><strong>transition-property</strong></p><p>产生动画效果的属性</p><p><strong>transition-durantion</strong></p><p>动画效果持续的时间</p><p><strong>transition-timing-function</strong></p><p>动画速度变换控制</p><p><strong>transition-delay</strong></p><p>动画开始延时时间</p><p><strong>animation</strong></p><p><strong>animation-name</strong></p><p>自运行多帧动画</p><h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p><strong>什么是文档流？</strong></p><p>​      将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流。</p><p>​      只有三种情况会使得元素脱离文档流，分别是：浮动、绝对定位和相对定位。</p><h1 id="元素种类"><a href="#元素种类" class="headerlink" title="元素种类"></a>元素种类</h1><p>display属性  块级元素 block  行内元素 inline  可以通过css修改</p><p>块级可以包含块级和行内，行内只能包含文本和行内<br>块级占据一整行空间，行内占据自身宽度空间，在同一行里可以放很多<br>宽高设置、内外边距的差异</p><h4 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div h1 h2 h3 h4 h5 h6 p hr</span><br><span class="line">form ul dl ol pre table</span><br><span class="line">li dd dt tr td th</span><br><span class="line">div,标题，表单，段落，列表，表格</span><br><span class="line">块级元素是占据一整行的空间的</span><br></pre></td></tr></table></figure><h4 id="行类元素（inline-level）"><a href="#行类元素（inline-level）" class="headerlink" title="行类元素（inline-level）"></a>行类元素（inline-level）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">em strong span a br img </span><br><span class="line">button input label select textarea</span><br><span class="line">code script</span><br><span class="line">块级元素可以包含块级元素和行内元素，行内元素只能包含行内元素和文本</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;选择器
      
    
    </summary>
    
      <category term="前端" scheme="https://iloverainbow.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="https://iloverainbow.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="CSS" scheme="https://iloverainbow.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>html基础</title>
    <link href="https://iloverainbow.top/2019/11/04/html%E5%9F%BA%E7%A1%80/"/>
    <id>https://iloverainbow.top/2019/11/04/html基础/</id>
    <published>2019-11-04T06:48:47.000Z</published>
    <updated>2019-11-04T06:51:11.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h1><p>所有的标签都有的属性</p><ol><li>id</li><li>class</li><li>style</li><li>title</li></ol><h1 id="标签们"><a href="#标签们" class="headerlink" title="标签们"></a>标签们</h1><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/notes/h5%E6%A0%87%E7%AD%BE%E8%AE%B0%E5%BF%86%E5%9B%BE.png" alt="标签记忆图"></p><h1 id="文档章节标签"><a href="#文档章节标签" class="headerlink" title="文档章节标签"></a>文档章节标签</h1><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/notes/%E5%B8%B8%E8%A7%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84.png" alt="常规页面结构"></p><ol><li><p>body 用户内容</p></li><li><p>header 章节头部，标题，logo，搜索</p></li><li><p>nav 导航 整站导航和页面内导航</p></li><li><p>aside 侧边栏，广告，工具 </p></li><li><p>article 主体内容，独立的，可重复的结构，比如论坛的一个帖子，博客的一篇文章。可以嵌套</p></li><li><p>section 表示article中的一部分</p></li><li><p>footer 版权，链接</p></li><li><p>hx</p></li></ol><h1 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h1><ol><li>超链接 a 链接，内部锚点 email</li><li>强调  em strong  em是语义的强调， strong是重要性的强调  strong比em更强烈 </li><li>行内容器  span  没有语义，结合样式来操作</li><li>换行 br</li></ol><h4 id="其他文本标签"><a href="#其他文本标签" class="headerlink" title="其他文本标签"></a>其他文本标签</h4><ol><li>引用 <ol><li>cite，表示引用的出处</li><li>q ，简短的一段文字</li></ol></li><li>代码 code</li><li>格式化<ol><li>b 粗体，但是并不强调，比如摘要中的关键字，产品的名称</li><li>i 斜体，比如技术术语</li></ol></li></ol><h1 id="组合内容标签"><a href="#组合内容标签" class="headerlink" title="组合内容标签"></a>组合内容标签</h1><ol><li>分区 div</li><li>段落 p</li><li>列表 ul ol dl</li></ol><h4 id="其他组合内容标签"><a href="#其他组合内容标签" class="headerlink" title="其他组合内容标签"></a>其他组合内容标签</h4><ol><li>pre 格式化的内容，会保留换行符和空格</li><li>blockquote，大块的引用</li></ol><h1 id="嵌入资源标签"><a href="#嵌入资源标签" class="headerlink" title="嵌入资源标签"></a>嵌入资源标签</h1><ol><li>img</li><li>iframe 嵌入第三方的页面或者广告，js的环境是隔离的，操作互不影响。比如云音乐下面的播放器，和上方的页面互不影响  </li><li>object  嵌入外部资源，比如pdf阅读插件，还有flash插件播放视频（以前）</li><li>embed 同上</li><li>video h5标签支持，不需要插件了 </li><li>audio</li></ol><h4 id="其他嵌入资源标签"><a href="#其他嵌入资源标签" class="headerlink" title="其他嵌入资源标签"></a>其他嵌入资源标签</h4><ol><li>图<ol><li>canvas 基于像素，利用脚本来绘制图像 性能高场景复杂的 比如实时数据展示 和游戏 </li><li>svg 矢量图 高保真静态图形图像</li></ol></li><li>热点区域 图像的不同部分跳转到不同的链接<ol><li>map</li><li>area</li></ol></li></ol><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><p>   Table thead tbody tfoot tr th td</p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><p>   数据交互</p><ol><li>form包裹  重要属性 action method</li><li>fieldset 给表单分区</li><li>legend 分区标题</li><li><strong>Input</strong> 基本数据输入单元  重要属性type name value</li><li>Button </li><li>Select 下拉框</li><li>textarea</li><li>label 提示 重要属性 for</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全局属性&quot;&gt;&lt;a href=&quot;#全局属性&quot; class=&quot;headerlink&quot; title=&quot;全局属性&quot;&gt;&lt;/a&gt;全局属性&lt;/h1&gt;&lt;p&gt;所有的标签都有的属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;style&lt;/li&gt;

      
    
    </summary>
    
      <category term="前端" scheme="https://iloverainbow.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础" scheme="https://iloverainbow.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="HTML" scheme="https://iloverainbow.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTTP基础</title>
    <link href="https://iloverainbow.top/2019/10/14/HTTP%E5%9F%BA%E7%A1%80/"/>
    <id>https://iloverainbow.top/2019/10/14/HTTP基础/</id>
    <published>2019-10-14T03:43:22.000Z</published>
    <updated>2019-10-14T03:46:10.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h5 id="OSI模型7层"><a href="#OSI模型7层" class="headerlink" title="OSI模型7层"></a>OSI模型7层</h5><p>应用层：各种应用软件，包括 Web 应用。</p><p>标识层：数据格式标识，基本压缩加密功能。</p><p>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</p><p>传输层：端到端传输数据的基本功能；如 TCP、UDP。</p><p>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</p><p>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</p><p>物理层：底层数据传输，如网线；网卡标准。 </p><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/notes/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><p><img src="https://bennypic.oss-cn-hangzhou.aliyuncs.com/notes/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif" alt=""></p><p><strong>为什么要三次握手</strong>？</p><p><code>这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.</code></p><p><strong>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手</strong>(服务端验证)</p><p><strong>为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手</strong>(客户端验证)</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>它是网络<strong>通信过程中端点的抽象表示</strong>，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，<strong>Socket其实就是一个门面模式</strong>，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“<strong>一切皆文件</strong>”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p><h6 id="socket与TCP"><a href="#socket与TCP" class="headerlink" title="socket与TCP"></a>socket与TCP</h6><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。</p><p>但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>一个 HTTP 请求报文由请求行（request line）、请求头部（header）、空行和请求数据四部分组成</p><ol><li>第一行必须是一个请求行（request line），用来说明请求类型、要访问的资源以及所使用的 HTTP 版本</li><li>紧接着是一个头部（header）小节，用来说明服务器要使用的附加信息</li><li>之后是一个空行</li><li>再后面可以添加任意的其他数据（称之为主体：body）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><p>响应报文类似，</p><ol><li>状态行</li><li>响应报头</li><li>空行</li><li>响应数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;state&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><h3 id="CORS跨域请求的限制与解决，预请求验证"><a href="#CORS跨域请求的限制与解决，预请求验证" class="headerlink" title="CORS跨域请求的限制与解决，预请求验证"></a>CORS跨域请求的限制与解决，预请求验证</h3><p>需服务器支持跨域</p><h3 id="缓存头"><a href="#缓存头" class="headerlink" title="缓存头"></a>缓存头</h3><p>Cache-Control，Expires，Last-Modified和Etag </p><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><p><a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">cookie和session</a></p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>cookie和session可以实现有状态(服务端保存session)的用户认证，但是扩展性不好</p><p>JWT实现无状态(服务端不保存session)，从而容易实现扩展</p><h3 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h3><p>Keep-alive</p><p><a href="https://mp.weixin.qq.com/s/CpJ1mKA_i52pG4hEg-3AWw" target="_blank" rel="noopener">Keep-alive的应用</a></p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA" target="_blank" rel="noopener">原理</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">实操</a></p><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>[服务器推送](</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP基础&quot;&gt;&lt;a href=&quot;#HTTP基础&quot; class=&quot;headerlink&quot; title=&quot;HTTP基础&quot;&gt;&lt;/a&gt;HTTP基础&lt;/h1&gt;&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础" scheme="https://iloverainbow.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络" scheme="https://iloverainbow.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://iloverainbow.top/2019/10/10/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>https://iloverainbow.top/2019/10/10/Redis基础/</id>
    <published>2019-10-10T08:29:35.000Z</published>
    <updated>2019-10-10T08:29:54.058Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础" scheme="https://iloverainbow.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据库" scheme="https://iloverainbow.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="https://iloverainbow.top/2019/10/10/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>https://iloverainbow.top/2019/10/10/MySQL基础/</id>
    <published>2019-10-10T06:57:39.000Z</published>
    <updated>2019-10-10T08:29:01.512Z</updated>
    
    <content type="html"><![CDATA[<p>整理自掘金小册《MySQL是怎样运行的》，还有<a href="https://juejin.im/post/5d351303f265da1bd30596f9#heading-4" target="_blank" rel="noopener">高频面试一百问</a>，<a href="https://juejin.im/post/5c6b9c09f265da2d8a55a855#heading-19" target="_blank" rel="noopener">MySQL优化面试</a>，<a href="https://juejin.im/post/5d1758d06fb9a07eed351405#heading-31" target="_blank" rel="noopener">MySQL重要知识点</a></p><p>图片都来自前者。</p><h1 id="一-索引"><a href="#一-索引" class="headerlink" title="一 索引"></a>一 索引</h1><h2 id="认识索引"><a href="#认识索引" class="headerlink" title="认识索引"></a>认识索引</h2><p>mysql按照记录的主键值从小到大，分页存储。记录之间组成单向链表，页之间组成双向列表。</p><p><code>主键查询</code>是在<code>页目录</code>中用二分法定位到页，然后在页中遍历到指定记录。</p><p>类似看书的时候查目录。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a01bd1b8eafbb4?imageslim" alt=""></p><p>不是主键也没有建立索引就是遍历查找所有记录。很慢，所以需要索引。</p><p>简单理解一下存储结构是下面这样</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a01bd295fd42b5?imageslim" alt=""></p><p>上面那一页就是索引页，专门存放目录项记录</p><p>实际情况是下面这样，一棵B+树。实际记录都存放在B+树最底层的节点(叶子节点)上。</p><p>名字很奇怪的聚簇索引说的就是这(叶子节点是实际记录)，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的索引即数据，数据即索引。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a6fb9126?imageslim" alt=""></p><p>上面是按照主键排列的，可以实现主键的快速查找。想要实现其他条件的快速查找就要重新排列了，这就是建索引。按照索引列排列，建一颗B+树。 不同的是，叶子节点不是真实记录，只有对应的主键值，所以需要去聚簇索引中再找一次。这个操作叫<strong>回表</strong>，以时间换空间。比聚簇索引(主键索引)多了一个回表操作，所以也叫<code>二级索引</code>(辅助索引)</p><h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><p>高频查询字段适合建立索引</p><p>联合索引需要注意联合索引中的顺序.</p><h4 id="索引不生效的情况"><a href="#索引不生效的情况" class="headerlink" title="索引不生效的情况"></a>索引不生效的情况</h4><ol><li>使用不等于查询,</li><li>列参与了数学运算或者函数</li><li>在字符串like时左边是通配符.类似于’%aaa’.</li><li>当mysql分析全表扫描比使用索引快的时候不使用索引.</li><li>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</li></ol><h1 id="二-设计优化"><a href="#二-设计优化" class="headerlink" title="二 设计优化"></a>二 设计优化</h1><h5 id="使用自增主键"><a href="#使用自增主键" class="headerlink" title="使用自增主键"></a>使用自增主键</h5><p>没有主键也建议添加一个自增主键，新的记录会按顺序添加到前一个记录的后面</p><p>uuid写入近似于随机(因为是按照字符来排序的)，插来插曲效率低</p><h5 id="使用NOT-NULL"><a href="#使用NOT-NULL" class="headerlink" title="使用NOT NULL"></a>使用NOT NULL</h5><p>理由很多，不用就完事了</p><h5 id="定长比非定长查询效率高"><a href="#定长比非定长查询效率高" class="headerlink" title="定长比非定长查询效率高"></a>定长比非定长查询效率高</h5><h5 id="选择小的数据类型"><a href="#选择小的数据类型" class="headerlink" title="选择小的数据类型"></a>选择小的数据类型</h5><h5 id="注释写好点"><a href="#注释写好点" class="headerlink" title="注释写好点"></a>注释写好点</h5><h5 id="单表字段不宜过多"><a href="#单表字段不宜过多" class="headerlink" title="单表字段不宜过多"></a>单表字段不宜过多</h5><p>二三十个是极限了</p><h5 id="冗余字段"><a href="#冗余字段" class="headerlink" title="冗余字段"></a>冗余字段</h5><p>我倾向多一点冗余，减少连表查询，也不使用子查询</p><h1 id="三-查询优化"><a href="#三-查询优化" class="headerlink" title="三 查询优化"></a>三 查询优化</h1><h4 id="慢查询的原因"><a href="#慢查询的原因" class="headerlink" title="慢查询的原因"></a>慢查询的原因</h4><p>是查询条件没有命中索引?</p><p>是load了不需要的数据列?</p><p>还是数据量太大?</p><p>所以优化也是针对这三个方向来的,</p><ul><li>首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.</li><li>分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.</li><li>如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.</li></ul><h1 id="四-事务"><a href="#四-事务" class="headerlink" title="四 事务"></a>四 事务</h1><p>事务的英文是transaction，其实本义是交易，买卖的意思。事务不够直观</p><p>需要符合AICD特性的一个或多个数据库操作称为<code>事务</code></p><p>A atomicity 原子性：不可分割，要么做要么不做，不存在中间状态</p><p>I isolation 隔离性：本次操作不受其他操作影响</p><p>C consistency 一致性：符合现实世界的约束，比如你在银行里只有5块钱，不可能取出6块钱来</p><p>D durability 持久性：操作产生的状态转换是稳定的</p><h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><p>1 活动的（active）</p><p>操作正在执行</p><p>2 部分提交的（partially committed）</p><p>最后一个操作执行完成，刷新到磁盘前</p><p>3 失败的（failed）</p><p>1或2执行失败后</p><p>4 中止的（aborted）</p><p>失败之后需要<code>回滚</code> ，回滚后</p><p>5 提交的（committed）</p><p>2提交成功后</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/1/169d7fd5bd4ce2f1?imageslim" alt=""></p><p>还没用到，写支付的时候再来吧</p><h1 id="五-锁"><a href="#五-锁" class="headerlink" title="五 锁"></a>五 锁</h1><p>有并发事务的时候通过锁来保证访问的次序。</p><p>需要的时候再来吧。</p><h1 id="六-其他"><a href="#六-其他" class="headerlink" title="六 其他"></a>六 其他</h1><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>小册总结得很好，就不copy了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理自掘金小册《MySQL是怎样运行的》，还有&lt;a href=&quot;https://juejin.im/post/5d351303f265da1bd30596f9#heading-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高频面试一百问&lt;/a&gt;，&lt;a 
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础" scheme="https://iloverainbow.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据库" scheme="https://iloverainbow.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>阿里云效搭建单机自动化部署系统</title>
    <link href="https://iloverainbow.top/2019/10/05/%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%88%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://iloverainbow.top/2019/10/05/阿里云效搭建单机自动化部署系统/</id>
    <published>2019-10-04T16:24:29.000Z</published>
    <updated>2019-10-10T08:12:30.970Z</updated>
    
    <content type="html"><![CDATA[<p>本来想搭一套k8s，一劳永逸，奈何坑太大，个子太矮，没趟过去。</p><p>那就用云效吧。根据文档操作，再稍作修改，就阔以了。</p><p>主要用在测试环境，生产的灰度发布等等高级功能还没探索。</p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p><a href="https://help.aliyun.com/document_detail/125756.html?spm=a2c4g.11186623.6.551.3b68424cuu1dyH" target="_blank" rel="noopener">先按照这个文档走下流程</a></p><p>在文档中的<code>部署配置</code>这一步之前增加一步镜像构建的操作，这一步会产出<code>制品</code>(用来部署)，部署操作里拿到制品才能进行。</p><p>镜像的标签写死，我写的latest，后面会用到。</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>部署机器可以用非阿里云的机器，阿里云牛逼。</p><p>部署配置：</p><p>下载路径空着，</p><p>执行用户是root</p><p>部署脚本参考</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop xxx <span class="comment"># 先把上一版本的容器停掉，因为启动的时候带了--rm参数，所以容器会自动删除</span></span><br><span class="line">docker rmi <span class="variable">$imageId</span> <span class="comment"># 然后把老镜像删掉，前面把标签写死就是为了这里能删掉老镜像</span></span><br><span class="line">docker run --name xxx --rm -d -p <span class="number">3000</span>:<span class="number">3000</span> <span class="variable">$imageId</span> <span class="comment"># 最后拉取镜像，跑起来</span></span><br></pre></td></tr></table></figure><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>机器上面需要docker login，还有一些代码库，镜像库的细节，摸索一下就会了。</p><p>OK，推送代码就能触发自动部署了，倍儿爽</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来想搭一套k8s，一劳永逸，奈何坑太大，个子太矮，没趟过去。&lt;/p&gt;
&lt;p&gt;那就用云效吧。根据文档操作，再稍作修改，就阔以了。&lt;/p&gt;
&lt;p&gt;主要用在测试环境，生产的灰度发布等等高级功能还没探索。&lt;/p&gt;
&lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;he
      
    
    </summary>
    
      <category term="运维" scheme="https://iloverainbow.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>周打卡-1</title>
    <link href="https://iloverainbow.top/2019/06/04/%E5%91%A8%E6%89%93%E5%8D%A11/"/>
    <id>https://iloverainbow.top/2019/06/04/周打卡1/</id>
    <published>2019-06-04T09:51:47.000Z</published>
    <updated>2019-12-01T08:31:45.381Z</updated>
    
    <content type="html"><![CDATA[<p>有些事情需要长期投入<br>在这里通过周打卡的形式记录<br>之后抽出来做一个打卡的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些事情需要长期投入&lt;br&gt;在这里通过周打卡的形式记录&lt;br&gt;之后抽出来做一个打卡的功能&lt;/p&gt;

      
    
    </summary>
    
      <category term="周打卡" scheme="https://iloverainbow.top/categories/%E5%91%A8%E6%89%93%E5%8D%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://iloverainbow.top/2018/08/09/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
    <id>https://iloverainbow.top/2018/08/09/Linux命令手册/</id>
    <published>2018-08-09T03:35:09.000Z</published>
    <updated>2019-10-10T08:22:10.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps -a| grep name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定程序的进程id</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用于显示tcp，udp的端口和进程等相关情况</span></span><br><span class="line">netstat -tunlp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换用户</span></span><br><span class="line">su name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="手册" scheme="https://iloverainbow.top/categories/%E6%89%8B%E5%86%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>部署流程</title>
    <link href="https://iloverainbow.top/2018/07/09/%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <id>https://iloverainbow.top/2018/07/09/部署流程/</id>
    <published>2018-07-09T15:39:07.000Z</published>
    <updated>2019-10-09T10:32:30.630Z</updated>
    
    <content type="html"><![CDATA[<p>项目写好了。有一台服务器。</p><h1 id="服务器基本配置"><a href="#服务器基本配置" class="headerlink" title="服务器基本配置"></a>服务器基本配置</h1><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@ip</span><br></pre></td></tr></table></figure><p>这是是root用户，权限太大不安全。</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">新建用户</span><br><span class="line"> adduser name </span><br><span class="line">给sudo权限</span><br><span class="line"> vim /etc/sudoers</span><br><span class="line">在root ALL=(ALL)ALL这一行下增加</span><br><span class="line">name ALL=(ALL)ALL</span><br></pre></td></tr></table></figure><h3 id="简化登录"><a href="#简化登录" class="headerlink" title="简化登录"></a>简化登录</h3><p>本机.zshrc文件给命令配置别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias tx=&quot;ssh name@ip&quot;</span><br></pre></td></tr></table></figure></p><h3 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h3><p>和git仓库配置秘钥原理一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 两边都要有生成秘钥</span><br><span class="line">ssh-keygen -t rsa -C “email”</span><br><span class="line"></span><br><span class="line">2. 服务器保存本地公钥</span><br><span class="line">echo pubkey &gt;&gt; .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">3. 重启服务器ssh</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></p><h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 修改端口</span><br><span class="line">文件/etc/ssh/sshd_config </span><br><span class="line">port属性,换成其他端口</span><br><span class="line"></span><br><span class="line">2. 关闭root密码登录</span><br><span class="line">PermitRootLogin属性，换成without-password</span><br><span class="line"></span><br><span class="line">3. 重启ssh</span><br><span class="line"></span><br><span class="line">4. 还可以配置iptables</span><br></pre></td></tr></table></figure><h3 id="nginx配置端口代理"><a href="#nginx配置端口代理" class="headerlink" title="nginx配置端口代理"></a>nginx配置端口代理</h3><p>在/etc/nginx/nginx.conf中添加<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让nginx加载配置文件</span></span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure></p><p>然后在/etc/nginx/conf.d文件夹下新建配置文件name-port.conf<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream dappdemo &#123;</span><br><span class="line">    server localhost:3000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forward-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy <span class="literal">true</span>;</span><br><span class="line">        proxy_pass http://dappdemo;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匹配到server_name的流量转发到proxy_pass</p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 安装docker</span><br><span class="line">wget -qO- https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line">2. 检验docker是否被正确安装</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="从仓库拉取代码"><a href="#从仓库拉取代码" class="headerlink" title="从仓库拉取代码"></a>从仓库拉取代码</h3><ol><li>服务器连接仓库<br><a href="https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="noopener">教程</a></li><li>git clone</li></ol><h3 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h3><p>根据dockerfile新建一个镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t yourname/imagename:tag .</span><br><span class="line"></span><br><span class="line">docker build -t benny/dapp:latest .</span><br></pre></td></tr></table></figure></p><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p>用了Makefile<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pjName := dappdemo</span><br><span class="line"></span><br><span class="line">docker:</span><br><span class="line">docker run \</span><br><span class="line">--name <span class="variable">$&#123;pjName&#125;</span> \</span><br><span class="line">--rm \</span><br><span class="line">-ti \</span><br><span class="line">-p 3000:3000 \</span><br><span class="line">benny/dapp:0.1 \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make docker</span><br></pre></td></tr></table></figure><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>npm run start，使用pm2管理进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pm2 start pm2.json</span><br><span class="line"></span><br><span class="line">===================================</span><br><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;ico-dapp&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;./server.js&quot;,</span><br><span class="line">      &quot;out_file&quot;: &quot;./logs/out.log&quot;,</span><br><span class="line">      &quot;error_file&quot;: &quot;./logs/error.log&quot;,</span><br><span class="line">      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;,</span><br><span class="line">      &quot;instances&quot;: 0,</span><br><span class="line">      &quot;exec_mode&quot;: &quot;cluster&quot;,</span><br><span class="line">      &quot;max_memory_restart&quot;: &quot;500M&quot;,</span><br><span class="line">      &quot;merge_logs&quot;: true,</span><br><span class="line">      &quot;env&quot;: &#123;</span><br><span class="line">        &quot;NODE_ENV&quot;: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目写好了。有一台服务器。&lt;/p&gt;
&lt;h1 id=&quot;服务器基本配置&quot;&gt;&lt;a href=&quot;#服务器基本配置&quot; class=&quot;headerlink&quot; title=&quot;服务器基本配置&quot;&gt;&lt;/a&gt;服务器基本配置&lt;/h1&gt;&lt;h3 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=
      
    
    </summary>
    
      <category term="运维" scheme="https://iloverainbow.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx笔记</title>
    <link href="https://iloverainbow.top/2018/07/09/Nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/07/09/Nginx笔记/</id>
    <published>2018-07-09T14:44:54.000Z</published>
    <updated>2019-10-09T10:31:42.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>nginx是web服务器，性能高，并发性好。</p><p>可以用作代理服务器。</p><p>正向：直接转发</p><p>反向：分发请求</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>nginx -s reload 重新加载</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="这和用程序起一个服务有什么区别呢？"><a href="#这和用程序起一个服务有什么区别呢？" class="headerlink" title="这和用程序起一个服务有什么区别呢？"></a>这和用程序起一个服务有什么区别呢？</h3><p>语言自带类库实现的服务器比较简单。nginx是专业的，更强大。</p><p>为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h3 id="动静态资源分离"><a href="#动静态资源分离" class="headerlink" title="动静态资源分离"></a>动静态资源分离</h3><p>运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p><h1 id="实现打点计数"><a href="#实现打点计数" class="headerlink" title="实现打点计数"></a>实现打点计数</h1><p>用到了服务器功能，和日志功能。</p><p>服务器只返回一个像素的gif图，很高效。</p><p>日志路径为”/usr/local/Cellar/nginx/1.15.0/logs”</p><p>nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location = /report &#123;</span><br><span class="line">        empty_gif;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现负载均衡和端口代理"><a href="#实现负载均衡和端口代理" class="headerlink" title="实现负载均衡和端口代理"></a>实现负载均衡和端口代理</h1><p>nginx运行在80端口，将请求分发到对应的端口上</p><p>/etc/nginx/conf.d/name-port.conf</p><p>把入口的流量转发到dappdemo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream dappdemo &#123;</span><br><span class="line">    server 127.0.0.1:3000;</span><br><span class="line"><span class="comment">#    down  表示单前的 server 暂时不参与负载 </span></span><br><span class="line">    server 127.0.0.1:8083 down;</span><br><span class="line"><span class="comment">#   weight  默认为 1 weight 越大，负载的权重就越大。 </span></span><br><span class="line">    server 127.0.0.1:8084 weight=3;   </span><br><span class="line"><span class="comment">#    backup 其它所有的非 backup 机器 down 或者忙的时候，请求 backup机器。所以这台机器压力会最轻</span></span><br><span class="line">    server 127.0.0.1:8002 backup;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 8080;</span><br><span class="line"><span class="comment">#    匹配的入口</span></span><br><span class="line">    server_name 127.0.0.1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forward-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_set_header X-Nginx-Proxy <span class="literal">true</span>;</span><br><span class="line">        proxy_pass http://dappdemo;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;nginx是web服务器，性能高，并发性好。&lt;/p&gt;
&lt;p&gt;可以用作代理服务器。&lt;/p&gt;
&lt;p&gt;正向：直接转发&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="运维" scheme="https://iloverainbow.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>非暴力沟通</title>
    <link href="https://iloverainbow.top/2018/07/03/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
    <id>https://iloverainbow.top/2018/07/03/非暴力沟通/</id>
    <published>2018-07-03T05:10:00.000Z</published>
    <updated>2019-10-10T08:25:02.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h1><p>沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配</p><p>暴力行为的背后，往往隐藏着人性本恶的价值取向。接受人性本善的价值取向，暴力因素就会远离。</p><h1 id="交流如何变成暴力行为"><a href="#交流如何变成暴力行为" class="headerlink" title="交流如何变成暴力行为"></a>交流如何变成暴力行为</h1><h3 id="道德批判"><a href="#道德批判" class="headerlink" title="道德批判"></a>道德批判</h3><p>用自己的价值观给别人贴标签。这种标签实际上反应了我们的需要和价值观。贴完标签，偏见就产生了，偏见会阻碍交流。</p><h3 id="进行比较"><a href="#进行比较" class="headerlink" title="进行比较"></a>进行比较</h3><p>比较也是一种评判。强迫别人参加一场比赛，然后判他输。</p><h3 id="回避责任"><a href="#回避责任" class="headerlink" title="回避责任"></a>回避责任</h3><p>这是一种表达方式的问题。“不得不做”是一种回避责任的表达方式，需要换成负责任的方式。</p><h3 id="强人所难"><a href="#强人所难" class="headerlink" title="强人所难"></a>强人所难</h3><p>字面意思。对别人的要求往往暗含威胁。</p><h1 id="暴力行为的背后"><a href="#暴力行为的背后" class="headerlink" title="暴力行为的背后"></a>暴力行为的背后</h1><p>行为只是表面原因，问题的根源是对自己和世界的看法。比如优胜劣汰，人性本恶。</p><p>优胜劣汰在社会运作的规则之一，但我们的生活不是。在社会中我们不得不去竞争，比输了很正常，要能够接受。尽人事，听天命，实在是智慧之言。很多情况下，让我懊恼的失败都是没有“尽人事”。</p><p>这个世界好人有很多，坏人也不少，好人可能也做过坏事，坏人大概率也不是彻头彻尾的坏。沟通的时候应该采用“无罪推定”原则，重大利益面前还是“有罪推定”吧。小亏吃了也没啥，大亏万万不能吃。有些场景本来就是暴力的战争，非暴力适用的场景是沟通。</p><h1 id="非暴力沟通要素"><a href="#非暴力沟通要素" class="headerlink" title="非暴力沟通要素"></a>非暴力沟通要素</h1><p>技能是需要练习的，沟通这项技能有四个要素，<strong>观察</strong>、<strong>感受</strong>、<strong>需要</strong>和 <strong>请求</strong>。通过四要素的逻辑来组织语言，语言结构就不再是随意的、任性的甚至是暴力的，而是一种平等的、尊重的语言。</p><p>比如，你给我一份重要文件，中午出去吃饭我把他放在桌子上了，没有收起来。你看见了然后生气的说：“我给你这么重要的文件，你怎么随便扔在桌子上？”</p><p>用非暴力沟通的方式来组织语言就是这样的：</p><ol><li>观察：我看到你把文件放在桌子上</li><li>感受：我郑重交给你的重要文件，你却随意仍在桌子上，我感到失望</li><li>需要：保管好文件，尊重我的嘱咐</li><li>请求：保管好文件</li></ol><p>经过组织后的语言是这样的：我看见刚才交给你的重要文件没有放在桌子上没有收起来(观察)，我担心不安全(感受)，重要的文件应该妥善保管(需要、请求)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;核心观点&quot;&gt;&lt;a href=&quot;#核心观点&quot; class=&quot;headerlink&quot; title=&quot;核心观点&quot;&gt;&lt;/a&gt;核心观点&lt;/h1&gt;&lt;p&gt;沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配&lt;/p&gt;
&lt;p&gt;暴力行为的背后，往往隐藏着
      
    
    </summary>
    
      <category term="综合能力" scheme="https://iloverainbow.top/categories/%E7%BB%BC%E5%90%88%E8%83%BD%E5%8A%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Fabric基础笔记</title>
    <link href="https://iloverainbow.top/2018/07/01/Fabric%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/07/01/Fabric基础笔记/</id>
    <published>2018-07-01T05:20:59.000Z</published>
    <updated>2018-07-01T05:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。</p><p>为了适用于不同的场合，采用模块化架构，提供可切换和可扩展的组件，包括</p><ol><li>共识算法</li><li>加密安全</li><li>数字资产</li><li>记录仓库</li><li>智能合约</li><li>身份鉴权</li></ol><p>Fabric克服了比特币等公有链项目的缺陷，如吞吐量低、无隐私性、无最终确定性以及共识算法低效等，使得用户能够方便地开发商业应用</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>超级账本的一个重要的设计原则是“用例驱动”(use case driven),所有的功能都有对应的用例需求。Farbic主要针对以下几种用例</p><h3 id="金融资产管存"><a href="#金融资产管存" class="headerlink" title="金融资产管存"></a>金融资产管存</h3><p>资产上链后，权益人可以直接访问资产数据，而无需经过传统的中间人，可大幅度提高效率和节约成本。另外资产附加自动执行的业务规则后，可以进一步降低运营成本。</p><p>与公有链应用的较大区别是，金融资产及其相关的交易、业务规则通常是保密的。</p><h3 id="公司行为"><a href="#公司行为" class="headerlink" title="公司行为"></a>公司行为</h3><p>上市公司发起的有关公司证券的事件一般和股东有关，需要股东做适时的回应。事件的完整信息需要及时传递给股东。股东作出决定后，该结果会实时处理货结算。整个过程应保护股东的隐私，确保投资者的决定不受外界影响</p><h3 id="供应链"><a href="#供应链" class="headerlink" title="供应链"></a>供应链</h3><p>在供应链中，所有的参与者都通过区块链记录、追踪和共享各种数据，例如原材料来源、零部件检测结果以及货物的出处等。数据上链，并贯穿货物的生产、运输和销售等环节，从而提供深度回溯查询等核心功能。</p><h3 id="主数据管理"><a href="#主数据管理" class="headerlink" title="主数据管理"></a>主数据管理</h3><p>在很多行业里，不同的组织之间往往共享一些主数据(master data)。例如，不同移动运营商之间，需要共同维护一份发射基站地理位置的数据。<br>通过区块链来保证数据的质量和完整性。</p><h3 id="分享经济"><a href="#分享经济" class="headerlink" title="分享经济"></a>分享经济</h3><p>分享经济是指将闲置或没有被充分利用的实物资源分享出来，有偿供陌生人暂时使用的一种商业模式。最需要解决的是陌生人之间的信任问题，即资源的提供方和资源的租用者，如何在缺乏信任的基础上安全地完成交易。目前的主要手段是通过分享经济平台来确保信任度。区块链将是一种去信任的方式，不使用任何中间平台，便可达到各方参与者可靠交易的目的</p><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric.JPG" alt="farbic架构"></p><h3 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h3><p>权限区块链与公链最大的区别就是具有身份识别能力。参与者都有明确的身份信息，身份服务管理着系统中各种实体、参与者和对象的身份信息。</p><h3 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h3><p>Fabric的许多功能需要用策略(policy)方式驱动,因此有独立的策略服务来提供系统的策略配置和管理功能。包括访问控制、授权、身份的注册、验证、隐私和保密、共识策略等。</p><h3 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h3><p>提供构建分布式账本最基础的能力，实现数据传输、共识达成等底层功能，并且提供发布/订阅的事件管理框架，分布式账本内部的各种事件可通知到外部监听的应用。主要包含四个组件</p><h5 id="P2P协议组件"><a href="#P2P协议组件" class="headerlink" title="P2P协议组件"></a>P2P协议组件</h5><p>主要提供区块链节点之间直接双向通信的能力，包括流式数据传输、流控制、多路复用等方面。</p><h5 id="分布式账本组件"><a href="#分布式账本组件" class="headerlink" title="分布式账本组件"></a>分布式账本组件</h5><p>维护区块链数据。该组件性能直接影响整个网络的吞吐量，因此需要较高的处理效率</p><h5 id="共识管理组件"><a href="#共识管理组件" class="headerlink" title="共识管理组件"></a>共识管理组件</h5><p>在各种公式算法之上定义里抽象的接口，可以根据场景切换公式算法</p><h5 id="账本存储组件"><a href="#账本存储组件" class="headerlink" title="账本存储组件"></a>账本存储组件</h5><p>链外存储大文件</p><h3 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h3><p>为合约代码提供安全的运行环境以及合约的声明周期管理</p><h1 id="网络与部署"><a href="#网络与部署" class="headerlink" title="网络与部署"></a>网络与部署</h1><p>Fabric网络由4类节点组成<br><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric节点"></p><h3 id="身份服务节点"><a href="#身份服务节点" class="headerlink" title="身份服务节点"></a>身份服务节点</h3><p>负责发放和管理用户的身份，具体来说就是在注册、交易、传输过程中使用的各类数字证书，以及区块链相关的秘钥</p><h3 id="验证节点"><a href="#验证节点" class="headerlink" title="验证节点"></a>验证节点</h3><p>创建和校验交易，并且维护智能合约的状态。在执行交易时，一般需要和其他多数的验证节点达成共识(取决于共识算法),然后才能更新本地的账本数据。每个验证节点在本地都保存一份账本的副本。</p><h3 id="非验证节点"><a href="#非验证节点" class="headerlink" title="非验证节点"></a>非验证节点</h3><p>主要是接受客户端的请求，组装交易，并发往验证节点处理，从这个角度看，非验证节点像交易预处理器，并不负责交易的实际执行。为了加速客户端的查询响应速度，非验证节点在本地也保留一份账本数据的拷贝</p><h3 id="应用节点"><a href="#应用节点" class="headerlink" title="应用节点"></a>应用节点</h3><p>主要提供用户端的后台服务，在收到请求后，把交易请求直接发往(或经由非验证节点转发)验证节点处理</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由于节点部署的多样性，应该考虑通信延迟、网络故障、节点失效、网络恢复等因素</p><h1 id="交易的执行"><a href="#交易的执行" class="headerlink" title="交易的执行"></a>交易的执行</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric执行步骤"><br>交易(transaction)分两种:部署智能合约，执行智能合约</p><p>部署步骤：</p><ol><li>客户端通过API提交代码给验证节点</li><li>验证节点确认代码有效</li><li>验证节点同步到其他节点</li></ol><p>执行步骤：</p><ol><li>客户端发送执行请求给验证节点</li><li>验证节点收到请求后，向本地账本发送启动交易的指令</li><li>验证节点创建隔离的运行环境，启动应用(智能合约)代码</li><li>应用执行过程中，更新本地账本的状态</li><li>应用完成后，验证节点想本地账本确认交易</li><li>验证节点向其他验证节点广播交易</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h1&gt;&lt;p&gt;Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。&lt;/p&gt;
&lt;p&gt;为了适用
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>智能合约基础笔记</title>
    <link href="https://iloverainbow.top/2018/06/30/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/06/30/智能合约基础笔记/</id>
    <published>2018-06-30T09:25:46.000Z</published>
    <updated>2018-06-30T09:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能合约简介"><a href="#智能合约简介" class="headerlink" title="智能合约简介"></a>智能合约简介</h1><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><ol><li>法律角度，智能合约是否是一个真正意义上的合约还有待确认</li><li>计算机科学角度，智能合约是一种计算机协议，一旦制定和部署就能实现自我执行(self-executing)和自我验证(self-verifying)，而且不再需要人为的干预</li><li>技术角度，一种计算机程序，能够自主执行合约相关的操作，并产生相应的可验证的证据，来说明执行合约操作的有效性</li></ol><p>例如，银行账户的存取款可以用合约来替代，以及任何需要记录信息的场合</p><h3 id="智能合约的历史"><a href="#智能合约的历史" class="headerlink" title="智能合约的历史"></a>智能合约的历史</h3><ol><li>20世纪七八十年代，人们提出了让计算机代替人类进行商业市场管理的想法。</li><li>九十年代，研究数字合约和数字货币的Nick Szabo提出了“智能合约”</li><li>08年比特币出现，借由其背后的区块链技术，智能合约飞速发展</li></ol><h5 id="Nick-Szabo对智能合约的定义"><a href="#Nick-Szabo对智能合约的定义" class="headerlink" title="Nick Szabo对智能合约的定义"></a>Nick Szabo对智能合约的定义</h5><p>智能合约是一个由计算机处理的、可执行合约条款的交易协议。其总体目标是能够满足普通的合约条件，例如支付、抵押、保密甚至强制执行，并最小化恶意或意外事件发生的可能性、以及最小化对信任中介的需求。智能合约所要达到的相关经济目标包括降低合约欺诈所造成的损失，降低仲裁和强制执行所产生的成本以及其他交易成本等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高效的实时更新</li><li>准确执行</li><li>较低的认为干预风险</li><li>去中心化权威</li><li>较低的运行成本<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3></li><li>现实中的合同出现漏洞可以协商或者通过法律和仲裁解决，智能合约的漏洞执行后无法修补</li><li>智能合约的自我验证特性导致隐私性低</li></ol><h1 id="以太坊智能合约详解"><a href="#以太坊智能合约详解" class="headerlink" title="以太坊智能合约详解"></a>以太坊智能合约详解</h1><h3 id="合约操作流程"><a href="#合约操作流程" class="headerlink" title="合约操作流程"></a>合约操作流程</h3><ol><li>启动一个节点</li><li>编写合约</li><li>编译</li><li>部署，矿工确认。得到地址与接口</li><li>使用web3.js接口调用合约<h3 id="以太坊上的账户"><a href="#以太坊上的账户" class="headerlink" title="以太坊上的账户"></a>以太坊上的账户</h3>两类账户，公用一个空间地址。</li></ol><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="钥匙文件"><a href="#钥匙文件" class="headerlink" title="钥匙文件"></a>钥匙文件</h5><ol><li>账户通过私钥和公钥确定</li><li>账户地址是公钥的最后20个字节</li><li>账户地址和私钥密文存储在钥匙文件keyfile中</li><li>私钥总是处于加密状态，秘钥是创建账户时输入的密码</li><li>通过秘钥和keyfile中的私钥密文才能得到私钥，进行交易</li><li>要确保备份好keyfile和秘钥<h5 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装客户端</span><br><span class="line">brew install ethereum</span><br><span class="line"></span><br><span class="line">创建账户</span><br><span class="line">geth account new</span><br><span class="line"></span><br><span class="line">同步区块</span><br><span class="line">geth</span><br></pre></td></tr></table></figure></li></ol><h5 id="账户的备份"><a href="#账户的备份" class="headerlink" title="账户的备份"></a>账户的备份</h5><p>~/Library/Ethereum/keystore/keyfile<br>这是账户数据，备份好</p><h3 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h3><p>为防止用户恶意部署无限循环运行的合约，合约执行的每一步都需要支付费用，就是gas。</p><ol><li><strong>Gas花销Gascost</strong>：针对具体操作是不变的。保证每种操作所需的计算资源保持不变</li><li><strong>Gas价格Gasprice</strong>：每个gas所需的以太币。由用户控制，价格高的确认快。并且随以太币的市值波动，以保证运行智能合约所需的真实花费不会出现大幅度变化</li><li><strong>Gasfee</strong>：Gascost*Gasprice，真实费用，单位是以太币</li></ol><h3 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h3><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>合约账户有能力向其他合约账户发送消息，它是一个虚拟的对象，不会具体的存储在以太坊的区块链内，可以看做一个函数调用的过程</p><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指外部所有账户将一个经过签名的数据包发送到另一个账户的过程，这个过程中产生的账户状态变化被存储到区块链上</p><p>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h1 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h1><h3 id="Gas的消耗"><a href="#Gas的消耗" class="headerlink" title="Gas的消耗"></a>Gas的消耗</h3><ol><li>最常见的，执行特定的内部抽象操作。例如运行SHA3散列运算</li><li>进行一个从属的消息调用或合约创建时，例如执行CREATE、CALL、CALLCODE操作</li><li>增加账户内存使用量</li></ol><p>内存使用计费机制鼓励用户使用较少的内存。执行账户内存清理操作不消耗GAS，还会得到折扣。</p><h3 id="虚拟机运行环境"><a href="#虚拟机运行环境" class="headerlink" title="虚拟机运行环境"></a>虚拟机运行环境</h3><ol><li>以太坊网络状态</li><li>合约剩余GAS</li><li>当前代码合约地址</li><li>合约发起者地址</li><li>Gasprice</li><li>交易的输入数据</li><li>执行合约交易的账户地址</li><li>合约账户的余额</li><li>用于执行虚拟机代码所需的数组</li><li>目前区块的数据头</li><li>目前执行的CALL操作和CREATE操作的数量</li></ol><h3 id="区块链系统状态的验证"><a href="#区块链系统状态的验证" class="headerlink" title="区块链系统状态的验证"></a>区块链系统状态的验证</h3><p>每产生一个新的有效区块，以太坊系统需要以下几个步骤将该区块加入权威区块链上</p><ol><li>验证新区快的ommer区块的有效性。验证叔区块？</li><li>验证新区快所包含交易的有效性，即所有交易所花费的GAS是否与新区块链中标记的花费量一致，并且每笔交易一一对应</li><li>给该区块和ommer区块的矿工发放奖励</li><li>验证新区快的工作量证明，连接主链，然后将整个系统更新</li></ol><h1 id="智能合约操作"><a href="#智能合约操作" class="headerlink" title="智能合约操作"></a>智能合约操作</h1><h3 id="钱包部署"><a href="#钱包部署" class="headerlink" title="钱包部署"></a>钱包部署</h3><p>Mist或者Eth Wallet</p><h3 id="命令行部署"><a href="#命令行部署" class="headerlink" title="命令行部署"></a>命令行部署</h3><p>通过web3.js的API在命令行部署</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智能合约简介&quot;&gt;&lt;a href=&quot;#智能合约简介&quot; class=&quot;headerlink&quot; title=&quot;智能合约简介&quot;&gt;&lt;/a&gt;智能合约简介&lt;/h1&gt;&lt;h3 id=&quot;什么是智能合约&quot;&gt;&lt;a href=&quot;#什么是智能合约&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Makefile笔记</title>
    <link href="https://iloverainbow.top/2018/06/29/makefile%E6%89%8B%E5%86%8C/"/>
    <id>https://iloverainbow.top/2018/06/29/makefile手册/</id>
    <published>2018-06-29T13:43:39.000Z</published>
    <updated>2019-10-10T08:23:10.468Z</updated>
    
    <content type="html"><![CDATA[<p>根据指定的Shell命令进行构建的工具</p><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pjName := wordpress</span><br><span class="line"><span class="comment"># 变量</span></span><br><span class="line"><span class="section">docker:</span></span><br><span class="line">docker run \</span><br><span class="line">--name $&#123;pjName&#125; \</span><br><span class="line"><span class="comment"># 容器名</span></span><br><span class="line">--rm \</span><br><span class="line"><span class="comment"># 停止运行后自动删除当前容器</span></span><br><span class="line">-ti \</span><br><span class="line"><span class="comment"># t for terminal,i for interact</span></span><br><span class="line">-v $<span class="variable">$(pwd)</span>:/var/www/html \</span><br><span class="line"><span class="comment"># 映射当前目录到容器指定目录</span></span><br><span class="line">-p 3000:3000 \</span><br><span class="line"><span class="comment"># 映射端口到容器端口</span></span><br><span class="line">mooxe/node \</span><br><span class="line">/bin/bash</span><br><span class="line"><span class="comment"># 额外加一个命令，只能加一个</span></span><br><span class="line"><span class="comment"># 这是运行bash shell</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据指定的Shell命令进行构建的工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/02/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifen
      
    
    </summary>
    
      <category term="运维" scheme="https://iloverainbow.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="https://iloverainbow.top/2018/06/29/Docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/06/29/Docker笔记/</id>
    <published>2018-06-29T13:42:43.000Z</published>
    <updated>2019-10-10T08:20:59.985Z</updated>
    
    <content type="html"><![CDATA[<p>可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行</p><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><p>update：K8s的pod才可以理解为虚拟机，容器其实就是一个进程，被修饰过，有点特殊的进程。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p> 获取image</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p> 创建image</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p> 列出image</p><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p> 运行container，跑一个项目<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> \</span><br><span class="line">--name $&#123;pjName&#125; \</span><br><span class="line"># 容器名</span><br><span class="line">--rm \</span><br><span class="line"># 停止运行后自动删除当前容器</span><br><span class="line">-ti \</span><br><span class="line"># t for terminal,i for interact</span><br><span class="line">-v $$(pwd):/var/www/html \</span><br><span class="line"># 映射当前目录到容器指定目录</span><br><span class="line">-p 3000:3000 \</span><br><span class="line"># 映射端口到容器端口</span><br><span class="line">mooxe/node \</span><br><span class="line">/bin/bash</span><br><span class="line"># 额外加一个命令，只能加一个</span><br><span class="line"># 这是运行bash shell</span><br></pre></td></tr></table></figure></p><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p> 列出container，项目们<br> -a</p><p> 列出隐藏的</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p> 删除container</p><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p> 删除image</p><h2 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h2><p> 在host和container之间拷贝文件</p><h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><p> 保存改动为新的image</p><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>FROM: base image</p><p>RUN: 执行命令</p><p>ADD： 添加文件</p><p>COPY： 拷贝文件</p><p>CMD： 执行命令，打包完成之后</p><p>EXPOSE： 暴露端口</p><p>WORKDIR： 指定路径</p><p>MAINTAINER: 维护者</p><p>ENV: 设定环境变量</p><p>ENTRYPOINT: 容器入口</p><p>USER: 指定用户</p><p>VOLUME: mount point</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以指定依赖的node镜像的版本 node:&lt;version&gt;，如果不指定，就会是最新的</span></span><br><span class="line">FROM node:8.6.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工作目录，对应的是应用代码存放在容器内的路径</span></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)</span></span><br><span class="line">COPY package.json *.lock .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只安装dependencies依赖</span></span><br><span class="line"><span class="comment"># node镜像自带yarn</span></span><br><span class="line">RUN yarn --only=prod --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把其他源文件复制到工作目录</span></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换成应用实际的端口号</span></span><br><span class="line">EXPOSE <span class="variable">$&#123;app_port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里根据实际起动命令做修改</span></span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br><span class="line"></span><br><span class="line">docker build -t hello_docker .</span><br><span class="line">使用.目录下的dockerfile文件创建一个叫做hello_docker的镜像，</span><br></pre></td></tr></table></figure><h1 id="使用docker步骤"><a href="#使用docker步骤" class="headerlink" title="使用docker步骤"></a>使用docker步骤</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 拉取镜像 --&gt;</span><br><span class="line">docker image pull imagename</span><br><span class="line">&lt;!-- 查看镜像 --&gt;</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>docker commit将指定容器保存为新的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;Container ID&gt; &lt;Name&gt;:&lt;Tag&gt;</span><br><span class="line">docker commit fldhsa5342hkjhs bitcoin:0.1</span><br></pre></td></tr></table></figure></p><p>根据dockerfile创建镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imagename .</span><br></pre></td></tr></table></figure></p><h2 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行镜像 </span></span><br><span class="line">docker run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器 </span></span><br><span class="line">docker rm [containerID]</span><br></pre></td></tr></table></figure></p><ul><li>-p参数：容器的 3000 端口映射到本机的 8000 端口。</li><li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="运维" scheme="https://iloverainbow.top/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链基础知识</title>
    <link href="https://iloverainbow.top/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://iloverainbow.top/2018/06/29/区块链/</id>
    <published>2018-06-29T10:33:53.000Z</published>
    <updated>2018-06-29T10:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链简介"><a href="#区块链简介" class="headerlink" title="区块链简介"></a>区块链简介</h1><p> 去中心化的方式建立信任，不需要大机构的背书。</p><p> 区块链定义：基于区块链技术形成的公共数据库(公共账本)<br> 区块链技术：多个参与方之间基于现代密码学、分布式一致性协议、点对点网络通信技术和智能合约编程语言等形成的数据交换、处理和存储的技术组合。同时，仍在不断发展和演化中。</p><h3 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h3><p>从参与方的角度来分，可以分为公共链、联盟链和私有链。从链与链的关系的角度来分，可以分为主链和侧链。不同区块链还可以形成网络，网络总链与链的互联互通。产生互联链Interchain的概念</p><h5 id="公共链"><a href="#公共链" class="headerlink" title="公共链"></a>公共链</h5><p>对外公开，用户不用注册就能匿名参与。<br>比特币和以太坊都是公链。<br>也叫非许可链Permissionless Blockchain。</p><p>公链适用于虚拟货币、面向大众的电子商务、互联网金融等B2C、C2C或C2B场景</p><h5 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h5><p>联盟链Consortium Blockchain，仅限联盟成员参与。读写权限、参与记账权限按照联盟规则来制定。也叫做许可链Permissioned Blockchain.<br>例如有四十多家银行参与的R3和Linux基金会支持的超级账本Hyperleder。</p><p>联盟链适用于机构间的交易、结算或清算等B2B场景。</p><h5 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h5><p>私有组织使用，区块链上的读写权限、参与记账权限按私有组织股则来制定。应用场景一般是企业内部的应用，如数据库管理、审计。<br>把制度写在区块链上。还有政府的一些应用，比如政府的预算和执行，或者政府的行业统计数据。</p><p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范内部和外部对数据的安全攻击。</p><p>Coin Science的Multichain平台提供一个在企业内部快速部署私链的解决方案。可以用于去中心化交易所、数据库同步、货币结算、债券发行和P2P交易、消费行业积分奖励机制等场景。</p><h5 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h5><p>侧链是能和比特币区块链交互，并与比特币挂钩的区块链。<br>主链不易改动。<br>比特币每秒只能确认7笔交易，通过侧链Side Chains提升效率，扩展比特币功能是一个有效的做法。例如闪电网络把交易放在侧链，只有在做清算时才用上主链。矿工打包少了，回报就少了。</p><h5 id="互联链"><a href="#互联链" class="headerlink" title="互联链"></a>互联链</h5><p>针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种协议连接起来。可以类比互联网</p><h3 id="区块链的价值与应用"><a href="#区块链的价值与应用" class="headerlink" title="区块链的价值与应用"></a>区块链的价值与应用</h3><p>区块链技术是一揽子技术，根据业务需要可以针对性的组合和创新。<br>价值很多，很大，这个需要慢慢理解，放一放，先上手技术。</p><h1 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h5 id="数据区块"><a href="#数据区块" class="headerlink" title="数据区块"></a>数据区块</h5><p>区块结构分为区块头和区块体</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区快加上随机数的哈希值满足一定的难度条件。找到了就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。<br>然后把新节点广播出去。</p><h5 id="挖矿与分叉问题"><a href="#挖矿与分叉问题" class="headerlink" title="挖矿与分叉问题"></a>挖矿与分叉问题</h5><p>穷举随机数算法，把上个区块的哈希值加上十分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数nonce使哈希值满足一定条件就获得这个区块的交易记账权。</p><p>后续矿工总是选择累计工作量证明最大的区块链。结果就是自动抛弃分叉处的短链。</p><h5 id="时间戳与不可篡改性"><a href="#时间戳与不可篡改性" class="headerlink" title="时间戳与不可篡改性"></a>时间戳与不可篡改性</h5><p>时间戳是歌灵位置时间到现在的总秒数，通常是一个字符序列，唯一标识某一刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时间。</p><p>时间戳技术很简单，但意义重大，极大的增强了不可篡改性</p><h5 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h5><p>可以理解为一个分布式数据库</p><h5 id="UTXO交易模式"><a href="#UTXO交易模式" class="headerlink" title="UTXO交易模式"></a>UTXO交易模式</h5><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><h5 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h5><h5 id="双花"><a href="#双花" class="headerlink" title="双花"></a>双花</h5><ol><li>双花如何发生？</li></ol><p>花了一次，还没有上链的时候再花一次</p><ol><li>如何避免</li></ol><p>时间戳+UTXO+数字签名</p><h5 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h5><p>P2P网络是一种在peer(对等者)之间分配任务和工作负载的分布式架构，是对等计算模型在应用层形成的一种组网或网络形式。</p><p>每个节点均承担网络路由，验证数据区块等功能。根据存储数据量分为全节点和轻节点。</p><p>全节点存储了所有区块链数据，数据校验不需要别的节点，硬件成本高。</p><p>轻节点只存储部分，需要别的数据时通过建议支付验证(Simplified Payment Verification, SPV)向临近节点请求数据来完成验证更新</p><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p>非对称加密算法(椭圆曲线加密算法，ECC)</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名就是在信息后加上一段内容，作为发送者的证明并且证明信息没有被篡改</p><p>要传送的信息先经过哈希得到一个值，再用私钥加密得到签名。对信息进行两次操作得到签名。</p><p>接受方通过发送方的公钥解密，然后对信息哈希，然后比对，验证需要三步。</p><p>公钥锁定比特币，私钥解锁，拥有私钥才能使用。</p><h5 id="比特币的隐私模型"><a href="#比特币的隐私模型" class="headerlink" title="比特币的隐私模型"></a>比特币的隐私模型</h5><p>匿名性好一截。进行交易不需要身份信息。</p><h3 id="框架与特点"><a href="#框架与特点" class="headerlink" title="框架与特点"></a>框架与特点</h3><h5 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h5><ol><li>网络层</li></ol><p>两个部分，P2P网络和TCP/IP协议。P2P网络提供了更好的安全性，任何一个节点被攻击都不会影响整个网络</p><ol><li>数据层</li></ol><p>三个部分，公共总账本，共识算法，密码学。在数据层面上，区块链就是一个只能追加、不可更改的分布式数据库系统，是一个分布式账本。通过公式算法保持账本的一致性。通过密码学的签名和哈希算法来确保这个账本不可篡改、不能作为，并且可追溯。</p><p>同时带有经济激励的工作量证明机制，使得即使拥有51%算力的人也不会损害自身利益去发起攻击</p><ol><li>应用层</li></ol><p>三个部分，可编程货币，可编程金融，可编程社会</p><p>区块链平台提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方上。<br>因此，智能合约可以降低合约建立、执行和仲裁中所涉及的中间机构成本。</p><h5 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h5><ol><li>去中心化</li><li>可靠数据库</li><li>开源可编程</li><li>集体维护</li><li>安全可信</li><li>准匿名性<h3 id="区块链运作的核心技术"><a href="#区块链运作的核心技术" class="headerlink" title="区块链运作的核心技术"></a>区块链运作的核心技术</h3><h5 id="区块链的连接"><a href="#区块链的连接" class="headerlink" title="区块链的连接"></a>区块链的连接</h5>区块头中上一区块的哈希值用来实现区块的连接，区块头中的随机数用来实现挖矿机制<h5 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h5>1 PoW<br>工作量证明</li></ol><p>优点： 完全去中心化，节点自由进出</p><p>缺点： 浪费大量资源，挖矿激励机制导致矿池算力集中，不去中心化了。更大的问题是，PoW机制达成共识的周期长，每秒智能作7笔交易，不适合商业应用</p><p>2 PoS</p><p>Proof of Stake，权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。拥有代币越多的节点获得记账权的概率越大。为了平衡会引入其他机制。</p><p>优点： 一定程度上缩短了共识达成的时间，降低了资源浪费</p><p>缺点： 破坏者攻击网络的成本低。拥有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性</p><p>3 DPoS</p><p>股份授权机制，类似于董事会投票。持股人投票选出一定数量的见证人，见证人生成区块。持股人可以随时通过投票更换这些见证人。</p><p>优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证</p><p>缺点： 选举固定数量的见证人作为记账候选人有可能不适用与完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。</p><p>4 分布式一致性算法<br>基于传统的分布式技术。有解决拜占庭将军问题的拜占庭容错算法，如PBFT。还有解决非拜占庭问题的分布式一致性算法(Pasox, Raft)。 目前联盟链和私有链场景中常使用。</p><p>优点： 实现妙计的快速共识机制，保证一致性</p><p>缺点： 去中心化程度不如公链上的共识机制，更适合多方参与的多中心商业模式</p><h5 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h5><p>交易的输出其实是指向一个脚本，而不是地址。它类似一套规则，约束着接收方怎样才能划掉这个输出上锁定的资产。</p><p>交易的合法性也依赖于脚本。锁定脚本和解锁脚本。</p><p>比特币的脚本机制相对简单，不能实现复杂的逻辑。但为后来者们提供了可编程区块链的原型。</p><h5 id="交易规则"><a href="#交易规则" class="headerlink" title="交易规则"></a>交易规则</h5><h5 id="交易优先级"><a href="#交易优先级" class="headerlink" title="交易优先级"></a>交易优先级</h5><h5 id="Merkle证明"><a href="#Merkle证明" class="headerlink" title="Merkle证明"></a>Merkle证明</h5><p>Merkle树的重要使用场景是快速支付验证。轻节点只下载区块头，数据大小为80字节。</p><p>能证明包含的交易，但无法证明任何当前的状态。</p><p>以太坊中有三棵树，分别对应交易transactions，收据recipts和状态State</p><h5 id="RLP"><a href="#RLP" class="headerlink" title="RLP"></a>RLP</h5><p>Recursive Length Prefix，递归长度前缀编码，是以太坊中对象序列化的一个主要编码方式。先放着</p><h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><ol><li>交易的生成：新交易创建</li><li>交易的传播：交易通过P2P网络传播</li><li>工作量证明：交易验证</li><li>整个网络节点验证：3的验证结果在P2P网络中传播</li><li>记录到区块链：交易写入账本</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区块链简介&quot;&gt;&lt;a href=&quot;#区块链简介&quot; class=&quot;headerlink&quot; title=&quot;区块链简介&quot;&gt;&lt;/a&gt;区块链简介&lt;/h1&gt;&lt;p&gt; 去中心化的方式建立信任，不需要大机构的背书。&lt;/p&gt;
&lt;p&gt; 区块链定义：基于区块链技术形成的公共数据库(公共账本
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>比特币基础知识</title>
    <link href="https://iloverainbow.top/2018/06/29/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>https://iloverainbow.top/2018/06/29/比特币/</id>
    <published>2018-06-29T10:32:34.000Z</published>
    <updated>2018-06-29T10:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="比特币特性"><a href="#比特币特性" class="headerlink" title="比特币特性"></a>比特币特性</h3><h5 id="硬通货"><a href="#硬通货" class="headerlink" title="硬通货"></a>硬通货</h5><p>跨境交易</p><h5 id="易携带"><a href="#易携带" class="headerlink" title="易携带"></a>易携带</h5><p>只需一个私钥</p><h5 id="私密性"><a href="#私密性" class="headerlink" title="私密性"></a>私密性</h5><ol><li>只暴露钱包地址</li><li>非法应用</li></ol><h5 id="无货币超发"><a href="#无货币超发" class="headerlink" title="无货币超发"></a>无货币超发</h5><p>通货紧缩</p><ol><li>去中心化，P2P分布式的数字货币系统</li><li>共识机制 - POW工作量证明</li><li>非对称密码学，公钥私钥</li><li>区块链作为账本</li></ol><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h3 id="POW共识机制"><a href="#POW共识机制" class="headerlink" title="POW共识机制"></a>POW共识机制</h3><p>proof of work<br>通过挖矿保证我是个善意的节点，并获得生成区块，和在这个区块里记账的权利</p><h3 id="区块的生成和连接"><a href="#区块的生成和连接" class="headerlink" title="区块的生成和连接"></a>区块的生成和连接</h3><ol><li>比特币由挖矿而产生，通过计算出一个算计数字nonce</li><li>生成的BTC被记录在矿工名下，通过矿工的公钥的哈希值锁定</li><li>交易的输出被称为UTXO，unspent transaction output,未花费交易</li><li>比特币钱包余额就是根据众多UTXO计算出来的</li><li>新区块通过包含前一个区块头部的哈希值建立链接关系。</li><li>区块链有时会产生临时的分叉而生成两条链，最终较短的链将被舍弃</li></ol><h3 id="UTXO的生成和销毁"><a href="#UTXO的生成和销毁" class="headerlink" title="UTXO的生成和销毁"></a>UTXO的生成和销毁</h3><p>交易包含三项，</p><ol><li>交易的输入，UTXO指针</li><li>交易的输出，UTXO</li><li>解锁脚本，私钥签名，公钥</li></ol><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h3 id=&quot;比特币特性&quot;&gt;&lt;a href=&quot;#比特币特性&quot; class=&quot;headerlink&quot; title=&quot;比特币特性&quot;&gt;&lt;/a&gt;比特币特
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链中的密码学技术</title>
    <link href="https://iloverainbow.top/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF/"/>
    <id>https://iloverainbow.top/2018/06/29/区块链中的密码学技术/</id>
    <published>2018-06-29T10:10:10.000Z</published>
    <updated>2018-06-29T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认证。</p><p>在比特币系统中，基于寻找给定前缀的SHA256哈希值，设计了工作量证明的共识机制</p><h3 id="哈希算法的性质与应用"><a href="#哈希算法的性质与应用" class="headerlink" title="哈希算法的性质与应用"></a>哈希算法的性质与应用</h3><h5 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h5><p>就是 两个信息具有相同的哈希值是不可能的</p><h5 id="原像不可逆"><a href="#原像不可逆" class="headerlink" title="原像不可逆"></a>原像不可逆</h5><p>不能根据哈希值推导出原值</p><h5 id="难题友好性"><a href="#难题友好性" class="headerlink" title="难题友好性"></a>难题友好性</h5><p>没有便捷的方式去产生一个特定要求的哈希值，只能穷举。</p><h3 id="哈希指针链"><a href="#哈希指针链" class="headerlink" title="哈希指针链"></a>哈希指针链</h3><p>用于验证信息是否发生改变。区块链可以看做一类使用哈希指针的链表。</p><h1 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h1><p>一类基于哈希值的二叉树或多叉树。<br>区块链中的Merkle树是二叉树，用于存储交易信息。</p><p>叶子： 数据块的哈希值</p><p>节点： 孩子节点的哈希值</p><p>用于检测数据副本的一致性，以减少传输的数据量。</p><h1 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h1><h3 id="椭圆曲线密码算法"><a href="#椭圆曲线密码算法" class="headerlink" title="椭圆曲线密码算法"></a>椭圆曲线密码算法</h3><h3 id="secp256k1椭圆曲线"><a href="#secp256k1椭圆曲线" class="headerlink" title="secp256k1椭圆曲线"></a>secp256k1椭圆曲线</h3><h3 id="椭圆曲线签名与验证签名"><a href="#椭圆曲线签名与验证签名" class="headerlink" title="椭圆曲线签名与验证签名"></a>椭圆曲线签名与验证签名</h3><p>先放一放，现在不感兴趣。等需要的时候再来学</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h1&gt;&lt;p&gt;一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>敏捷编码</title>
    <link href="https://iloverainbow.top/2018/06/23/%E6%95%8F%E6%8D%B7%E7%BC%96%E7%A0%81/"/>
    <id>https://iloverainbow.top/2018/06/23/敏捷编码/</id>
    <published>2018-06-23T15:35:05.000Z</published>
    <updated>2019-10-09T10:42:50.481Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《敏捷开发修炼之道》中敏捷编码一章的总结</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行正确的代码编写方式。</p><ol><li>代码要清晰地表达意图</li><li>用代码沟通</li><li>动态评估取舍</li><li>增量式编程</li><li>保持简单</li><li>编写内聚的代码</li><li>告知，不要询问</li><li>根据契约进行替换</li></ol><h1 id="代码要清晰地表达意图"><a href="#代码要清晰地表达意图" class="headerlink" title="代码要清晰地表达意图"></a>代码要清晰地表达意图</h1><p>PIE(Program Intently and Expressively)原则，意图清晰，表达明确</p><ol><li>充分语义化，尽量不看定义也能明白</li><li>使用方法名传达意向，方法参数名帮助读者理解背后的想法</li><li>正确的使用和命名异常</li><li>使用语言特性提升表现力</li><li>好的编码规范可以让代码容易理解，同时减少不必要的注释和文档</li><li>编写清晰而不是讨巧的代码，比如位移操作可读性就不好</li><li>想象一年后的自己来阅读代码，读一次就能明白</li><li>有意图的编程不是创建更多的类或者类型，这不是过分抽象的理由</li><li>使用合适的耦合。例如，通过散列表进行松耦合。散列表存储紧密耦合的组件没有明确的表示意图</li></ol><h1 id="用代码沟通"><a href="#用代码沟通" class="headerlink" title="用代码沟通"></a>用代码沟通</h1><p>读代码的方式：先阅读注释，然后快速浏览代码。从而理解它做了什么，为什么这么做</p><p>建立代码文档有两种方式，利用代码本身以及利用注释来沟通代码之外的事情</p><p>适当的注释和良好的代码能让人快速理解代码。知道代码的意图，结果和需要注意的地方。</p><h3 id="优雅清晰的代码"><a href="#优雅清晰的代码" class="headerlink" title="优雅清晰的代码"></a>优雅清晰的代码</h3><p>优雅的代码易于辨识和理解，简洁，第一眼看上去就知道它的用处</p><ol><li>变量名运用正确</li><li>空格使用得当</li><li>逻辑分离清晰</li><li>表达式简洁</li><li>清晰的执行路径</li></ol><h5 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h5><ol><li>好名字向读者传递大量信息，不好的名字无法传递信息，糟糕的名字传递错误的信息</li><li>遵循习惯用法。比如i表示循环索引量，s表示字符串</li></ol><h3 id="适当的注释"><a href="#适当的注释" class="headerlink" title="适当的注释"></a>适当的注释</h3><ol><li>克制在方法体内部的注释。</li><li>为读者指定一条正确的代码访问路线图</li><li>为代码中的每个类或模块添加一个短小的描述，说明目的以及要求</li><li>对于类中的每个方法，可能要说明四点。目的，输入，输出和异常</li><li>注释不能替代优秀的代码</li><li>在代码可以传递意图的地方不要使用注释</li><li>解释代码做了什么的注释用处不大。注释要说明为什么这样做</li><li>重写方法时，保留描述原有方法意图和约束的注释</li></ol><h1 id="动态评估取舍"><a href="#动态评估取舍" class="headerlink" title="动态评估取舍"></a>动态评估取舍</h1><p><strong>错误观点</strong>：性能、生产力、优雅、成本、以及上市时间，在软件开发过程中都是至关重要的因素，每一项都必须达到最理想状态<br><strong>正确观点</strong>：如果性能表现足够了，就把注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化</p><ul><li>由用户或者利益相关者来评估性能是否足够，界面是否吸引人</li><li>即使不能面面俱到，你也应该得到最重要的东西——客户认为有价值的特性</li><li>如果现在要投入额外的资源和精力是为了将来可能得到的好处，那么要确认投入一定要得到回报</li><li>真正的高性能系统，从一开始设计时就在向这个方向努力</li><li>过早的优化是万恶之源</li></ul><h1 id="增量式编程"><a href="#增量式编程" class="headerlink" title="增量式编程"></a>增量式编程</h1><p><strong>在很短的编辑/构建/测试循环中编写代码</strong>，可以创建更加清晰、简单、易于维护的代码</p><p>采取增量式编程，会更倾向于创建更小的方法和更具内聚性的类</p><ul><li>如果构建和测试花费的时间过长，你就不会经常运行它们了。要保证测试可以快速运行</li><li>在编译和测试中，停下来想一想，并暂时远离代码细节，这是保证不会偏离正确方向的好办法</li><li>要像重构代码一样重构测试，并且经常重构测试</li></ul><h1 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h1><ul><li>不要过度设计</li><li>开发可以工作的、最简单的解决方案。就是没有一行多余代码，并且仍能交付全部功能</li><li>使用模式、原则和高难度技术要有明确的目的</li><li>代码几乎总可以得到进一步精炼，但是到了某个点之后，再做改进就不会带来实质性的好处了。这时就改停下来去做其他的事情了</li><li>强行让代码变得优雅与过早优化一样，会产生恶劣的影响</li><li>简单不是在功能上妥协</li><li>简单不是单纯的代码量少，要兼顾可读性</li><li>一个人认为简单的东西，可能对另一个人意味着复杂</li></ul><h1 id="编写内聚的代码"><a href="#编写内聚的代码" class="headerlink" title="编写内聚的代码"></a>编写内聚的代码</h1><p>内聚性用来评价一个组件中成员的功能相关性。内聚性高说明各成员共同完成了一个或一组功能特性</p><p>好处：</p><ol><li>稳定，维护成本低</li><li>可重用性高</li><li>责任清晰，易跟踪，易修改</li></ol><p>方法：</p><ul><li>在创建一个类的时候，想一下，这个类的功能是否与其他类的功能相似</li><li>让类的功能尽量集中，组件尽量小，避免创建很大的类</li><li>拆分太小也不行。</li></ul><h1 id="告知，不要询问"><a href="#告知，不要询问" class="headerlink" title="告知，不要询问"></a>告知，不要询问</h1><p>作为某段代码的调用者，开发人员绝不应该基于<em>被调用对象的状态</em>来做任何决策，更<em>不能改变该对象的状态</em>，这是被调用对象的责任。在对象之外替他做决策，违反了封装原则，而且为bug提供了土壤。</p><p>这一条我没理解。想象不出场景</p><h1 id="根据契约进行替换"><a href="#根据契约进行替换" class="headerlink" title="根据契约进行替换"></a>根据契约进行替换</h1><p>替换组件代码，其他代码无感知</p><p>通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。委托比继承灵活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为《敏捷开发修炼之道》中敏捷编码一章的总结&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
