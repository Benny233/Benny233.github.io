<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Benny&#39;s Notebook</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iloverainbow.top/"/>
  <updated>2019-10-04T16:57:35.894Z</updated>
  <id>https://iloverainbow.top/</id>
  
  <author>
    <name>Benny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云效搭建单机自动化部署系统</title>
    <link href="https://iloverainbow.top/2019/10/05/%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%88%E6%90%AD%E5%BB%BA%E5%8D%95%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://iloverainbow.top/2019/10/05/阿里云效搭建单机自动化部署系统/</id>
    <published>2019-10-04T16:24:29.000Z</published>
    <updated>2019-10-04T16:57:35.894Z</updated>
    
    <content type="html"><![CDATA[<p>嘿嘿嘿</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;嘿嘿嘿&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>arts打卡-1</title>
    <link href="https://iloverainbow.top/2019/06/04/arts%E6%89%93%E5%8D%A1-1/"/>
    <id>https://iloverainbow.top/2019/06/04/arts打卡-1/</id>
    <published>2019-06-04T09:51:47.000Z</published>
    <updated>2019-06-04T09:52:14.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>框架图，设计流程？</p><p>交互设计要明确产品的任务==需求==和==目标==，通过系统的==规划==，梳理产品==逻辑==关系，做出漂亮的交互设计==流程==</p><p>通过设计测试，优化产品的可用性</p><p>最终，交互设计的目标是，优化产品的用户体验</p><h2 id="2-产品开发流程与团队构成"><a href="#2-产品开发流程与团队构成" class="headerlink" title="2 产品开发流程与团队构成"></a>2 产品开发流程与团队构成</h2><h4 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h4><p>需求的讨论和用户的调研，确认我到底要做什么，我的目标用户是什么，他们需要什么</p><h4 id="交互设计师"><a href="#交互设计师" class="headerlink" title="交互设计师"></a>交互设计师</h4><p>产品经理完成了比较好的用户调研，需求调研之后，交互设计师来把需求落地，形成真正的功能流程和界面原型，让后面的ui和开发知道要做一个什么样的产品  </p><p>产品经理说，我们需要一个看电影的工具，交互设计师把这个工具长什么样告诉其他成员</p><h4 id="交互设计师的输出："><a href="#交互设计师的输出：" class="headerlink" title="交互设计师的输出："></a>交互设计师的输出：</h4><ol><li>交互原型图</li><li>交互设计文档</li></ol><p>还有审核视觉稿 </p><p>还要和qa一起审核开发出来的产品是不是用户真的能顺利使用</p><h2 id="3-交互设计关键着用户体验"><a href="#3-交互设计关键着用户体验" class="headerlink" title="3 交互设计关键着用户体验"></a>3 交互设计关键着用户体验</h2><p>很多产品没有经过良好的设计</p><p>用户体验的定义：</p><p>用户对于使用或期望使用的产品、系统、服务的==主观感受==和==反应==</p><p>交互设计如何影响用户体验：</p><p>更少消耗，等多需求的满足</p><p>优秀的交互设计来源于生活，比如网易云音乐的音乐播放界面的唱片播放器的设计</p><p>garrett 五个用户体验层次 《用户体验要素》</p><h1 id="设计需求分析与方案选择"><a href="#设计需求分析与方案选择" class="headerlink" title="设计需求分析与方案选择"></a>设计需求分析与方案选择</h1><h1 id="规范信息架构与流程设计"><a href="#规范信息架构与流程设计" class="headerlink" title="规范信息架构与流程设计"></a>规范信息架构与流程设计</h1><h1 id="让页面布局更优雅"><a href="#让页面布局更优雅" class="headerlink" title="让页面布局更优雅"></a>让页面布局更优雅</h1><h1 id="交互设计测试与评估"><a href="#交互设计测试与评估" class="headerlink" title="交互设计测试与评估"></a>交互设计测试与评估</h1><h1 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h1><h1 id="B端产品的体验设计方法与实践"><a href="#B端产品的体验设计方法与实践" class="headerlink" title="B端产品的体验设计方法与实践"></a>B端产品的体验设计方法与实践</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h1&gt;&lt;p&gt;框架图，设计流程？&lt;/p&gt;
&lt;p&gt;交互设计要明确产品的任务==需求==和==目标==，通过系统的==规划==，梳理产品==逻辑==关系，做出
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://iloverainbow.top/2018/08/09/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://iloverainbow.top/2018/08/09/Linux常用命令/</id>
    <published>2018-08-09T03:35:09.000Z</published>
    <updated>2018-08-09T03:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><pre><code class="shell">ps -a| grep name# 查看指定程序的进程id#用于显示tcp，udp的端口和进程等相关情况netstat -tunlp# 切换用户su name</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;ps -a| grep name
# 查看指定程序的进程id

#用于显示tcp
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>部署流程</title>
    <link href="https://iloverainbow.top/2018/07/09/%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <id>https://iloverainbow.top/2018/07/09/部署流程/</id>
    <published>2018-07-09T15:39:07.000Z</published>
    <updated>2018-07-09T15:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目写好了。有一台服务器。</p><h1 id="服务器基本配置"><a href="#服务器基本配置" class="headerlink" title="服务器基本配置"></a>服务器基本配置</h1><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code class="shell">ssh username@ip</code></pre><p>这是是root用户，权限太大不安全。</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><pre><code class="shell">新建用户 adduser name 给sudo权限 vim /etc/sudoers在root ALL=(ALL)ALL这一行下增加name ALL=(ALL)ALL</code></pre><h3 id="简化登录"><a href="#简化登录" class="headerlink" title="简化登录"></a>简化登录</h3><p>本机.zshrc文件给命令配置别名</p><pre><code>alias tx=&quot;ssh name@ip&quot;</code></pre><h3 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h3><p>和git仓库配置秘钥原理一样。</p><pre><code>1. 两边都要有生成秘钥ssh-keygen -t rsa -C “email”2. 服务器保存本地公钥echo pubkey &gt;&gt; .ssh/authorized_keys3. 重启服务器sshservice ssh restart</code></pre><h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><pre><code>1. 修改端口文件/etc/ssh/sshd_config port属性,换成其他端口2. 关闭root密码登录PermitRootLogin属性，换成without-password3. 重启ssh4. 还可以配置iptables</code></pre><h3 id="nginx配置端口代理"><a href="#nginx配置端口代理" class="headerlink" title="nginx配置端口代理"></a>nginx配置端口代理</h3><p>在/etc/nginx/nginx.conf中添加</p><pre><code class="sh"># 让nginx加载配置文件include /etc/nginx/conf.d/*.conf;</code></pre><p>然后在/etc/nginx/conf.d文件夹下新建配置文件name-port.conf</p><pre><code class="sh">upstream dappdemo {    server localhost:3000;}server {    listen 80;    server_name 127.0.0.1;    location / {        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;        proxy_set_header Host $http_host;        proxy_set_header X-Nginx-Proxy true;        proxy_pass http://dappdemo;        proxy_redirect off;    }}</code></pre><p>匹配到server_name的流量转发到proxy_pass</p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code>1. 安装dockerwget -qO- https://get.docker.com/ | sh2. 检验docker是否被正确安装sudo docker run hello-world</code></pre><h3 id="从仓库拉取代码"><a href="#从仓库拉取代码" class="headerlink" title="从仓库拉取代码"></a>从仓库拉取代码</h3><ol><li>服务器连接仓库<br><a href="https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="noopener">教程</a></li><li>git clone</li></ol><h3 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h3><p>根据dockerfile新建一个镜像</p><pre><code>docker build -t yourname/imagename:tag .docker build -t benny/dapp:latest .</code></pre><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p>用了Makefile</p><pre><code class="sh">pjName := dappdemodocker:    docker run \        --name ${pjName} \        --rm \        -ti \        -p 3000:3000 \        benny/dapp:0.1 \        /bin/bash</code></pre><pre><code>make docker</code></pre><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>npm run start，使用pm2管理进程</p><pre><code>pm2 start pm2.json==================================={  &quot;apps&quot;: [    {      &quot;name&quot;: &quot;ico-dapp&quot;,      &quot;script&quot;: &quot;./server.js&quot;,      &quot;out_file&quot;: &quot;./logs/out.log&quot;,      &quot;error_file&quot;: &quot;./logs/error.log&quot;,      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;,      &quot;instances&quot;: 0,      &quot;exec_mode&quot;: &quot;cluster&quot;,      &quot;max_memory_restart&quot;: &quot;500M&quot;,      &quot;merge_logs&quot;: true,      &quot;env&quot;: {        &quot;NODE_ENV&quot;: &quot;production&quot;      }    }  ]}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目写好了。有一台服务器。&lt;/p&gt;
&lt;h1 id=&quot;服务器基本配置&quot;&gt;&lt;a href=&quot;#服务器基本配置&quot; class=&quot;headerlink&quot; title=&quot;服务器基本配置&quot;&gt;&lt;/a&gt;服务器基本配置&lt;/h1&gt;&lt;h3 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx笔记</title>
    <link href="https://iloverainbow.top/2018/07/09/Nginx%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/07/09/Nginx笔记/</id>
    <published>2018-07-09T14:44:54.000Z</published>
    <updated>2018-07-09T14:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>nginx是web服务器，性能高，并发性好。</p><p>可以用作代理服务器。</p><p>正向：直接转发</p><p>反向：分发请求</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>nginx -s reload 重新加载</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="这和用程序起一个服务有什么区别呢？"><a href="#这和用程序起一个服务有什么区别呢？" class="headerlink" title="这和用程序起一个服务有什么区别呢？"></a>这和用程序起一个服务有什么区别呢？</h3><p>语言自带类库实现的服务器比较简单。nginx是专业的，更强大。</p><p>为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h3 id="动静态资源分离"><a href="#动静态资源分离" class="headerlink" title="动静态资源分离"></a>动静态资源分离</h3><p>运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p><h1 id="实现打点计数"><a href="#实现打点计数" class="headerlink" title="实现打点计数"></a>实现打点计数</h1><p>用到了服务器功能，和日志功能。</p><p>服务器只返回一个像素的gif图，很高效。</p><p>日志路径为”/usr/local/Cellar/nginx/1.15.0/logs”</p><p>nginx.conf </p><pre><code>server {    location = /report {        empty_gif;    }}</code></pre><h1 id="实现负载均衡和端口代理"><a href="#实现负载均衡和端口代理" class="headerlink" title="实现负载均衡和端口代理"></a>实现负载均衡和端口代理</h1><p>nginx运行在80端口，将请求分发到对应的端口上</p><p>/etc/nginx/conf.d/name-port.conf</p><p>把入口的流量转发到dappdemo</p><pre><code class="sh">upstream dappdemo {    server 127.0.0.1:3000;#    down  表示单前的 server 暂时不参与负载     server 127.0.0.1:8083 down;#   weight  默认为 1 weight 越大，负载的权重就越大。     server 127.0.0.1:8084 weight=3;   #    backup 其它所有的非 backup 机器 down 或者忙的时候，请求 backup机器。所以这台机器压力会最轻    server 127.0.0.1:8002 backup;   }server {    listen 8080;#    匹配的入口    server_name 127.0.0.1;    location / {        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;        proxy_set_header Host $http_host;        proxy_set_header X-Nginx-Proxy true;        proxy_pass http://dappdemo;        proxy_redirect off;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h1&gt;&lt;p&gt;nginx是web服务器，性能高，并发性好。&lt;/p&gt;
&lt;p&gt;可以用作代理服务器。&lt;/p&gt;
&lt;p&gt;正向：直接转发&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>非暴力沟通</title>
    <link href="https://iloverainbow.top/2018/07/03/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
    <id>https://iloverainbow.top/2018/07/03/非暴力沟通/</id>
    <published>2018-07-03T05:10:00.000Z</published>
    <updated>2018-07-03T05:10:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h1><p>沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配</p><p>暴力行为的背后，往往隐藏着人性本恶的价值取向。接受人性本善的价值取向，暴力因素就会远离。</p><h1 id="交流如何变成暴力行为"><a href="#交流如何变成暴力行为" class="headerlink" title="交流如何变成暴力行为"></a>交流如何变成暴力行为</h1><h3 id="道德批判"><a href="#道德批判" class="headerlink" title="道德批判"></a>道德批判</h3><p>用自己的价值观给别人贴标签。这种标签实际上反应了我们的需要和价值观。贴完标签，偏见就产生了，偏见会阻碍交流。</p><h3 id="进行比较"><a href="#进行比较" class="headerlink" title="进行比较"></a>进行比较</h3><p>比较也是一种评判。强迫别人参加一场比赛，然后判他输。</p><h3 id="回避责任"><a href="#回避责任" class="headerlink" title="回避责任"></a>回避责任</h3><p>这是一种表达方式的问题。“不得不做”是一种回避责任的表达方式，需要换成负责任的方式。</p><h3 id="强人所难"><a href="#强人所难" class="headerlink" title="强人所难"></a>强人所难</h3><p>字面意思。对别人的要求往往暗含威胁。</p><h1 id="暴力行为的背后"><a href="#暴力行为的背后" class="headerlink" title="暴力行为的背后"></a>暴力行为的背后</h1><p>行为只是表面原因，问题的根源是对自己和世界的看法。比如优胜劣汰，人性本恶。</p><p>优胜劣汰在社会运作的规则之一，但我们的生活不是。在社会中我们不得不去竞争，比输了很正常，要能够接受。尽人事，听天命，实在是智慧之言。很多情况下，让我懊恼的失败都是没有“尽人事”。</p><p>这个世界好人有很多，坏人也不少，好人可能也做过坏事，坏人大概率也不是彻头彻尾的坏。沟通的时候应该采用“无罪推定”原则，重大利益面前还是“有罪推定”吧。小亏吃了也没啥，大亏万万不能吃。有些场景本来就是暴力的战争，非暴力适用的场景是沟通。</p><h1 id="非暴力沟通要素"><a href="#非暴力沟通要素" class="headerlink" title="非暴力沟通要素"></a>非暴力沟通要素</h1><p>技能是需要练习的，沟通这项技能有四个要素，<strong>观察</strong>、<strong>感受</strong>、<strong>需要</strong>和 <strong>请求</strong>。通过四要素的逻辑来组织语言，语言结构就不再是随意的、任性的甚至是暴力的，而是一种平等的、尊重的语言。</p><p>比如，你给我一份重要文件，中午出去吃饭我把他放在桌子上了，没有收起来。你看见了然后生气的说：“我给你这么重要的文件，你怎么随便扔在桌子上？”</p><p>用非暴力沟通的方式来组织语言就是这样的：</p><ol><li>观察：我看到你把文件放在桌子上</li><li>感受：我郑重交给你的重要文件，你却随意仍在桌子上，我感到失望</li><li>需要：保管好文件，尊重我的嘱咐</li><li>请求：保管好文件</li></ol><p>经过组织后的语言是这样的：我看见刚才交给你的重要文件没有放在桌子上没有收起来(观察)，我担心不安全(感受)，重要的文件应该妥善保管(需要、请求)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;核心观点&quot;&gt;&lt;a href=&quot;#核心观点&quot; class=&quot;headerlink&quot; title=&quot;核心观点&quot;&gt;&lt;/a&gt;核心观点&lt;/h1&gt;&lt;p&gt;沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配&lt;/p&gt;
&lt;p&gt;暴力行为的背后，往往隐藏着
      
    
    </summary>
    
      <category term="读书" scheme="https://iloverainbow.top/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Fabric基础笔记</title>
    <link href="https://iloverainbow.top/2018/07/01/Fabric%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/07/01/Fabric基础笔记/</id>
    <published>2018-07-01T05:20:59.000Z</published>
    <updated>2018-07-01T05:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。</p><p>为了适用于不同的场合，采用模块化架构，提供可切换和可扩展的组件，包括</p><ol><li>共识算法</li><li>加密安全</li><li>数字资产</li><li>记录仓库</li><li>智能合约</li><li>身份鉴权</li></ol><p>Fabric克服了比特币等公有链项目的缺陷，如吞吐量低、无隐私性、无最终确定性以及共识算法低效等，使得用户能够方便地开发商业应用</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>超级账本的一个重要的设计原则是“用例驱动”(use case driven),所有的功能都有对应的用例需求。Farbic主要针对以下几种用例</p><h3 id="金融资产管存"><a href="#金融资产管存" class="headerlink" title="金融资产管存"></a>金融资产管存</h3><p>资产上链后，权益人可以直接访问资产数据，而无需经过传统的中间人，可大幅度提高效率和节约成本。另外资产附加自动执行的业务规则后，可以进一步降低运营成本。</p><p>与公有链应用的较大区别是，金融资产及其相关的交易、业务规则通常是保密的。</p><h3 id="公司行为"><a href="#公司行为" class="headerlink" title="公司行为"></a>公司行为</h3><p>上市公司发起的有关公司证券的事件一般和股东有关，需要股东做适时的回应。事件的完整信息需要及时传递给股东。股东作出决定后，该结果会实时处理货结算。整个过程应保护股东的隐私，确保投资者的决定不受外界影响</p><h3 id="供应链"><a href="#供应链" class="headerlink" title="供应链"></a>供应链</h3><p>在供应链中，所有的参与者都通过区块链记录、追踪和共享各种数据，例如原材料来源、零部件检测结果以及货物的出处等。数据上链，并贯穿货物的生产、运输和销售等环节，从而提供深度回溯查询等核心功能。</p><h3 id="主数据管理"><a href="#主数据管理" class="headerlink" title="主数据管理"></a>主数据管理</h3><p>在很多行业里，不同的组织之间往往共享一些主数据(master data)。例如，不同移动运营商之间，需要共同维护一份发射基站地理位置的数据。<br>通过区块链来保证数据的质量和完整性。</p><h3 id="分享经济"><a href="#分享经济" class="headerlink" title="分享经济"></a>分享经济</h3><p>分享经济是指将闲置或没有被充分利用的实物资源分享出来，有偿供陌生人暂时使用的一种商业模式。最需要解决的是陌生人之间的信任问题，即资源的提供方和资源的租用者，如何在缺乏信任的基础上安全地完成交易。目前的主要手段是通过分享经济平台来确保信任度。区块链将是一种去信任的方式，不使用任何中间平台，便可达到各方参与者可靠交易的目的</p><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric.JPG" alt="farbic架构"></p><h3 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h3><p>权限区块链与公链最大的区别就是具有身份识别能力。参与者都有明确的身份信息，身份服务管理着系统中各种实体、参与者和对象的身份信息。</p><h3 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h3><p>Fabric的许多功能需要用策略(policy)方式驱动,因此有独立的策略服务来提供系统的策略配置和管理功能。包括访问控制、授权、身份的注册、验证、隐私和保密、共识策略等。</p><h3 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h3><p>提供构建分布式账本最基础的能力，实现数据传输、共识达成等底层功能，并且提供发布/订阅的事件管理框架，分布式账本内部的各种事件可通知到外部监听的应用。主要包含四个组件</p><h5 id="P2P协议组件"><a href="#P2P协议组件" class="headerlink" title="P2P协议组件"></a>P2P协议组件</h5><p>主要提供区块链节点之间直接双向通信的能力，包括流式数据传输、流控制、多路复用等方面。</p><h5 id="分布式账本组件"><a href="#分布式账本组件" class="headerlink" title="分布式账本组件"></a>分布式账本组件</h5><p>维护区块链数据。该组件性能直接影响整个网络的吞吐量，因此需要较高的处理效率</p><h5 id="共识管理组件"><a href="#共识管理组件" class="headerlink" title="共识管理组件"></a>共识管理组件</h5><p>在各种公式算法之上定义里抽象的接口，可以根据场景切换公式算法</p><h5 id="账本存储组件"><a href="#账本存储组件" class="headerlink" title="账本存储组件"></a>账本存储组件</h5><p>链外存储大文件</p><h3 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h3><p>为合约代码提供安全的运行环境以及合约的声明周期管理</p><h1 id="网络与部署"><a href="#网络与部署" class="headerlink" title="网络与部署"></a>网络与部署</h1><p>Fabric网络由4类节点组成<br><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric节点"></p><h3 id="身份服务节点"><a href="#身份服务节点" class="headerlink" title="身份服务节点"></a>身份服务节点</h3><p>负责发放和管理用户的身份，具体来说就是在注册、交易、传输过程中使用的各类数字证书，以及区块链相关的秘钥</p><h3 id="验证节点"><a href="#验证节点" class="headerlink" title="验证节点"></a>验证节点</h3><p>创建和校验交易，并且维护智能合约的状态。在执行交易时，一般需要和其他多数的验证节点达成共识(取决于共识算法),然后才能更新本地的账本数据。每个验证节点在本地都保存一份账本的副本。</p><h3 id="非验证节点"><a href="#非验证节点" class="headerlink" title="非验证节点"></a>非验证节点</h3><p>主要是接受客户端的请求，组装交易，并发往验证节点处理，从这个角度看，非验证节点像交易预处理器，并不负责交易的实际执行。为了加速客户端的查询响应速度，非验证节点在本地也保留一份账本数据的拷贝</p><h3 id="应用节点"><a href="#应用节点" class="headerlink" title="应用节点"></a>应用节点</h3><p>主要提供用户端的后台服务，在收到请求后，把交易请求直接发往(或经由非验证节点转发)验证节点处理</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由于节点部署的多样性，应该考虑通信延迟、网络故障、节点失效、网络恢复等因素</p><h1 id="交易的执行"><a href="#交易的执行" class="headerlink" title="交易的执行"></a>交易的执行</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric执行步骤"><br>交易(transaction)分两种:部署智能合约，执行智能合约</p><p>部署步骤：</p><ol><li>客户端通过API提交代码给验证节点</li><li>验证节点确认代码有效</li><li>验证节点同步到其他节点</li></ol><p>执行步骤：</p><ol><li>客户端发送执行请求给验证节点</li><li>验证节点收到请求后，向本地账本发送启动交易的指令</li><li>验证节点创建隔离的运行环境，启动应用(智能合约)代码</li><li>应用执行过程中，更新本地账本的状态</li><li>应用完成后，验证节点想本地账本确认交易</li><li>验证节点向其他验证节点广播交易</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目概述&quot;&gt;&lt;a href=&quot;#项目概述&quot; class=&quot;headerlink&quot; title=&quot;项目概述&quot;&gt;&lt;/a&gt;项目概述&lt;/h1&gt;&lt;p&gt;Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。&lt;/p&gt;
&lt;p&gt;为了适用
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>智能合约基础笔记</title>
    <link href="https://iloverainbow.top/2018/06/30/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/06/30/智能合约基础笔记/</id>
    <published>2018-06-30T09:25:46.000Z</published>
    <updated>2018-06-30T09:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能合约简介"><a href="#智能合约简介" class="headerlink" title="智能合约简介"></a>智能合约简介</h1><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><ol><li>法律角度，智能合约是否是一个真正意义上的合约还有待确认</li><li>计算机科学角度，智能合约是一种计算机协议，一旦制定和部署就能实现自我执行(self-executing)和自我验证(self-verifying)，而且不再需要人为的干预</li><li>技术角度，一种计算机程序，能够自主执行合约相关的操作，并产生相应的可验证的证据，来说明执行合约操作的有效性</li></ol><p>例如，银行账户的存取款可以用合约来替代，以及任何需要记录信息的场合</p><h3 id="智能合约的历史"><a href="#智能合约的历史" class="headerlink" title="智能合约的历史"></a>智能合约的历史</h3><ol><li>20世纪七八十年代，人们提出了让计算机代替人类进行商业市场管理的想法。</li><li>九十年代，研究数字合约和数字货币的Nick Szabo提出了“智能合约”</li><li>08年比特币出现，借由其背后的区块链技术，智能合约飞速发展</li></ol><h5 id="Nick-Szabo对智能合约的定义"><a href="#Nick-Szabo对智能合约的定义" class="headerlink" title="Nick Szabo对智能合约的定义"></a>Nick Szabo对智能合约的定义</h5><p>智能合约是一个由计算机处理的、可执行合约条款的交易协议。其总体目标是能够满足普通的合约条件，例如支付、抵押、保密甚至强制执行，并最小化恶意或意外事件发生的可能性、以及最小化对信任中介的需求。智能合约所要达到的相关经济目标包括降低合约欺诈所造成的损失，降低仲裁和强制执行所产生的成本以及其他交易成本等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高效的实时更新</li><li>准确执行</li><li>较低的认为干预风险</li><li>去中心化权威</li><li>较低的运行成本<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3></li><li>现实中的合同出现漏洞可以协商或者通过法律和仲裁解决，智能合约的漏洞执行后无法修补</li><li>智能合约的自我验证特性导致隐私性低</li></ol><h1 id="以太坊智能合约详解"><a href="#以太坊智能合约详解" class="headerlink" title="以太坊智能合约详解"></a>以太坊智能合约详解</h1><h3 id="合约操作流程"><a href="#合约操作流程" class="headerlink" title="合约操作流程"></a>合约操作流程</h3><ol><li>启动一个节点</li><li>编写合约</li><li>编译</li><li>部署，矿工确认。得到地址与接口</li><li>使用web3.js接口调用合约<h3 id="以太坊上的账户"><a href="#以太坊上的账户" class="headerlink" title="以太坊上的账户"></a>以太坊上的账户</h3>两类账户，公用一个空间地址。</li></ol><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="钥匙文件"><a href="#钥匙文件" class="headerlink" title="钥匙文件"></a>钥匙文件</h5><ol><li>账户通过私钥和公钥确定</li><li>账户地址是公钥的最后20个字节</li><li>账户地址和私钥密文存储在钥匙文件keyfile中</li><li>私钥总是处于加密状态，秘钥是创建账户时输入的密码</li><li>通过秘钥和keyfile中的私钥密文才能得到私钥，进行交易</li><li>要确保备份好keyfile和秘钥<h5 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h5><code>`</code>shell<br>安装客户端<br>brew install ethereum</li></ol><p>创建账户<br>geth account new</p><p>同步区块<br>geth</p><p><code>`</code></p><h5 id="账户的备份"><a href="#账户的备份" class="headerlink" title="账户的备份"></a>账户的备份</h5><p>~/Library/Ethereum/keystore/keyfile<br>这是账户数据，备份好</p><h3 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h3><p>为防止用户恶意部署无限循环运行的合约，合约执行的每一步都需要支付费用，就是gas。</p><ol><li><strong>Gas花销Gascost</strong>：针对具体操作是不变的。保证每种操作所需的计算资源保持不变</li><li><strong>Gas价格Gasprice</strong>：每个gas所需的以太币。由用户控制，价格高的确认快。并且随以太币的市值波动，以保证运行智能合约所需的真实花费不会出现大幅度变化</li><li><strong>Gasfee</strong>：Gascost*Gasprice，真实费用，单位是以太币</li></ol><h3 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h3><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>合约账户有能力向其他合约账户发送消息，它是一个虚拟的对象，不会具体的存储在以太坊的区块链内，可以看做一个函数调用的过程</p><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指外部所有账户将一个经过签名的数据包发送到另一个账户的过程，这个过程中产生的账户状态变化被存储到区块链上</p><p>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h1 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h1><h3 id="Gas的消耗"><a href="#Gas的消耗" class="headerlink" title="Gas的消耗"></a>Gas的消耗</h3><ol><li>最常见的，执行特定的内部抽象操作。例如运行SHA3散列运算</li><li>进行一个从属的消息调用或合约创建时，例如执行CREATE、CALL、CALLCODE操作</li><li>增加账户内存使用量</li></ol><p>内存使用计费机制鼓励用户使用较少的内存。执行账户内存清理操作不消耗GAS，还会得到折扣。</p><h3 id="虚拟机运行环境"><a href="#虚拟机运行环境" class="headerlink" title="虚拟机运行环境"></a>虚拟机运行环境</h3><ol><li>以太坊网络状态</li><li>合约剩余GAS</li><li>当前代码合约地址</li><li>合约发起者地址</li><li>Gasprice</li><li>交易的输入数据</li><li>执行合约交易的账户地址</li><li>合约账户的余额</li><li>用于执行虚拟机代码所需的数组</li><li>目前区块的数据头</li><li>目前执行的CALL操作和CREATE操作的数量</li></ol><h3 id="区块链系统状态的验证"><a href="#区块链系统状态的验证" class="headerlink" title="区块链系统状态的验证"></a>区块链系统状态的验证</h3><p>每产生一个新的有效区块，以太坊系统需要以下几个步骤将该区块加入权威区块链上</p><ol><li>验证新区快的ommer区块的有效性。验证叔区块？</li><li>验证新区快所包含交易的有效性，即所有交易所花费的GAS是否与新区块链中标记的花费量一致，并且每笔交易一一对应</li><li>给该区块和ommer区块的矿工发放奖励</li><li>验证新区快的工作量证明，连接主链，然后将整个系统更新</li></ol><h1 id="智能合约操作"><a href="#智能合约操作" class="headerlink" title="智能合约操作"></a>智能合约操作</h1><h3 id="钱包部署"><a href="#钱包部署" class="headerlink" title="钱包部署"></a>钱包部署</h3><p>Mist或者Eth Wallet</p><h3 id="命令行部署"><a href="#命令行部署" class="headerlink" title="命令行部署"></a>命令行部署</h3><p>通过web3.js的API在命令行部署</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智能合约简介&quot;&gt;&lt;a href=&quot;#智能合约简介&quot; class=&quot;headerlink&quot; title=&quot;智能合约简介&quot;&gt;&lt;/a&gt;智能合约简介&lt;/h1&gt;&lt;h3 id=&quot;什么是智能合约&quot;&gt;&lt;a href=&quot;#什么是智能合约&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Makefile笔记</title>
    <link href="https://iloverainbow.top/2018/06/29/makefile%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/06/29/makefile笔记/</id>
    <published>2018-06-29T13:43:39.000Z</published>
    <updated>2018-06-29T13:44:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据指定的Shell命令进行构建的工具</p><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></p><pre><code class="makefile">pjName := wordpress# 变量docker:    docker run \        --name ${pjName} \# 容器名        --rm \# 停止运行后自动删除当前容器        -ti \# t for terminal,i for interact        -v $$(pwd):/var/www/html \# 映射当前目录到容器指定目录        -p 3000:3000 \# 映射端口到容器端口        mooxe/node \        /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据指定的Shell命令进行构建的工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/02/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifen
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="https://iloverainbow.top/2018/06/29/Docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2018/06/29/Docker笔记/</id>
    <published>2018-06-29T13:42:43.000Z</published>
    <updated>2018-07-09T15:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行</p><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p> 获取image</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p> 创建image</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p> 列出image</p><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p> 运行container，跑一个项目</p><pre><code class="dockerfile">    docker run \        --name ${pjName} \# 容器名        --rm \# 停止运行后自动删除当前容器        -ti \# t for terminal,i for interact        -v $$(pwd):/var/www/html \# 映射当前目录到容器指定目录        -p 3000:3000 \# 映射端口到容器端口        mooxe/node \        /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell</code></pre><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p> 列出container，项目们<br> -a</p><p> 列出隐藏的</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p> 删除container</p><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p> 删除image</p><h2 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h2><p> 在host和container之间拷贝文件</p><h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><p> 保存改动为新的image</p><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>FROM: base image</p><p>RUN: 执行命令</p><p>ADD： 添加文件</p><p>COPY： 拷贝文件</p><p>CMD： 执行命令，打包完成之后</p><p>EXPOSE： 暴露端口</p><p>WORKDIR： 指定路径</p><p>MAINTAINER: 维护者</p><p>ENV: 设定环境变量</p><p>ENTRYPOINT: 容器入口</p><p>USER: 指定用户</p><p>VOLUME: mount point</p><pre><code class="sh"># 可以指定依赖的node镜像的版本 node:&lt;version&gt;，如果不指定，就会是最新的FROM node:8.6.0# 创建工作目录，对应的是应用代码存放在容器内的路径WORKDIR /usr/src/app# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)COPY package.json *.lock .# 只安装dependencies依赖# node镜像自带yarnRUN yarn --only=prod --registry=https://registry.npm.taobao.org# 把其他源文件复制到工作目录COPY . .# 替换成应用实际的端口号EXPOSE ${app_port}# 这里根据实际起动命令做修改CMD [ &quot;npm&quot;, &quot;start&quot; ]</code></pre><pre><code class="shell">touch Dockerfiledocker build -t hello_docker .使用.目录下的dockerfile文件创建一个叫做hello_docker的镜像，</code></pre><h1 id="使用docker步骤"><a href="#使用docker步骤" class="headerlink" title="使用docker步骤"></a>使用docker步骤</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><pre><code>&lt;!-- 拉取镜像 --&gt;docker image pull imagename&lt;!-- 查看镜像 --&gt;docker images</code></pre><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>docker commit将指定容器保存为新的镜像</p><pre><code>docker commit &lt;Container ID&gt; &lt;Name&gt;:&lt;Tag&gt;docker commit fldhsa5342hkjhs bitcoin:0.1</code></pre><p>根据dockerfile创建镜像</p><pre><code>docker build -t imagename .</code></pre><h2 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><pre><code class="sh"># 运行镜像 docker run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash# 删除容器 docker rm [containerID]</code></pre><ul><li>-p参数：容器的 3000 端口映射到本机的 8000 端口。</li><li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链基础知识</title>
    <link href="https://iloverainbow.top/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://iloverainbow.top/2018/06/29/区块链/</id>
    <published>2018-06-29T10:33:53.000Z</published>
    <updated>2018-06-29T10:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链简介"><a href="#区块链简介" class="headerlink" title="区块链简介"></a>区块链简介</h1><p> 去中心化的方式建立信任，不需要大机构的背书。</p><p> 区块链定义：基于区块链技术形成的公共数据库(公共账本)<br> 区块链技术：多个参与方之间基于现代密码学、分布式一致性协议、点对点网络通信技术和智能合约编程语言等形成的数据交换、处理和存储的技术组合。同时，仍在不断发展和演化中。</p><h3 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h3><p>从参与方的角度来分，可以分为公共链、联盟链和私有链。从链与链的关系的角度来分，可以分为主链和侧链。不同区块链还可以形成网络，网络总链与链的互联互通。产生互联链Interchain的概念</p><h5 id="公共链"><a href="#公共链" class="headerlink" title="公共链"></a>公共链</h5><p>对外公开，用户不用注册就能匿名参与。<br>比特币和以太坊都是公链。<br>也叫非许可链Permissionless Blockchain。</p><p>公链适用于虚拟货币、面向大众的电子商务、互联网金融等B2C、C2C或C2B场景</p><h5 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h5><p>联盟链Consortium Blockchain，仅限联盟成员参与。读写权限、参与记账权限按照联盟规则来制定。也叫做许可链Permissioned Blockchain.<br>例如有四十多家银行参与的R3和Linux基金会支持的超级账本Hyperleder。</p><p>联盟链适用于机构间的交易、结算或清算等B2B场景。</p><h5 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h5><p>私有组织使用，区块链上的读写权限、参与记账权限按私有组织股则来制定。应用场景一般是企业内部的应用，如数据库管理、审计。<br>把制度写在区块链上。还有政府的一些应用，比如政府的预算和执行，或者政府的行业统计数据。</p><p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范内部和外部对数据的安全攻击。</p><p>Coin Science的Multichain平台提供一个在企业内部快速部署私链的解决方案。可以用于去中心化交易所、数据库同步、货币结算、债券发行和P2P交易、消费行业积分奖励机制等场景。</p><h5 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h5><p>侧链是能和比特币区块链交互，并与比特币挂钩的区块链。<br>主链不易改动。<br>比特币每秒只能确认7笔交易，通过侧链Side Chains提升效率，扩展比特币功能是一个有效的做法。例如闪电网络把交易放在侧链，只有在做清算时才用上主链。矿工打包少了，回报就少了。</p><h5 id="互联链"><a href="#互联链" class="headerlink" title="互联链"></a>互联链</h5><p>针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种协议连接起来。可以类比互联网</p><h3 id="区块链的价值与应用"><a href="#区块链的价值与应用" class="headerlink" title="区块链的价值与应用"></a>区块链的价值与应用</h3><p>区块链技术是一揽子技术，根据业务需要可以针对性的组合和创新。<br>价值很多，很大，这个需要慢慢理解，放一放，先上手技术。</p><h1 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h5 id="数据区块"><a href="#数据区块" class="headerlink" title="数据区块"></a>数据区块</h5><p>区块结构分为区块头和区块体</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区快加上随机数的哈希值满足一定的难度条件。找到了就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。<br>然后把新节点广播出去。</p><h5 id="挖矿与分叉问题"><a href="#挖矿与分叉问题" class="headerlink" title="挖矿与分叉问题"></a>挖矿与分叉问题</h5><p>穷举随机数算法，把上个区块的哈希值加上十分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数nonce使哈希值满足一定条件就获得这个区块的交易记账权。</p><p>后续矿工总是选择累计工作量证明最大的区块链。结果就是自动抛弃分叉处的短链。</p><h5 id="时间戳与不可篡改性"><a href="#时间戳与不可篡改性" class="headerlink" title="时间戳与不可篡改性"></a>时间戳与不可篡改性</h5><p>时间戳是歌灵位置时间到现在的总秒数，通常是一个字符序列，唯一标识某一刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时间。</p><p>时间戳技术很简单，但意义重大，极大的增强了不可篡改性</p><h5 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h5><p>可以理解为一个分布式数据库</p><h5 id="UTXO交易模式"><a href="#UTXO交易模式" class="headerlink" title="UTXO交易模式"></a>UTXO交易模式</h5><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><h5 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h5><h5 id="双花"><a href="#双花" class="headerlink" title="双花"></a>双花</h5><ol><li>双花如何发生？</li></ol><p>花了一次，还没有上链的时候再花一次</p><ol><li>如何避免</li></ol><p>时间戳+UTXO+数字签名</p><h5 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h5><p>P2P网络是一种在peer(对等者)之间分配任务和工作负载的分布式架构，是对等计算模型在应用层形成的一种组网或网络形式。</p><p>每个节点均承担网络路由，验证数据区块等功能。根据存储数据量分为全节点和轻节点。</p><p>全节点存储了所有区块链数据，数据校验不需要别的节点，硬件成本高。</p><p>轻节点只存储部分，需要别的数据时通过建议支付验证(Simplified Payment Verification, SPV)向临近节点请求数据来完成验证更新</p><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p>非对称加密算法(椭圆曲线加密算法，ECC)</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名就是在信息后加上一段内容，作为发送者的证明并且证明信息没有被篡改</p><p>要传送的信息先经过哈希得到一个值，再用私钥加密得到签名。对信息进行两次操作得到签名。</p><p>接受方通过发送方的公钥解密，然后对信息哈希，然后比对，验证需要三步。</p><p>公钥锁定比特币，私钥解锁，拥有私钥才能使用。</p><h5 id="比特币的隐私模型"><a href="#比特币的隐私模型" class="headerlink" title="比特币的隐私模型"></a>比特币的隐私模型</h5><p>匿名性好一截。进行交易不需要身份信息。</p><h3 id="框架与特点"><a href="#框架与特点" class="headerlink" title="框架与特点"></a>框架与特点</h3><h5 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h5><ol><li>网络层</li></ol><p>两个部分，P2P网络和TCP/IP协议。P2P网络提供了更好的安全性，任何一个节点被攻击都不会影响整个网络</p><ol><li>数据层</li></ol><p>三个部分，公共总账本，共识算法，密码学。在数据层面上，区块链就是一个只能追加、不可更改的分布式数据库系统，是一个分布式账本。通过公式算法保持账本的一致性。通过密码学的签名和哈希算法来确保这个账本不可篡改、不能作为，并且可追溯。</p><p>同时带有经济激励的工作量证明机制，使得即使拥有51%算力的人也不会损害自身利益去发起攻击</p><ol><li>应用层</li></ol><p>三个部分，可编程货币，可编程金融，可编程社会</p><p>区块链平台提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方上。<br>因此，智能合约可以降低合约建立、执行和仲裁中所涉及的中间机构成本。</p><h5 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h5><ol><li>去中心化</li><li>可靠数据库</li><li>开源可编程</li><li>集体维护</li><li>安全可信</li><li>准匿名性<h3 id="区块链运作的核心技术"><a href="#区块链运作的核心技术" class="headerlink" title="区块链运作的核心技术"></a>区块链运作的核心技术</h3><h5 id="区块链的连接"><a href="#区块链的连接" class="headerlink" title="区块链的连接"></a>区块链的连接</h5>区块头中上一区块的哈希值用来实现区块的连接，区块头中的随机数用来实现挖矿机制<h5 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h5>1 PoW<br>工作量证明</li></ol><p>优点： 完全去中心化，节点自由进出</p><p>缺点： 浪费大量资源，挖矿激励机制导致矿池算力集中，不去中心化了。更大的问题是，PoW机制达成共识的周期长，每秒智能作7笔交易，不适合商业应用</p><p>2 PoS</p><p>Proof of Stake，权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。拥有代币越多的节点获得记账权的概率越大。为了平衡会引入其他机制。</p><p>优点： 一定程度上缩短了共识达成的时间，降低了资源浪费</p><p>缺点： 破坏者攻击网络的成本低。拥有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性</p><p>3 DPoS</p><p>股份授权机制，类似于董事会投票。持股人投票选出一定数量的见证人，见证人生成区块。持股人可以随时通过投票更换这些见证人。</p><p>优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证</p><p>缺点： 选举固定数量的见证人作为记账候选人有可能不适用与完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。</p><p>4 分布式一致性算法<br>基于传统的分布式技术。有解决拜占庭将军问题的拜占庭容错算法，如PBFT。还有解决非拜占庭问题的分布式一致性算法(Pasox, Raft)。 目前联盟链和私有链场景中常使用。</p><p>优点： 实现妙计的快速共识机制，保证一致性</p><p>缺点： 去中心化程度不如公链上的共识机制，更适合多方参与的多中心商业模式</p><h5 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h5><p>交易的输出其实是指向一个脚本，而不是地址。它类似一套规则，约束着接收方怎样才能划掉这个输出上锁定的资产。</p><p>交易的合法性也依赖于脚本。锁定脚本和解锁脚本。</p><p>比特币的脚本机制相对简单，不能实现复杂的逻辑。但为后来者们提供了可编程区块链的原型。</p><h5 id="交易规则"><a href="#交易规则" class="headerlink" title="交易规则"></a>交易规则</h5><h5 id="交易优先级"><a href="#交易优先级" class="headerlink" title="交易优先级"></a>交易优先级</h5><h5 id="Merkle证明"><a href="#Merkle证明" class="headerlink" title="Merkle证明"></a>Merkle证明</h5><p>Merkle树的重要使用场景是快速支付验证。轻节点只下载区块头，数据大小为80字节。</p><p>能证明包含的交易，但无法证明任何当前的状态。</p><p>以太坊中有三棵树，分别对应交易transactions，收据recipts和状态State</p><h5 id="RLP"><a href="#RLP" class="headerlink" title="RLP"></a>RLP</h5><p>Recursive Length Prefix，递归长度前缀编码，是以太坊中对象序列化的一个主要编码方式。先放着</p><h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><ol><li>交易的生成：新交易创建</li><li>交易的传播：交易通过P2P网络传播</li><li>工作量证明：交易验证</li><li>整个网络节点验证：3的验证结果在P2P网络中传播</li><li>记录到区块链：交易写入账本</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;区块链简介&quot;&gt;&lt;a href=&quot;#区块链简介&quot; class=&quot;headerlink&quot; title=&quot;区块链简介&quot;&gt;&lt;/a&gt;区块链简介&lt;/h1&gt;&lt;p&gt; 去中心化的方式建立信任，不需要大机构的背书。&lt;/p&gt;
&lt;p&gt; 区块链定义：基于区块链技术形成的公共数据库(公共账本
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>比特币基础知识</title>
    <link href="https://iloverainbow.top/2018/06/29/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>https://iloverainbow.top/2018/06/29/比特币/</id>
    <published>2018-06-29T10:32:34.000Z</published>
    <updated>2018-06-29T10:34:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="比特币特性"><a href="#比特币特性" class="headerlink" title="比特币特性"></a>比特币特性</h3><h5 id="硬通货"><a href="#硬通货" class="headerlink" title="硬通货"></a>硬通货</h5><p>跨境交易</p><h5 id="易携带"><a href="#易携带" class="headerlink" title="易携带"></a>易携带</h5><p>只需一个私钥</p><h5 id="私密性"><a href="#私密性" class="headerlink" title="私密性"></a>私密性</h5><ol><li>只暴露钱包地址</li><li>非法应用</li></ol><h5 id="无货币超发"><a href="#无货币超发" class="headerlink" title="无货币超发"></a>无货币超发</h5><p>通货紧缩</p><ol><li>去中心化，P2P分布式的数字货币系统</li><li>共识机制 - POW工作量证明</li><li>非对称密码学，公钥私钥</li><li>区块链作为账本</li></ol><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h3 id="POW共识机制"><a href="#POW共识机制" class="headerlink" title="POW共识机制"></a>POW共识机制</h3><p>proof of work<br>通过挖矿保证我是个善意的节点，并获得生成区块，和在这个区块里记账的权利</p><h3 id="区块的生成和连接"><a href="#区块的生成和连接" class="headerlink" title="区块的生成和连接"></a>区块的生成和连接</h3><ol><li>比特币由挖矿而产生，通过计算出一个算计数字nonce</li><li>生成的BTC被记录在矿工名下，通过矿工的公钥的哈希值锁定</li><li>交易的输出被称为UTXO，unspent transaction output,未花费交易</li><li>比特币钱包余额就是根据众多UTXO计算出来的</li><li>新区块通过包含前一个区块头部的哈希值建立链接关系。</li><li>区块链有时会产生临时的分叉而生成两条链，最终较短的链将被舍弃</li></ol><h3 id="UTXO的生成和销毁"><a href="#UTXO的生成和销毁" class="headerlink" title="UTXO的生成和销毁"></a>UTXO的生成和销毁</h3><p>交易包含三项，</p><ol><li>交易的输入，UTXO指针</li><li>交易的输出，UTXO</li><li>解锁脚本，私钥签名，公钥</li></ol><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h3 id=&quot;比特币特性&quot;&gt;&lt;a href=&quot;#比特币特性&quot; class=&quot;headerlink&quot; title=&quot;比特币特性&quot;&gt;&lt;/a&gt;比特币特
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链中的密码学技术</title>
    <link href="https://iloverainbow.top/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF/"/>
    <id>https://iloverainbow.top/2018/06/29/区块链中的密码学技术/</id>
    <published>2018-06-29T10:10:10.000Z</published>
    <updated>2018-06-29T10:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认证。</p><p>在比特币系统中，基于寻找给定前缀的SHA256哈希值，设计了工作量证明的共识机制</p><h3 id="哈希算法的性质与应用"><a href="#哈希算法的性质与应用" class="headerlink" title="哈希算法的性质与应用"></a>哈希算法的性质与应用</h3><h5 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h5><p>就是 两个信息具有相同的哈希值是不可能的</p><h5 id="原像不可逆"><a href="#原像不可逆" class="headerlink" title="原像不可逆"></a>原像不可逆</h5><p>不能根据哈希值推导出原值</p><h5 id="难题友好性"><a href="#难题友好性" class="headerlink" title="难题友好性"></a>难题友好性</h5><p>没有便捷的方式去产生一个特定要求的哈希值，只能穷举。</p><h3 id="哈希指针链"><a href="#哈希指针链" class="headerlink" title="哈希指针链"></a>哈希指针链</h3><p>用于验证信息是否发生改变。区块链可以看做一类使用哈希指针的链表。</p><h1 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h1><p>一类基于哈希值的二叉树或多叉树。<br>区块链中的Merkle树是二叉树，用于存储交易信息。</p><p>叶子： 数据块的哈希值</p><p>节点： 孩子节点的哈希值</p><p>用于检测数据副本的一致性，以减少传输的数据量。</p><h1 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h1><h3 id="椭圆曲线密码算法"><a href="#椭圆曲线密码算法" class="headerlink" title="椭圆曲线密码算法"></a>椭圆曲线密码算法</h3><h3 id="secp256k1椭圆曲线"><a href="#secp256k1椭圆曲线" class="headerlink" title="secp256k1椭圆曲线"></a>secp256k1椭圆曲线</h3><h3 id="椭圆曲线签名与验证签名"><a href="#椭圆曲线签名与验证签名" class="headerlink" title="椭圆曲线签名与验证签名"></a>椭圆曲线签名与验证签名</h3><p>先放一放，现在不感兴趣。等需要的时候再来学</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h1&gt;&lt;p&gt;一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>敏捷编码</title>
    <link href="https://iloverainbow.top/2018/06/23/%E6%95%8F%E6%8D%B7%E7%BC%96%E7%A0%81/"/>
    <id>https://iloverainbow.top/2018/06/23/敏捷编码/</id>
    <published>2018-06-23T15:35:05.000Z</published>
    <updated>2018-06-23T15:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《敏捷开发修炼之道》中敏捷编码一章的总结</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行正确的代码编写方式。</p><ol><li>代码要清晰地表达意图</li><li>用代码沟通</li><li>动态评估取舍</li><li>增量式编程</li><li>保持简单</li><li>编写内聚的代码</li><li>告知，不要询问</li><li>根据契约进行替换</li></ol><h1 id="代码要清晰地表达意图"><a href="#代码要清晰地表达意图" class="headerlink" title="代码要清晰地表达意图"></a>代码要清晰地表达意图</h1><p>PIE(Program Intently and Expressively)原则，意图清晰，表达明确</p><ol><li>充分语义化，尽量不看定义也能明白</li><li>使用方法名传达意向，方法参数名帮助读者理解背后的想法</li><li>正确的使用和命名异常</li><li>使用语言特性提升表现力</li><li>好的编码规范可以让代码容易理解，同时减少不必要的注释和文档</li><li>编写清晰而不是讨巧的代码，比如位移操作可读性就不好</li><li>想象一年后的自己来阅读代码，读一次就能明白</li><li>有意图的编程不是创建更多的类或者类型，这不是过分抽象的理由</li><li>使用合适的耦合。例如，通过散列表进行松耦合。散列表存储紧密耦合的组件没有明确的表示意图</li></ol><h1 id="用代码沟通"><a href="#用代码沟通" class="headerlink" title="用代码沟通"></a>用代码沟通</h1><p>读代码的方式：先阅读注释，然后快速浏览代码。从而理解它做了什么，为什么这么做</p><p>建立代码文档有两种方式，利用代码本身以及利用注释来沟通代码之外的事情</p><p>适当的注释和良好的代码能让人快速理解代码。知道代码的意图，结果和需要注意的地方。</p><h3 id="优雅清晰的代码"><a href="#优雅清晰的代码" class="headerlink" title="优雅清晰的代码"></a>优雅清晰的代码</h3><p>优雅的代码易于辨识和理解，简洁，第一眼看上去就知道它的用处</p><ol><li>变量名运用正确</li><li>空格使用得当</li><li>逻辑分离清晰</li><li>表达式简洁</li><li>清晰的执行路径</li></ol><h5 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h5><ol><li>好名字向读者传递大量信息，不好的名字无法传递信息，糟糕的名字传递错误的信息</li><li>遵循习惯用法。比如i表示循环索引量，s表示字符串</li></ol><h3 id="适当的注释"><a href="#适当的注释" class="headerlink" title="适当的注释"></a>适当的注释</h3><ol><li>克制在方法体内部的注释。</li><li>为读者指定一条正确的代码访问路线图</li><li>为代码中的每个类或模块添加一个短小的描述，说明目的以及要求</li><li>对于类中的每个方法，可能要说明四点。目的，输入，输出和异常</li><li>注释不能替代优秀的代码</li><li>在代码可以传递意图的地方不要使用注释</li><li>解释代码做了什么的注释用处不大。注释要说明为什么这样做</li><li>重写方法时，保留描述原有方法意图和约束的注释</li></ol><h1 id="动态评估取舍"><a href="#动态评估取舍" class="headerlink" title="动态评估取舍"></a>动态评估取舍</h1><p><strong>错误观点</strong>：性能、生产力、优雅、成本、以及上市时间，在软件开发过程中都是至关重要的因素，每一项都必须达到最理想状态<br><strong>正确观点</strong>：如果性能表现足够了，就把注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化</p><ul><li>由用户或者利益相关者来评估性能是否足够，界面是否吸引人</li><li>即使不能面面俱到，你也应该得到最重要的东西——客户认为有价值的特性</li><li>如果现在要投入额外的资源和精力是为了将来可能得到的好处，那么要确认投入一定要得到回报</li><li>真正的高性能系统，从一开始设计时就在向这个方向努力</li><li>过早的优化是万恶之源</li></ul><h1 id="增量式编程"><a href="#增量式编程" class="headerlink" title="增量式编程"></a>增量式编程</h1><p><strong>在很短的编辑/构建/测试循环中编写代码</strong>，可以创建更加清晰、简单、易于维护的代码</p><p>采取增量式编程，会更倾向于创建更小的方法和更具内聚性的类</p><ul><li>如果构建和测试花费的时间过长，你就不会经常运行它们了。要保证测试可以快速运行</li><li>在编译和测试中，停下来想一想，并暂时远离代码细节，这是保证不会偏离正确方向的好办法</li><li>要像重构代码一样重构测试，并且经常重构测试</li></ul><h1 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h1><ul><li>不要过度设计</li><li>开发可以工作的、最简单的解决方案。就是没有一行多余代码，并且仍能交付全部功能</li><li>使用模式、原则和高难度技术要有明确的目的</li><li>代码几乎总可以得到进一步精炼，但是到了某个点之后，再做改进就不会带来实质性的好处了。这时就改停下来去做其他的事情了</li><li>强行让代码变得优雅与过早优化一样，会产生恶劣的影响</li><li>简单不是在功能上妥协</li><li>简单不是单纯的代码量少，要兼顾可读性</li><li>一个人认为简单的东西，可能对另一个人意味着复杂</li></ul><h1 id="编写内聚的代码"><a href="#编写内聚的代码" class="headerlink" title="编写内聚的代码"></a>编写内聚的代码</h1><p>内聚性用来评价一个组件中成员的功能相关性。内聚性高说明各成员共同完成了一个或一组功能特性</p><p>好处：</p><ol><li>稳定，维护成本低</li><li>可重用性高</li><li>责任清晰，易跟踪，易修改</li></ol><p>方法：</p><ul><li>在创建一个类的时候，想一下，这个类的功能是否与其他类的功能相似</li><li>让类的功能尽量集中，组件尽量小，避免创建很大的类</li><li>拆分太小也不行。</li></ul><h1 id="告知，不要询问"><a href="#告知，不要询问" class="headerlink" title="告知，不要询问"></a>告知，不要询问</h1><p>作为某段代码的调用者，开发人员绝不应该基于<em>被调用对象的状态</em>来做任何决策，更<em>不能改变该对象的状态</em>，这是被调用对象的责任。在对象之外替他做决策，违反了封装原则，而且为bug提供了土壤。</p><p>这一条我没理解。想象不出场景</p><h1 id="根据契约进行替换"><a href="#根据契约进行替换" class="headerlink" title="根据契约进行替换"></a>根据契约进行替换</h1><p>替换组件代码，其他代码无感知</p><p>通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。委托比继承灵活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为《敏捷开发修炼之道》中敏捷编码一章的总结&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行
      
    
    </summary>
    
      <category term="程序员修养" scheme="https://iloverainbow.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E5%85%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>合作的进化</title>
    <link href="https://iloverainbow.top/2018/06/17/%E5%90%88%E4%BD%9C%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
    <id>https://iloverainbow.top/2018/06/17/合作的进化/</id>
    <published>2018-06-17T12:41:59.000Z</published>
    <updated>2018-06-17T12:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>博弈论经典之作。罗小蔓解读。</p><h1 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h1><p>从个人利益来说，背叛比合作好。从共同利益来说，合作比背叛好。<br>“重复囚徒困境”就是背叛还是合作的选择会进行多次</p><h1 id="一报还一报策略"><a href="#一报还一报策略" class="headerlink" title="一报还一报策略"></a>一报还一报策略</h1><p>一句话总结就是，合作就奖励，背叛就惩罚。</p><p>它有四个优点。</p><ol><li>善良性：在一开始主动释放善意</li><li>报复性：坚持自己的原则，对合作和背叛都给与相应的回报</li><li>宽容性：对给背叛者改正的机会</li><li>清晰性：通过善意与规则清楚地传达合作意愿</li></ol><h1 id="利益"><a href="#利益" class="headerlink" title="利益"></a>利益</h1><p>追逐自身利益是个体的本能，因此想要鼓励合作的产生，最好的办法就是让合作带来的利益大于背叛能够带来的。</p><p>如果想要委婉一些或者降低成本，可以增加合作的步骤，给双方制造更多互相报复的机会，避免一锤子买卖。忌惮于对方的报复，就会更倾向于合作。</p><h1 id="信誉"><a href="#信誉" class="headerlink" title="信誉"></a>信誉</h1><p>信誉不只有诚信度，还包括行事风格，是宽容大度的老好人还是报复心中的小心眼。老好人容易吸引爱占便宜的坏蛋。</p><p>良好的信誉既能吸引好的合作方，也会警告哪些爱占便宜的人与你保持距离</p><h1 id="促进合作的条件"><a href="#促进合作的条件" class="headerlink" title="促进合作的条件"></a>促进合作的条件</h1><ol><li>增加未来对现在的影响，增加基础频率</li><li>提高合作收益，未来收益大于眼前收益的2/3</li><li>塑造信誉，一报还一报</li></ol><h1 id="维持合作的方法"><a href="#维持合作的方法" class="headerlink" title="维持合作的方法"></a>维持合作的方法</h1><ol><li>不要嫉妒</li><li>不刷小聪明</li><li>对合作和背叛都要给与回报</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博弈论经典之作。罗小蔓解读。&lt;/p&gt;
&lt;h1 id=&quot;囚徒困境&quot;&gt;&lt;a href=&quot;#囚徒困境&quot; class=&quot;headerlink&quot; title=&quot;囚徒困境&quot;&gt;&lt;/a&gt;囚徒困境&lt;/h1&gt;&lt;p&gt;从个人利益来说，背叛比合作好。从共同利益来说，合作比背叛好。&lt;br&gt;“重复囚徒困
      
    
    </summary>
    
      <category term="读书" scheme="https://iloverainbow.top/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>iterm快捷键总结</title>
    <link href="https://iloverainbow.top/2018/06/04/iterm/"/>
    <id>https://iloverainbow.top/2018/06/04/iterm/</id>
    <published>2018-06-04T15:38:02.000Z</published>
    <updated>2018-06-14T02:56:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>iterm2的快捷键总结</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>新建tab：⌘ + t</p><p>切换 tab： ⌘+←, ⌘+→</p><p>​ ⌘+{, ⌘+}</p><p>​ ⌘ + Num</p><p>切换全屏：⌘ + enter</p><p>关闭tab：⌘ + w</p><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p><p>切换Tab中的pane：⌘ + [ / ]</p><p>按方向切换 pane：⌘+Option+方向键</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p><p>关闭panel：⌘ + w</p><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p>智能查找，支持正则查找：⌘+f</p><p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p><p>自动填充：⌘ + ； 命令补全提示</p><p>打开最近目录： ⌘ + alt + /</p><p>窗口太多，快速定位到光标所在位置：⌘ + /</p><p>鼠标所在行高亮显示： ⌘ + alt + ；</p><p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p><p>⌘+Shift+h弹出历史记录窗口</p><p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p><p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p><h1 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h1><p>可以拖拽选中的字符串</p><p>可以点击 url：调用默认浏览器访问该网址</p><p>可以点击文件：调用默认程序打开文件</p><p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p><p>点击文件夹：在 finder 中打开该文件夹</p><h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><p>设置标记：⌘ + shift + m</p><p>跳转到上个标记：⌘ + shift + j</p><p>多个标记切换：⌘ + shift + arrow(上下)</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>置空屏幕: clear</p><p>​ ctrl + l</p><p>​ ⌘ + k</p><p>清空屏幕: command + k/r</p><p>字体调大: command + +</p><p>字体调小: command + -</p><p>清除当前行：ctrl + u</p><p>到行首：ctrl + a</p><p>到行尾：ctrl + e</p><p>从光标处删至字首/尾：ctrl + w / k</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iterm2的快捷键总结&lt;/p&gt;
&lt;h1 id=&quot;标签&quot;&gt;&lt;a href=&quot;#标签&quot; class=&quot;headerlink&quot; title=&quot;标签&quot;&gt;&lt;/a&gt;标签&lt;/h1&gt;&lt;p&gt;新建tab：⌘ + t&lt;/p&gt;
&lt;p&gt;切换 tab： ⌘+←, ⌘+→&lt;/p&gt;
&lt;p&gt;​ ⌘+{, 
      
    
    </summary>
    
      <category term="技术" scheme="https://iloverainbow.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链架构</title>
    <link href="https://iloverainbow.top/2018/05/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84/"/>
    <id>https://iloverainbow.top/2018/05/26/区块链架构/</id>
    <published>2018-05-26T14:47:23.000Z</published>
    <updated>2018-06-29T10:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>这里有一段很好的关于架构的讲述，就不完整的抄了</p><p>架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构、组成的组件以及组件之间的关联关系。动态层面主要规范组件的行为以及组件之间的交互协议。根据系统的架构，可以界定系统的功能特性和非功能特性。<br>功能特性是特点，非功能特性是不可缺少的共性部分。</p><p>架构设计要考虑不断变化和恒久不变的两方面。</p><p>一个有长久生命力的系统都有一个设计高明的架构，其精髓在于架构能支持系统功能的变化、发展、演化，允许系统功能不断变化，也就是架构必须提供灵活性。</p><p>而系统对易用性、安全性、稳定性和性能却应该是恒久不变的，因此IT架构的设计必须强调非功能特性，其中</p><ol><li>开放性</li><li>可扩展性</li><li>可移植性</li><li>可维护性</li><li>灵活性</li><li>安全性</li><li>性能(响应时间、吞吐率、并发数)</li></ol><h3 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h3><p> 例如比特币，支撑虚拟货币应用，也就是与转账、汇款和数字化支付相关的密码学货币应用。</p><h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><p> 2.0支撑智能合约应用，合约是经济、市场和金融的区块链应用的基石。2.0应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。</p><h3 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h3><p> 超越货币、金融和市场的范围的去中心化应用，特别是在政府、健康、科学、文化和艺术领域的应用。</p><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="3-0-超越货币，金融范围的区块链应用"><a href="#3-0-超越货币，金融范围的区块链应用" class="headerlink" title="3.0 超越货币，金融范围的区块链应用"></a>3.0 超越货币，金融范围的区块链应用</h1><p>超宇货币和金融范围，特别是政府、健康、科学、工业、文化和艺术的应用<br>支持广义资产、广义交换、支持行业应用。<br>支持行业应用意味着具备企业级属性。其中安全性最突出。同时对网络和共识算法的性能、每秒交易数TPS都有比较高的要求。可以不是完全去中华的架构，最有可能是在不同场景下的混合架构。</p><h3 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h3><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h3><h5 id="自动化采购"><a href="#自动化采购" class="headerlink" title="自动化采购"></a>自动化采购</h5><h5 id="智能化物联网应用"><a href="#智能化物联网应用" class="headerlink" title="智能化物联网应用"></a>智能化物联网应用</h5><h5 id="供应链自动化管理"><a href="#供应链自动化管理" class="headerlink" title="供应链自动化管理"></a>供应链自动化管理</h5><h5 id="虚拟资产兑换、转移"><a href="#虚拟资产兑换、转移" class="headerlink" title="虚拟资产兑换、转移"></a>虚拟资产兑换、转移</h5><h5 id="产权登记"><a href="#产权登记" class="headerlink" title="产权登记"></a>产权登记</h5><h1 id="互联链架构剖析"><a href="#互联链架构剖析" class="headerlink" title="互联链架构剖析"></a>互联链架构剖析</h1><p>不同链的价值转移</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a&gt;基本定义&lt;/h1&gt;&lt;p&gt;这里有一段很好的关于架构的讲述，就不完整的抄了&lt;/p&gt;
&lt;p&gt;架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>共识算法详解</title>
    <link href="https://iloverainbow.top/2018/05/26/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://iloverainbow.top/2018/05/26/共识算法详解/</id>
    <published>2018-05-26T12:14:43.000Z</published>
    <updated>2018-06-29T10:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点</p><p>共识算法的假设条件有以下几种，</p><ol><li>故障模型： 非拜占庭故障/拜占庭故障</li><li>通信模型： 同步/异步</li><li>通信网络连接： 节点间直连数</li><li>信息发送者身份： 实名/匿名</li><li>通信通道稳定性： 通道可靠/不可靠</li><li>消息认证性： 认证消息/非认证消息</li></ol><p>由于应用场景的不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，私有链和联盟链对一致性、正确性要求更高，一般采用强一致性的共识算法。公有链对一致性和正确性通常没法做到百分之百，通常采用最终一致性Eventual Consistency的共识算法。</p><h1 id="拜占庭容错技术"><a href="#拜占庭容错技术" class="headerlink" title="拜占庭容错技术"></a>拜占庭容错技术</h1><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><h3 id="实用的拜占庭容错系统"><a href="#实用的拜占庭容错系统" class="headerlink" title="实用的拜占庭容错系统"></a>实用的拜占庭容错系统</h3><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><h5 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h5><h5 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h5><h5 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h5><h1 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h1><p>一句话解释，根据投入的算力来选择记账节点</p><p>会导致算力浪费</p><p>穷举法找到一个符合要求的哈希值。</p><h3 id="工作量证明函数"><a href="#工作量证明函数" class="headerlink" title="工作量证明函数"></a>工作量证明函数</h3><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h3 id="难度值"><a href="#难度值" class="headerlink" title="难度值"></a>难度值</h3><h3 id="PoW的过程"><a href="#PoW的过程" class="headerlink" title="PoW的过程"></a>PoW的过程</h3><h3 id="基于PoW的共识记账"><a href="#基于PoW的共识记账" class="headerlink" title="基于PoW的共识记账"></a>基于PoW的共识记账</h3><h3 id="关于比特币PoW能否解决拜占庭将军的问题"><a href="#关于比特币PoW能否解决拜占庭将军的问题" class="headerlink" title="关于比特币PoW能否解决拜占庭将军的问题"></a>关于比特币PoW能否解决拜占庭将军的问题</h3><h1 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h1><p>一句话解释，根据拥有的货币数量来算则记账节点</p><p>会导致中心化</p><p>用户证明拥有某些数量的货币(即对货币的权益)</p><h3 id="PoS的应用"><a href="#PoS的应用" class="headerlink" title="PoS的应用"></a>PoS的应用</h3><p>点点币结合币龄</p><h3 id="随机区块选择"><a href="#随机区块选择" class="headerlink" title="随机区块选择"></a>随机区块选择</h3><p>NXT和blackcoin采用随机方法预测下一合法区块，使用公式查找与权益大小结合的最小哈希值</p><h3 id="基于权益速度的选择"><a href="#基于权益速度的选择" class="headerlink" title="基于权益速度的选择"></a>基于权益速度的选择</h3><p>Reddcoin引入权益速度证明，即鼓励钱币的流动而非囤积。通过给币龄引入指数衰减函数，使得币龄不会超过2币月</p><h1 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h1><p>股份授权证明机制 Delegated Proof of Stake,期望通过引入一个技术民主层来减少中心化的负面影响</p><p>持股人投票选出见证人。见证人按序生成区块。</p><h1 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h1><p>基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。</p><p>参与投票节点的身份是事先知道的，因此算法的效率比PoW高，交易的确认只需要几秒钟。<br>这点也决定了它只适合权限链。</p><p>容忍20%的拜占庭错误</p><h3 id="Ripple的网络结构"><a href="#Ripple的网络结构" class="headerlink" title="Ripple的网络结构"></a>Ripple的网络结构</h3><h3 id="Ripple共识算法-1"><a href="#Ripple共识算法-1" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><h1 id="小蚁共识机制"><a href="#小蚁共识机制" class="headerlink" title="小蚁共识机制"></a>小蚁共识机制</h1><p>PoW、PoS、DPoS确定谁有记账权。小蚁侧重于解决如何限制记账人权利的问题。这种记账机制被称为中性记账。记账人只有选择是否参加的权利，而不能改变交易数据，不能认为排除某笔交易，也不能对交易排序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PoW安全性和公平性强一些。PoS和DPoS更环保高效。</p><p>PoW和PoS比较适合公共链环境，PBFT和Raft适合联盟链和私有链的分布式环境。</p><p>比特币的PoW机制是一种概念性的拜占庭协议，能在一定程度上解决拜占庭问题，而PoS等其他机制 并没有严格分析其在拜占庭协议方面的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点&lt;/p&gt;
&lt;p&gt;共识算法的假设条件有以下几种，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;故障模型： 非拜占庭故障/拜占庭故障&lt;/li&gt;
&lt;li&gt;通信模型： 同步/异步&lt;/li&gt;
&lt;li&gt;通信网络连接： 节点间直连数&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>以太坊笔记</title>
    <link href="https://iloverainbow.top/2018/05/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>https://iloverainbow.top/2018/05/25/以太坊/</id>
    <published>2018-05-25T10:12:03.000Z</published>
    <updated>2018-06-29T10:07:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。<br>比特币没有账户的概念，只有UTXO。需要计算。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>智能合约部署在以太坊虚拟机上，通过虚拟机和RPC接口和底层区块链进行交互</p><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="以太坊技术"><a href="#以太坊技术" class="headerlink" title="以太坊技术"></a>以太坊技术</h1><h3 id="以太坊核心概念"><a href="#以太坊核心概念" class="headerlink" title="以太坊核心概念"></a>以太坊核心概念</h3><h5 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h5><p>由许多互联的计算机组成。程序按照EVM定义的方式运行在其上。任何人都可以为所有权、交易格式和状态转换函数创建商业逻辑</p><h5 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h5><p>两类账户，公用一个空间地址。</p><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指存储从外部账户发出的消息的签名数据包。<br>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h5 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h5><p>每笔交易都会被收取一定数量的Gas，其目的是限制交易执行所需要的工作量，同时为交易的执行支付费用。</p><h5 id="存储、主存和栈"><a href="#存储、主存和栈" class="headerlink" title="存储、主存和栈"></a>存储、主存和栈</h5><p>每个账户都有一块永久内存区域，成为存储，key-value形式。存储的读写开销比主存和栈大。合约只能对自己的存储进行读写。</p><p>第二个内存区叫主存，合约执行每次消息调用时都有一块新的被清除过的主存。</p><p>EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈的区域内执行。</p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><p>EVM指令集被可以保持在最小规模，以尽可能的避免可能导致共识问题的而错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作还有条件跳转和无条件跳转。</p><p>此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><h5 id="消息调用"><a href="#消息调用" class="headerlink" title="消息调用"></a>消息调用</h5><p>合约通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，目标，数据负载，以太币，Gas和返回数据。</p><p>事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会一次产生更多的消息调用。</p><h5 id="代码调用和库"><a href="#代码调用和库" class="headerlink" title="代码调用和库"></a>代码调用和库</h5><p>callcode是一种特殊的消息调用。加载来自目标地址的代码将在发起调用的合约上下文中运行。用来实现库。</p><h3 id="以太坊状态转换"><a href="#以太坊状态转换" class="headerlink" title="以太坊状态转换"></a>以太坊状态转换</h3><p>一个交易发生时，从一个状态转换到下一个状态</p><h3 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h3><p>go语言客户端Geth</p><p>客户端浏览器Mist</p><h1 id="以太坊智能合约"><a href="#以太坊智能合约" class="headerlink" title="以太坊智能合约"></a>以太坊智能合约</h1><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>由尼克萨博提出，几乎与互联网同龄。但一直没有可信的执行环境，以太坊首先实现了区块链和智能合约的完整契合。</p><p>以太坊这方面的特性有：</p><ol><li>图灵完备性</li><li>价值意识(value-awareness)</li><li>区块链意识(blockchain-awareness)</li><li>多状态<h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3>以太坊有四种专用语言：</li><li>Serpent(Python)</li><li>Solidity(Js)</li><li>Mutan(Go)</li><li>LLL(Lisp)</li></ol><p>图灵完备，可以解决所有的计算问题。但是半图灵完备，因为通过对计算量设置上限来避免图灵完备语言的无法停机的问题。</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的。可以访问三种存储空间。</p><ol><li>堆栈</li><li>内存，可无限扩展的字节队列</li><li>合约的长期存储，一个秘钥/数值的存储<br>堆栈与内存计算结束就重置，长期存储会保持。<h1 id="以太坊的去中心化应用"><a href="#以太坊的去中心化应用" class="headerlink" title="以太坊的去中心化应用"></a>以太坊的去中心化应用</h1><h3 id="什么是Dapp"><a href="#什么是Dapp" class="headerlink" title="什么是Dapp"></a>什么是Dapp</h3>Dapp由智能合约和客户端代码构成。类似于后端和前端。智能合约跑在区块链上。</li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。&lt;br&gt;比特币没有账户的概念，只有UTXO。需要计算。&lt;/p&gt;
&lt;h1 id=&quot;以太坊架构&quot;&gt;&lt;a href=&quot;#以太坊架构&quot; class=&quot;headerlink&quot; title=&quot;以太坊架构&quot;&gt;&lt;/a&gt;以太坊架构
      
    
    </summary>
    
      <category term="区块链" scheme="https://iloverainbow.top/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>TDD笔记</title>
    <link href="https://iloverainbow.top/2017/12/21/TDD%E7%AC%94%E8%AE%B0/"/>
    <id>https://iloverainbow.top/2017/12/21/TDD笔记/</id>
    <published>2017-12-21T11:22:36.000Z</published>
    <updated>2018-06-29T10:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>graph TD需求提出--&gt;抽象出模型抽象出模型--&gt;转化出测试用例转化出测试用例--&gt;TDD:定义接口测试接口抽象出模型--&gt;|not TDD|codeTDD:定义接口测试接口--&gt;提交PR并讨论提交PR并讨论--&gt;codecode --&gt;整合</code></pre><h2 id="自己写测试的心得"><a href="#自己写测试的心得" class="headerlink" title="自己写测试的心得"></a>自己写测试的心得</h2><p>普通写代码就是直接撸，写成啥是啥，错了就改<br>正确的写测试就是  先想好接口，根据接口来写测试用例，最后再写代码去通过测试<br>这就叫谋而后动</p><p>今天跟了一个测试教程<br>学会了测试语言describe it   before after(mocha)  expect(supettest)</p><h2 id="在egg中写测试"><a href="#在egg中写测试" class="headerlink" title="在egg中写测试"></a>在egg中写测试</h2><p>这是应用的单元测试，不是插件和框架的单元测试</p><p>内置的egg-bin模块，这个模块已经内置了所有测试所需要的好用的模块。<br>包括：Mocha、co-mocha、power-assert，istanbul<br>测试mock辅助模块egg-mock</p><h3 id="第一步，编写测试"><a href="#第一步，编写测试" class="headerlink" title="第一步，编写测试"></a>第一步，编写测试</h3><h4 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h4><h3 id="第二步-配置测试"><a href="#第二步-配置测试" class="headerlink" title="第二步 配置测试"></a>第二步 配置测试</h3><p>在==package.json==中配置==script.test==</p><pre><code class="js">{    &quot;scripts&quot;:{        &quot;test&quot;:&quot;egg-bin test&quot;    }}</code></pre><h3 id="第三步-启动测试"><a href="#第三步-启动测试" class="headerlink" title="第三步 启动测试"></a>第三步 启动测试</h3><pre><code class="js">npm test</code></pre><p><a href="https://zhuanlan.zhihu.com/p/24997923" target="_blank" rel="noopener">打开TDD的正确姿势</a></p><h2 id="TDD是什么"><a href="#TDD是什么" class="headerlink" title="TDD是什么"></a>TDD是什么</h2><p>tested dirven development,测试驱动开发</p><h2 id="TDD的核心"><a href="#TDD的核心" class="headerlink" title="TDD的核心"></a>TDD的核心</h2><p>做好需求分析和设计，将==需求==拆解</p><h2 id="为什么要测试，什么时候测试"><a href="#为什么要测试，什么时候测试" class="headerlink" title="为什么要测试，什么时候测试"></a>为什么要测试，什么时候测试</h2><p>因为错误不可避免，要排除错误减少损失<br>测试越早越好，因为错误绝大部分错误是在早期引入的，发现在中后期<br>错误造成的损失随着时间呈现指数级的增长，越早发现，成本越低。这是软件测试的作用</p><p>测试驱动开发的作用：测试是根据需求来的，测试用例就是各个需求点，只要通过测试，模块的行为就能确保正确。在修改的时候做测试也能确保没有修改出错误。</p><h2 id="测试的概念"><a href="#测试的概念" class="headerlink" title="测试的概念"></a>测试的概念</h2><p><strong>单元测试</strong>：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。就是该部分能否正常工作</p><p> <strong>测试用例</strong>：进行单元测试使用的例子</p><p>单元测试不通过说明要么有bug，要么测试用例不正确</p><p>测试正确说明，对该函数的修改没有对原来的行为造成影响。</p><p>测试驱动，是测试的什么？<br>测试个模块的接口<br>检验是否满足规定的需求，找出与预期的差异</p><h2 id="测试效果的指标"><a href="#测试效果的指标" class="headerlink" title="测试效果的指标"></a>测试效果的指标</h2><p>提高测试覆盖率，测试效率</p><h2 id="测试的误区"><a href="#测试的误区" class="headerlink" title="测试的误区"></a>测试的误区</h2><p>盲目追求覆盖率</p><h2 id="测试的工具"><a href="#测试的工具" class="headerlink" title="测试的工具"></a>测试的工具</h2><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h3><p>mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。</p><p>使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。</p><p>mocha的特点主要有：</p><p>既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一；</p><p>可以自动运行所有测试，也可以只运行特定的测试；</p><p>可以支持before、after、beforeEach和afterEach来编写初始化代码。</p><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>包裹it们</p><p>第一个参数是测试的名字</p><p>第二个参数是一个函数，函数里是it</p><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><p>是各个测试用例</p><p>第一个参数是测试用例的描述</p><p>第二个参数是一个函数，函数体就是测试的内容，assert们</p><h3 id="supertest"><a href="#supertest" class="headerlink" title="supertest"></a>supertest</h3><p>网络测试<br>构造请求，expect断言 判断回复</p><h3 id="node自带断言库-assert"><a href="#node自带断言库-assert" class="headerlink" title="node自带断言库 assert"></a>node自带断言库 assert</h3><h2 id="如何写好测试"><a href="#如何写好测试" class="headerlink" title="如何写好测试"></a>如何写好测试</h2><p>所有人都假设TDD以后软件质量一定提高到最高境界了，但是测试代码也是代码，也有合理不合理的问题，也有价值与维护成本，不好的测试代码会降低效率<br>那么如何写好测试代码呢</p><blockquote><p>测试的核心是“可测试“，可测试意味着好的代码架构，写出可测试代码是优良测试的必要条件。</p></blockquote><blockquote><p>测试驱动开发不是测试人员驱动。<br>这种开发方法完全是开发人员自行实施的，要点在于开发功能之前先开发该功能的测试程序，当然一开始测试程序的结果是失败的，然后去实现功能，让测试结果成功通过<br>测试驱动也不是测试驱动项目运转</p></blockquote><blockquote><p>因为国内大多数程序员写的代码粒度太粗，无法测试。</p></blockquote><p>编写测试的原则是，一次只测一种情况，且测试代码要非常简单。</p><h2 id="TDD和时间的关系"><a href="#TDD和时间的关系" class="headerlink" title="TDD和时间的关系"></a>TDD和时间的关系</h2><blockquote><p>如果时间够，自然可以TDD。如果时间不够，有人可以tdd，测试先行，不代表真的要先写测试。tdd像一种工具或者流程，其背后有它自己的思维，掌握了思维，没有按流程出招，或许就表示tdd已死了吧。如果楼主是指形式或者招式，那么其在某些情况下还是继续存活的。比如时间足够，而程序员足够热爱它</p></blockquote><blockquote><p>TDD只是一个概念，时间允许的话每个重要的方法业务都写单元测试，涉及正确性测试，边界测试，错误测试等等。之后代码有改动再跑单元测试就可以了。这样开发会节省挺多时间。</p></blockquote><p>和时间的关系，写测试要消耗时间<br>这是一个问题，很多公司的迭代周期比较短，比如半个月。那么如何搞TDD呢</p><h2 id="TDD的好处"><a href="#TDD的好处" class="headerlink" title="TDD的好处"></a>TDD的好处</h2><blockquote><p>TDD好处其实很简单：</p><ol><li>帮你整理需求</li><li>帮你设计接口（空想的话很容易设计出屎）</li><li>帮你做regression和给以后重构做准备</li></ol></blockquote><p>提高程序健壮性</p><blockquote><p>TDD会鼓励你对现有代码，更频繁，更敏捷地进行改变<br>它带给你的是，更少的regression，更少的debuggingtime，以及更多的勇气来refactor</p></blockquote><blockquote><p>是tdd重新让我编程的信心和乐趣。<br>我不爱用眼睛看检查运行结果，只要改动之后，一运行看到一长排的勾我就去冲杯香飘飘喝吧喝吧，喝了睡觉去了</p></blockquote><hr><blockquote><p>过度测试是存在。但一些看似过度的testmethod确实揪出了bug。国内中小公司(没去过大公司，不知道啥情况)从上到下对测试总是抗拒的态度。他们会迷惑如何在需求变更中控制缺陷，却不愿试着作任何改变。整天鼓吹熬夜搬砖的人是没法沟通的:(。所以总是测试不够，而非过度</p></blockquote><p>要会单元测试，没有deadline的威胁，就是时间要足够<br>适合思路发散常常迷糊的人，让人有安全感，能确定想法落实了<br>可以灵活一些，比较高层的feature在确保接口可测试的前提下，没必要完全tdd。</p><blockquote><p>TDD是否已死先不说，很多程序员连写出基本的整洁代码都做不到，还能指望他先写测试吗？写代码绝对是个技术活，而不是体力活。所以，写代码需要不断修炼，比如code dojo, code kata 至于是否用TDD方式写代码，倒不一定。如果程序员的思维转变，写代码之前先考虑到测试用例、测试场景，也是一个很大的转变，即测试先行。</p></blockquote><blockquote><p>我觉得TDD不火的原因是它对developer的素质要求非常高。新手看到TDD会欢欣鼓舞，但是他们没有能力来实践。老手们在项目的压力下，早就麻木了，先写case还不如写好代码再补case呢，很多东西我还没时间想清楚，怎么写case？不如先写个小功能先，边写边改，等稳定下来再补case. 所以对老手来说也需要不断练习，才能熟悉TDD.</p></blockquote><blockquote><p>其实我们的目的是为了快速的交付有价值，有质量的产品或者服务，赢得公司的生存和发展空间。为了达到这个目的，我们有很多种的手段。但手段不是目的。<br>有很多盲目推崇TDD的所谓敏捷专家，其实是把手段当做目的，而忽略了问题的本质</p></blockquote><blockquote><p>首先理清一个价值观问题，是方法论为生产力服务还是生产力为方法论服务<br>TDD的错误在于，他没有尊重程序员尊重开发实际，让非生产代码通知生产代码</p></blockquote><blockquote><p>TDD 力量和问题都源自 test first。要能 test first，写代码之前要想得更清楚；代码得要有良好的可测试性，而为了可测试性要做一些不直接产生效益的工作；两者都既能推动思考，也能限制思考。TDD 是正确的思想：程序员要保证代码的正确性，和不完美的实践：程序员写测试。</p></blockquote><blockquote><p>目前我们团队也在想办法推行TDD，但是不是标准的TDD，而仅仅是测试先行，并且不用mock这样做可以在实现业务代码之前对于自己的程序要实现什么有一个清晰的认识，而且写程序的过程也变成了“跑通我的单元测试”的过程，这样更加有目标和针对性，当你看到你写完的业务代码能跑通单元测试的时候，是否有种游戏过关的成就感呢？等到全员都逐渐适应这种测试先行的做法，再“得寸进尺”，多要求一点点。</p></blockquote><blockquote><p>测试先行，怎么和开发做交互呢？什么时间调用开发的方法？<br>测试先行是说在实现业务逻辑前先写完单元测试，此时的单元测试肯定不通，之后再逐渐针对测试完善业务代码，最后跑通测试的时候业务代码也就完成了。不是让测试人员先测的意思</p></blockquote><blockquote><p>TDD解决了：1）我要开始写代码了，我从哪开始。 搞个main，还是搞个test2）我不知道那个家伙的代码写的怎么样，以后会不会捅个篓子，要求他TDD好了。CodeReview的时候也轻松点。飞机上写几个小时代码，下来编译一遍过还没有bug的人。你跳出来说，他没有tdd，他LowB，那你是不是有毛病。总之一句话，各种方法论都是解决一个问题——人不行。</p></blockquote><blockquote><p>软件开发说到底还是抽象和逻辑的艺术，TDD只是一种辅助开发手段，并不会减少因为开发人员素质不过硬或者工期短赶工而在开发过程中产生的抽象和逻辑问题。从来没听说过历史上哪位编程高手是因为什么方法论而练成的，人家是数据结构、算法、抽象和逻辑能力真的强大。对了，除了TDD，那什么敏捷、XP、结对、DDD等等，所有抛开实际抽象和逻辑问题的方法论，都是垃圾。</p></blockquote><p>更重要的是  基础的是  数据结构算法  抽象  逻辑能力</p><blockquote><p>TDD在什么情况下最有效？</p><ol><li>一个老系统，</li><li>老系统有还不错的test case</li><li>有很多相关系统依赖老系统</li><li>老系统要推翻重做</li></ol></blockquote><blockquote><p>先阐明观点，TDD没死，只是存活着在一些技术及配合要求比较高的团队，并且是挑业务的。我在互联网行业摸打滚爬了蛮久，历经各种项目，包括PC、游戏、云存储、电商等项目，TDD也是我这几年年一直在推动的事情，大部分失败了，也有些收获，这里大致把所了解以及个人见解说下。拿我所熟悉的互联网行业来说吧，其他传统软件行业经历时间太早，离当前较远，就不乱说了。现在互联网大都流行敏捷开发，其模式大家可自行度娘，但是真正做到的貌似没有，最少我没见过或者听过，很难用定性的词语来形容（语文不好），用个相似度来说吧，当前BAT公司排序为BTA（还是个人见解），用我个人的说法就是作坊式开发，忽略很多流程，只留下骨干的评审、开发、用例评审、转测、回归发布的流程。这个模式特点就是快，从需求提出到发布上线，一般都是一两周的时间，现有三周才能开发完成的业务。当然这里也有提出异议，说我太片面了，不过我说的大部分的互联网公司业务，保守估计60%的比例吧。解释完了互联网公司的开发模式，接下来我们回到TDD，至于TDD的概念，我就不科普了，自行度娘。其中TDD有一个特点非常明确，基本上可以作为是否做到的标签。这就是测试架构先于开发完成，并可对开发完成大部分模块进行测试（个人的理解，标准定义自行百度）。为了达到这个目的，我们搬出几个要素出来：时间、人、效果、方式。时间：什么时候完成，项目时间大约多久可以做TDD，TDD占项目时间大约多少比例合适。人：谁来做，一个人的项目我这里不谈，只谈多人协作项目，开发做还是测试来做？效果：要达成什么效果，以什么为合格的TDD的指标，功能覆盖？代码覆盖率？方式：要怎么做，开发一套自动化框架，还是用先协商接口用单测来完成，这里特别要提出的是，需要考虑后期维护的代价。</p></blockquote><blockquote><p>TDD 推行的最大问题在于，大多数程序员还不会「写测试用例」和「重构」。<br>我认为推行TDD主要在两个方面努力，即意识和能力（好像任何事情都是这两方面哈）。意识方面主要是：认识到自己原有编程方法的不足；搞清楚TDD的价值所在，如何弥补原有方法的不足；心态开放，勇于尝试新鲜事物，不要浅尝辄止，要持续改进。意识和能力没有先后关系，而是在不断学习和实践过程中同时提高。在这篇文章中，我更想谈的是能力。我见到初接触TDD的人常犯下面的错误：在声明测试方法后，便开始写实现代码；写完“所有”的测试代码才开始写实现；一次实现过多的代码（超出当前测试覆盖的业务）；从不重构；测试实现细节而不是接口行为；TDD真是看起来容易，做起来难。</p></blockquote><pre><code>graph LRRed--&gt;GreenGreen--&gt;RefactorRefactor--&gt;Red</code></pre><blockquote><p>上面这个图一目了然，但其实每一步都是对能力有要求的：红测试先行并不是说不需要思考，直接开始写代码。在开始写代码之前要进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断循环去实现。测试代码其实是产品代码的“用户”，在写测试代码时你就要考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实我们就是在做设计，而且设计以代码来体现，比在脑袋中空想要更直观。很多人不懂“意图式编程”，总是习惯先实现一个东西，再去调用它。而测试先行就要求先使用，再实现。这样能少走很多弯路，减少返工。无法把测试前置的原因往往在于，测试的是「实现」，也就是你写的是「白盒」测试。这样的测试根本没有价值，重构的时候会成为维护负担。而好的做法是测试「做什么」，而不是「怎么做」。绿以最快的速度让测试变绿，意味着我们通常用最直接但可能并不优雅的方式，比如复制代码。然后小步重构，直到符合简单设计的原则：通过所有测试每个概念都被清楚地表达没有重复没有多余的东西难的是要让实现刚好满足当前的测试，不做过度的设计，不写多余的代码。因为如果你写多了，除了引入复杂性以外，多的那部分就没有测试能覆盖到。或者你后面的测试写出来就能直接变绿，你就没办法按TDD的节奏进行下去了。重构首先要能识别坏味道，一些低级的Smell，很容易识别，比如：Magic Number，重复代码，太大的类，太长的方法，命名等。但更高级的如Feature Envy，Lazy Class等就比较难以识别。只要识别到Smell，知道用什么手法去重构，剩下的就比较简单了，现代的IDE，尤其是JetBrains的产品，对重构的支持非常强大，几乎都可以用快捷键完成。选对工具非常重要，善假于物能极大提高开发效率。但也不能过分依赖工具，要明白每一个手法背后的原理。所以推荐每个想要实践TDD的开发者，一定要先读《重构》。最后我想说：TDD不是银弹，不可能适合所有的场景，但这不应该成为我们拒绝它的理由。也不要轻易否定TDD，如果要否定，起码要在认真实践过之后。</p></blockquote><h1 id="TDD教程"><a href="#TDD教程" class="headerlink" title="TDD教程"></a>TDD教程</h1><p>总览</p><p>TDD的理解和讲解</p><p>基线描述</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态<br>掌握mock技巧，能够讲出几种mock的场景<br>了解SetUp的作用<br>会写TestCase<br>给出题目可以驱动着写出来<br>细节如下：</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态</p><p>正确的TDD的步骤至少包含下面的几个点，写一个TestCase，运行，得到期望的失败，写实现，重构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;graph TD
需求提出--&amp;gt;抽象出模型
抽象出模型--&amp;gt;转化出测试用例
转化出测试用例--&amp;gt;TDD:定义接口测试接口
抽象出模型--&amp;gt;|not TDD|code
TDD:定义接口测试接口--&amp;gt;提交PR并讨论
提交PR并讨论-
      
    
    </summary>
    
      <category term="程序员修养" scheme="https://iloverainbow.top/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E5%85%BB/"/>
    
    
  </entry>
  
</feed>
