<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>合作的进化</title>
      <link href="/2018/06/17/%E5%90%88%E4%BD%9C%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
      <url>/2018/06/17/%E5%90%88%E4%BD%9C%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>博弈论经典之作。罗小蔓解读。</p><h1 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h1><p>从个人利益来说，背叛比合作好。从共同利益来说，合作比背叛好。<br>“重复囚徒困境”就是背叛还是合作的选择会进行多次</p><h1 id="一报还一报策略"><a href="#一报还一报策略" class="headerlink" title="一报还一报策略"></a>一报还一报策略</h1><p>一句话总结就是，合作就奖励，背叛就惩罚。</p><p>它有四个优点。</p><ol><li>善良性：在一开始主动释放善意</li><li>报复性：坚持自己的原则，对合作和背叛都给与相应的回报</li><li>宽容性：对给背叛者改正的机会</li><li>清晰性：通过善意与规则清楚地传达合作意愿</li></ol><h1 id="利益"><a href="#利益" class="headerlink" title="利益"></a>利益</h1><p>追逐自身利益是个体的本能，因此想要鼓励合作的产生，最好的办法就是让合作带来的利益大于背叛能够带来的。</p><p>如果想要委婉一些或者降低成本，可以增加合作的步骤，给双方制造更多互相报复的机会，避免一锤子买卖。忌惮于对方的报复，就会更倾向于合作。</p><h1 id="信誉"><a href="#信誉" class="headerlink" title="信誉"></a>信誉</h1><p>信誉不只有诚信度，还包括行事风格，是宽容大度的老好人还是报复心中的小心眼。老好人容易吸引爱占便宜的坏蛋。</p><p>良好的信誉既能吸引好的合作方，也会警告哪些爱占便宜的人与你保持距离</p><h1 id="促进合作的条件"><a href="#促进合作的条件" class="headerlink" title="促进合作的条件"></a>促进合作的条件</h1><ol><li>增加未来对现在的影响，增加基础频率</li><li>提高合作收益，未来收益大于眼前收益的2/3</li><li>塑造信誉，一报还一报</li></ol><h1 id="维持合作的方法"><a href="#维持合作的方法" class="headerlink" title="维持合作的方法"></a>维持合作的方法</h1><ol><li>不要嫉妒</li><li>不刷小聪明</li><li>对合作和背叛都要给与回报</li></ol>]]></content>
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iterm快捷键总结</title>
      <link href="/2018/06/04/iterm/"/>
      <url>/2018/06/04/iterm/</url>
      <content type="html"><![CDATA[<p>iterm2的快捷键总结</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>新建tab：⌘ + t</p><p>切换 tab： ⌘+←, ⌘+→</p><p>​ ⌘+{, ⌘+}</p><p>​ ⌘ + Num</p><p>切换全屏：⌘ + enter</p><p>关闭tab：⌘ + w</p><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p><p>切换Tab中的pane：⌘ + [ / ]</p><p>按方向切换 pane：⌘+Option+方向键</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p><p>关闭panel：⌘ + w</p><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p>智能查找，支持正则查找：⌘+f</p><p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p><p>自动填充：⌘ + ； 命令补全提示</p><p>打开最近目录： ⌘ + alt + /</p><p>窗口太多，快速定位到光标所在位置：⌘ + /</p><p>鼠标所在行高亮显示： ⌘ + alt + ；</p><p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p><p>⌘+Shift+h弹出历史记录窗口</p><p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p><p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p><h1 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h1><p>可以拖拽选中的字符串</p><p>可以点击 url：调用默认浏览器访问该网址</p><p>可以点击文件：调用默认程序打开文件</p><p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p><p>点击文件夹：在 finder 中打开该文件夹</p><h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><p>设置标记：⌘ + shift + m</p><p>跳转到上个标记：⌘ + shift + j</p><p>多个标记切换：⌘ + shift + arrow(上下)</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>置空屏幕: clear</p><p>​ ctrl + l</p><p>​ ⌘ + k</p><p>清空屏幕: command + k/r</p><p>字体调大: command + +</p><p>字体调小: command + -</p><p>清除当前行：ctrl + u</p><p>到行首：ctrl + a</p><p>到行尾：ctrl + e</p><p>从光标处删至字首/尾：ctrl + w / k</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区块链架构</title>
      <link href="/2018/05/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/05/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>这里有一段很好的关于架构的讲述，就不完整的抄了</p><p>架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构、组成的组件以及组件之间的关联关系。动态层面主要规范组件的行为以及组件之间的交互协议。根据系统的架构，可以界定系统的功能特性和非功能特性。<br>功能特性是特点，非功能特性是不可缺少的共性部分。</p><p>架构设计要考虑不断变化和恒久不变的两方面。</p><p>一个有长久生命力的系统都有一个设计高明的架构，其精髓在于架构能支持系统功能的变化、发展、演化，允许系统功能不断变化，也就是架构必须提供灵活性。</p><p>而系统对易用性、安全性、稳定性和性能却应该是恒久不变的，因此IT架构的设计必须强调非功能特性，其中</p><ol><li>开放性</li><li>可扩展性</li><li>可移植性</li><li>可维护性</li><li>灵活性</li><li>安全性</li><li>性能(响应时间、吞吐率、并发数)</li></ol><h3 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h3><p> 例如比特币，支撑虚拟货币应用，也就是与转账、汇款和数字化支付相关的密码学货币应用。</p><h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><p> 2.0支撑智能合约应用，合约是经济、市场和金融的区块链应用的基石。2.0应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。</p><h3 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h3><p> 超越货币、金融和市场的范围的去中心化应用，特别是在政府、健康、科学、文化和艺术领域的应用。</p><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="3-0-超越货币，金融范围的区块链应用"><a href="#3-0-超越货币，金融范围的区块链应用" class="headerlink" title="3.0 超越货币，金融范围的区块链应用"></a>3.0 超越货币，金融范围的区块链应用</h1><p>超宇货币和金融范围，特别是政府、健康、科学、工业、文化和艺术的应用<br>支持广义资产、广义交换、支持行业应用。<br>支持行业应用意味着具备企业级属性。其中安全性最突出。同时对网络和共识算法的性能、每秒交易数TPS都有比较高的要求。可以不是完全去中华的架构，最有可能是在不同场景下的混合架构。</p><h3 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h3><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h3><h5 id="自动化采购"><a href="#自动化采购" class="headerlink" title="自动化采购"></a>自动化采购</h5><h5 id="智能化物联网应用"><a href="#智能化物联网应用" class="headerlink" title="智能化物联网应用"></a>智能化物联网应用</h5><h5 id="供应链自动化管理"><a href="#供应链自动化管理" class="headerlink" title="供应链自动化管理"></a>供应链自动化管理</h5><h5 id="虚拟资产兑换、转移"><a href="#虚拟资产兑换、转移" class="headerlink" title="虚拟资产兑换、转移"></a>虚拟资产兑换、转移</h5><h5 id="产权登记"><a href="#产权登记" class="headerlink" title="产权登记"></a>产权登记</h5><h1 id="互联链架构剖析"><a href="#互联链架构剖析" class="headerlink" title="互联链架构剖析"></a>互联链架构剖析</h1><p>不同链的价值转移</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>共识算法详解</title>
      <link href="/2018/05/26/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/26/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点</p><p>共识算法的假设条件有以下几种，</p><ol><li>故障模型： 非拜占庭故障/拜占庭故障</li><li>通信模型： 同步/异步</li><li>通信网络连接： 节点间直连数</li><li>信息发送者身份： 实名/匿名</li><li>通信通道稳定性： 通道可靠/不可靠</li><li>消息认证性： 认证消息/非认证消息</li></ol><p>由于应用场景的不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，私有链和联盟链对一致性、正确性要求更高，一般采用强一致性的共识算法。公有链对一致性和正确性通常没法做到百分之百，通常采用最终一致性Eventual Consistency的共识算法。</p><h1 id="拜占庭容错技术"><a href="#拜占庭容错技术" class="headerlink" title="拜占庭容错技术"></a>拜占庭容错技术</h1><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><h3 id="实用的拜占庭容错系统"><a href="#实用的拜占庭容错系统" class="headerlink" title="实用的拜占庭容错系统"></a>实用的拜占庭容错系统</h3><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><h5 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h5><h5 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h5><h5 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h5><h1 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h1><p>一句话解释，根据投入的算力来选择记账节点</p><p>会导致算力浪费</p><p>穷举法找到一个符合要求的哈希值。</p><h3 id="工作量证明函数"><a href="#工作量证明函数" class="headerlink" title="工作量证明函数"></a>工作量证明函数</h3><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h3 id="难度值"><a href="#难度值" class="headerlink" title="难度值"></a>难度值</h3><h3 id="PoW的过程"><a href="#PoW的过程" class="headerlink" title="PoW的过程"></a>PoW的过程</h3><h3 id="基于PoW的共识记账"><a href="#基于PoW的共识记账" class="headerlink" title="基于PoW的共识记账"></a>基于PoW的共识记账</h3><h3 id="关于比特币PoW能否解决拜占庭将军的问题"><a href="#关于比特币PoW能否解决拜占庭将军的问题" class="headerlink" title="关于比特币PoW能否解决拜占庭将军的问题"></a>关于比特币PoW能否解决拜占庭将军的问题</h3><h1 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h1><p>一句话解释，根据拥有的货币数量来算则记账节点</p><p>会导致中心化</p><p>用户证明拥有某些数量的货币(即对货币的权益)</p><h3 id="PoS的应用"><a href="#PoS的应用" class="headerlink" title="PoS的应用"></a>PoS的应用</h3><p>点点币结合币龄</p><h3 id="随机区块选择"><a href="#随机区块选择" class="headerlink" title="随机区块选择"></a>随机区块选择</h3><p>NXT和blackcoin采用随机方法预测下一合法区块，使用公式查找与权益大小结合的最小哈希值</p><h3 id="基于权益速度的选择"><a href="#基于权益速度的选择" class="headerlink" title="基于权益速度的选择"></a>基于权益速度的选择</h3><p>Reddcoin引入权益速度证明，即鼓励钱币的流动而非囤积。通过给币龄引入指数衰减函数，使得币龄不会超过2币月</p><h1 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h1><p>股份授权证明机制 Delegated Proof of Stake,期望通过引入一个技术民主层来减少中心化的负面影响</p><p>持股人投票选出见证人。见证人按序生成区块。</p><h1 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h1><p>基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。</p><p>参与投票节点的身份是事先知道的，因此算法的效率比PoW高，交易的确认只需要几秒钟。<br>这点也决定了它只适合权限链。</p><p>容忍20%的拜占庭错误</p><h3 id="Ripple的网络结构"><a href="#Ripple的网络结构" class="headerlink" title="Ripple的网络结构"></a>Ripple的网络结构</h3><h3 id="Ripple共识算法-1"><a href="#Ripple共识算法-1" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><h1 id="小蚁共识机制"><a href="#小蚁共识机制" class="headerlink" title="小蚁共识机制"></a>小蚁共识机制</h1><p>PoW、PoS、DPoS确定谁有记账权。小蚁侧重于解决如何限制记账人权利的问题。这种记账机制被称为中性记账。记账人只有选择是否参加的权利，而不能改变交易数据，不能认为排除某笔交易，也不能对交易排序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PoW安全性和公平性强一些。PoS和DPoS更环保高效。</p><p>PoW和PoS比较适合公共链环境，PBFT和Raft适合联盟链和私有链的分布式环境。</p><p>比特币的PoW机制是一种概念性的拜占庭协议，能在一定程度上解决拜占庭问题，而PoS等其他机制 并没有严格分析其在拜占庭协议方面的属性。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>以太坊笔记</title>
      <link href="/2018/05/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
      <url>/2018/05/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</url>
      <content type="html"><![CDATA[<p>以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。<br>比特币没有账户的概念，只有UTXO。需要计算。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>智能合约部署在以太坊虚拟机上，通过虚拟机和RPC接口和底层区块链进行交互</p><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="以太坊技术"><a href="#以太坊技术" class="headerlink" title="以太坊技术"></a>以太坊技术</h1><h3 id="以太坊核心概念"><a href="#以太坊核心概念" class="headerlink" title="以太坊核心概念"></a>以太坊核心概念</h3><h5 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h5><p>由许多互联的计算机组成。程序按照EVM定义的方式运行在其上。任何人都可以为所有权、交易格式和状态转换函数创建商业逻辑</p><h5 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h5><p>两类账户，公用一个空间地址。</p><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指存储从外部账户发出的消息的签名数据包。<br>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h5 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h5><p>每笔交易都会被收取一定数量的Gas，其目的是限制交易执行所需要的工作量，同时为交易的执行支付费用。</p><h5 id="存储、主存和栈"><a href="#存储、主存和栈" class="headerlink" title="存储、主存和栈"></a>存储、主存和栈</h5><p>每个账户都有一块永久内存区域，成为存储，key-value形式。存储的读写开销比主存和栈大。合约只能对自己的存储进行读写。</p><p>第二个内存区叫主存，合约执行每次消息调用时都有一块新的被清除过的主存。</p><p>EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈的区域内执行。</p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><p>EVM指令集被可以保持在最小规模，以尽可能的避免可能导致共识问题的而错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作还有条件跳转和无条件跳转。</p><p>此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><h5 id="消息调用"><a href="#消息调用" class="headerlink" title="消息调用"></a>消息调用</h5><p>合约通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，目标，数据负载，以太币，Gas和返回数据。</p><p>事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会一次产生更多的消息调用。</p><h5 id="代码调用和库"><a href="#代码调用和库" class="headerlink" title="代码调用和库"></a>代码调用和库</h5><p>callcode是一种特殊的消息调用。加载来自目标地址的代码将在发起调用的合约上下文中运行。用来实现库。</p><h3 id="以太坊状态转换"><a href="#以太坊状态转换" class="headerlink" title="以太坊状态转换"></a>以太坊状态转换</h3><p>一个交易发生时，从一个状态转换到下一个状态</p><h3 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h3><p>go语言客户端Geth</p><p>客户端浏览器Mist</p><h1 id="以太坊智能合约"><a href="#以太坊智能合约" class="headerlink" title="以太坊智能合约"></a>以太坊智能合约</h1><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>由尼克萨博提出，几乎与互联网同龄。但一直没有可信的执行环境，以太坊首先实现了区块链和智能合约的完整契合。</p><p>以太坊这方面的特性有：</p><ol><li>图灵完备性</li><li>价值意识(value-awareness)</li><li>区块链意识(blockchain-awareness)</li><li>多状态<h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3>以太坊有四种专用语言：</li><li>Serpent(Python)</li><li>Solidity(Js)</li><li>Mutan(Go)</li><li>LLL(Lisp)</li></ol><p>图灵完备，可以解决所有的计算问题。但是半图灵完备，因为通过对计算量设置上限来避免图灵完备语言的无法停机的问题。</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的。可以访问三种存储空间。</p><ol><li>堆栈</li><li>内存，可无限扩展的字节队列</li><li>合约的长期存储，一个秘钥/数值的存储<br>堆栈与内存计算结束就重置，长期存储会保持。<h1 id="以太坊的去中心化应用"><a href="#以太坊的去中心化应用" class="headerlink" title="以太坊的去中心化应用"></a>以太坊的去中心化应用</h1><h3 id="什么是Dapp"><a href="#什么是Dapp" class="headerlink" title="什么是Dapp"></a>什么是Dapp</h3>Dapp由智能合约和客户端代码构成。类似于后端和前端。智能合约跑在区块链上。</li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TDD笔记</title>
      <link href="/2017/12/21/TDD%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/TDD%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<pre><code>graph TD需求提出--&gt;抽象出模型抽象出模型--&gt;转化出测试用例转化出测试用例--&gt;TDD:定义接口测试接口抽象出模型--&gt;|not TDD|codeTDD:定义接口测试接口--&gt;提交PR并讨论提交PR并讨论--&gt;codecode --&gt;整合</code></pre><h2 id="自己写测试的心得"><a href="#自己写测试的心得" class="headerlink" title="自己写测试的心得"></a>自己写测试的心得</h2><p>普通写代码就是直接撸，写成啥是啥，错了就改<br>正确的写测试就是  先想好接口，根据接口来写测试用例，最后再写代码去通过测试<br>这就叫谋而后动</p><p>今天跟了一个测试教程<br>学会了测试语言describe it   before after(mocha)  expect(supettest)</p><h2 id="在egg中写测试"><a href="#在egg中写测试" class="headerlink" title="在egg中写测试"></a>在egg中写测试</h2><p>这是应用的单元测试，不是插件和框架的单元测试</p><p>内置的egg-bin模块，这个模块已经内置了所有测试所需要的好用的模块。<br>包括：Mocha、co-mocha、power-assert，istanbul<br>测试mock辅助模块egg-mock</p><h3 id="第一步，编写测试"><a href="#第一步，编写测试" class="headerlink" title="第一步，编写测试"></a>第一步，编写测试</h3><h4 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h4><h3 id="第二步-配置测试"><a href="#第二步-配置测试" class="headerlink" title="第二步 配置测试"></a>第二步 配置测试</h3><p>在==package.json==中配置==script.test==</p><pre><code class="js">{    &quot;scripts&quot;:{        &quot;test&quot;:&quot;egg-bin test&quot;    }}</code></pre><h3 id="第三步-启动测试"><a href="#第三步-启动测试" class="headerlink" title="第三步 启动测试"></a>第三步 启动测试</h3><pre><code class="js">npm test</code></pre><p><a href="https://zhuanlan.zhihu.com/p/24997923" target="_blank" rel="noopener">打开TDD的正确姿势</a></p><h2 id="TDD是什么"><a href="#TDD是什么" class="headerlink" title="TDD是什么"></a>TDD是什么</h2><p>tested dirven development,测试驱动开发</p><h2 id="TDD的核心"><a href="#TDD的核心" class="headerlink" title="TDD的核心"></a>TDD的核心</h2><p>做好需求分析和设计，将==需求==拆解</p><h2 id="为什么要测试，什么时候测试"><a href="#为什么要测试，什么时候测试" class="headerlink" title="为什么要测试，什么时候测试"></a>为什么要测试，什么时候测试</h2><p>因为错误不可避免，要排除错误减少损失<br>测试越早越好，因为错误绝大部分错误是在早期引入的，发现在中后期<br>错误造成的损失随着时间呈现指数级的增长，越早发现，成本越低。这是软件测试的作用</p><p>测试驱动开发的作用：测试是根据需求来的，测试用例就是各个需求点，只要通过测试，模块的行为就能确保正确。在修改的时候做测试也能确保没有修改出错误。</p><h2 id="测试的概念"><a href="#测试的概念" class="headerlink" title="测试的概念"></a>测试的概念</h2><p><strong>单元测试</strong>：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。就是该部分能否正常工作</p><p> <strong>测试用例</strong>：进行单元测试使用的例子</p><p>单元测试不通过说明要么有bug，要么测试用例不正确</p><p>测试正确说明，对该函数的修改没有对原来的行为造成影响。</p><p>测试驱动，是测试的什么？<br>测试个模块的接口<br>检验是否满足规定的需求，找出与预期的差异</p><h2 id="测试效果的指标"><a href="#测试效果的指标" class="headerlink" title="测试效果的指标"></a>测试效果的指标</h2><p>提高测试覆盖率，测试效率</p><h2 id="测试的误区"><a href="#测试的误区" class="headerlink" title="测试的误区"></a>测试的误区</h2><p>盲目追求覆盖率</p><h2 id="测试的工具"><a href="#测试的工具" class="headerlink" title="测试的工具"></a>测试的工具</h2><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h3><p>mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。</p><p>使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。</p><p>mocha的特点主要有：</p><p>既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一；</p><p>可以自动运行所有测试，也可以只运行特定的测试；</p><p>可以支持before、after、beforeEach和afterEach来编写初始化代码。</p><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>包裹it们</p><p>第一个参数是测试的名字</p><p>第二个参数是一个函数，函数里是it</p><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><p>是各个测试用例</p><p>第一个参数是测试用例的描述</p><p>第二个参数是一个函数，函数体就是测试的内容，assert们</p><h3 id="supertest"><a href="#supertest" class="headerlink" title="supertest"></a>supertest</h3><p>网络测试<br>构造请求，expect断言 判断回复</p><h3 id="node自带断言库-assert"><a href="#node自带断言库-assert" class="headerlink" title="node自带断言库 assert"></a>node自带断言库 assert</h3><h2 id="如何写好测试"><a href="#如何写好测试" class="headerlink" title="如何写好测试"></a>如何写好测试</h2><p>所有人都假设TDD以后软件质量一定提高到最高境界了，但是测试代码也是代码，也有合理不合理的问题，也有价值与维护成本，不好的测试代码会降低效率<br>那么如何写好测试代码呢</p><blockquote><p>测试的核心是“可测试“，可测试意味着好的代码架构，写出可测试代码是优良测试的必要条件。</p></blockquote><blockquote><p>测试驱动开发不是测试人员驱动。<br>这种开发方法完全是开发人员自行实施的，要点在于开发功能之前先开发该功能的测试程序，当然一开始测试程序的结果是失败的，然后去实现功能，让测试结果成功通过<br>测试驱动也不是测试驱动项目运转</p></blockquote><blockquote><p>因为国内大多数程序员写的代码粒度太粗，无法测试。</p></blockquote><p>编写测试的原则是，一次只测一种情况，且测试代码要非常简单。</p><h2 id="TDD和时间的关系"><a href="#TDD和时间的关系" class="headerlink" title="TDD和时间的关系"></a>TDD和时间的关系</h2><blockquote><p>如果时间够，自然可以TDD。如果时间不够，有人可以tdd，测试先行，不代表真的要先写测试。tdd像一种工具或者流程，其背后有它自己的思维，掌握了思维，没有按流程出招，或许就表示tdd已死了吧。如果楼主是指形式或者招式，那么其在某些情况下还是继续存活的。比如时间足够，而程序员足够热爱它</p></blockquote><blockquote><p>TDD只是一个概念，时间允许的话每个重要的方法业务都写单元测试，涉及正确性测试，边界测试，错误测试等等。之后代码有改动再跑单元测试就可以了。这样开发会节省挺多时间。</p></blockquote><p>和时间的关系，写测试要消耗时间<br>这是一个问题，很多公司的迭代周期比较短，比如半个月。那么如何搞TDD呢</p><h2 id="TDD的好处"><a href="#TDD的好处" class="headerlink" title="TDD的好处"></a>TDD的好处</h2><blockquote><p>TDD好处其实很简单：</p><ol><li>帮你整理需求</li><li>帮你设计接口（空想的话很容易设计出屎）</li><li>帮你做regression和给以后重构做准备</li></ol></blockquote><p>提高程序健壮性</p><blockquote><p>TDD会鼓励你对现有代码，更频繁，更敏捷地进行改变<br>它带给你的是，更少的regression，更少的debuggingtime，以及更多的勇气来refactor</p></blockquote><blockquote><p>是tdd重新让我编程的信心和乐趣。<br>我不爱用眼睛看检查运行结果，只要改动之后，一运行看到一长排的勾我就去冲杯香飘飘喝吧喝吧，喝了睡觉去了</p></blockquote><hr><blockquote><p>过度测试是存在。但一些看似过度的testmethod确实揪出了bug。国内中小公司(没去过大公司，不知道啥情况)从上到下对测试总是抗拒的态度。他们会迷惑如何在需求变更中控制缺陷，却不愿试着作任何改变。整天鼓吹熬夜搬砖的人是没法沟通的:(。所以总是测试不够，而非过度</p></blockquote><p>要会单元测试，没有deadline的威胁，就是时间要足够<br>适合思路发散常常迷糊的人，让人有安全感，能确定想法落实了<br>可以灵活一些，比较高层的feature在确保接口可测试的前提下，没必要完全tdd。</p><blockquote><p>TDD是否已死先不说，很多程序员连写出基本的整洁代码都做不到，还能指望他先写测试吗？写代码绝对是个技术活，而不是体力活。所以，写代码需要不断修炼，比如code dojo, code kata 至于是否用TDD方式写代码，倒不一定。如果程序员的思维转变，写代码之前先考虑到测试用例、测试场景，也是一个很大的转变，即测试先行。</p></blockquote><blockquote><p>我觉得TDD不火的原因是它对developer的素质要求非常高。新手看到TDD会欢欣鼓舞，但是他们没有能力来实践。老手们在项目的压力下，早就麻木了，先写case还不如写好代码再补case呢，很多东西我还没时间想清楚，怎么写case？不如先写个小功能先，边写边改，等稳定下来再补case. 所以对老手来说也需要不断练习，才能熟悉TDD.</p></blockquote><blockquote><p>其实我们的目的是为了快速的交付有价值，有质量的产品或者服务，赢得公司的生存和发展空间。为了达到这个目的，我们有很多种的手段。但手段不是目的。<br>有很多盲目推崇TDD的所谓敏捷专家，其实是把手段当做目的，而忽略了问题的本质</p></blockquote><blockquote><p>首先理清一个价值观问题，是方法论为生产力服务还是生产力为方法论服务<br>TDD的错误在于，他没有尊重程序员尊重开发实际，让非生产代码通知生产代码</p></blockquote><blockquote><p>TDD 力量和问题都源自 test first。要能 test first，写代码之前要想得更清楚；代码得要有良好的可测试性，而为了可测试性要做一些不直接产生效益的工作；两者都既能推动思考，也能限制思考。TDD 是正确的思想：程序员要保证代码的正确性，和不完美的实践：程序员写测试。</p></blockquote><blockquote><p>目前我们团队也在想办法推行TDD，但是不是标准的TDD，而仅仅是测试先行，并且不用mock这样做可以在实现业务代码之前对于自己的程序要实现什么有一个清晰的认识，而且写程序的过程也变成了“跑通我的单元测试”的过程，这样更加有目标和针对性，当你看到你写完的业务代码能跑通单元测试的时候，是否有种游戏过关的成就感呢？等到全员都逐渐适应这种测试先行的做法，再“得寸进尺”，多要求一点点。</p></blockquote><blockquote><p>测试先行，怎么和开发做交互呢？什么时间调用开发的方法？<br>测试先行是说在实现业务逻辑前先写完单元测试，此时的单元测试肯定不通，之后再逐渐针对测试完善业务代码，最后跑通测试的时候业务代码也就完成了。不是让测试人员先测的意思</p></blockquote><blockquote><p>TDD解决了：1）我要开始写代码了，我从哪开始。 搞个main，还是搞个test2）我不知道那个家伙的代码写的怎么样，以后会不会捅个篓子，要求他TDD好了。CodeReview的时候也轻松点。飞机上写几个小时代码，下来编译一遍过还没有bug的人。你跳出来说，他没有tdd，他LowB，那你是不是有毛病。总之一句话，各种方法论都是解决一个问题——人不行。</p></blockquote><blockquote><p>软件开发说到底还是抽象和逻辑的艺术，TDD只是一种辅助开发手段，并不会减少因为开发人员素质不过硬或者工期短赶工而在开发过程中产生的抽象和逻辑问题。从来没听说过历史上哪位编程高手是因为什么方法论而练成的，人家是数据结构、算法、抽象和逻辑能力真的强大。对了，除了TDD，那什么敏捷、XP、结对、DDD等等，所有抛开实际抽象和逻辑问题的方法论，都是垃圾。</p></blockquote><p>更重要的是  基础的是  数据结构算法  抽象  逻辑能力</p><blockquote><p>TDD在什么情况下最有效？</p><ol><li>一个老系统，</li><li>老系统有还不错的test case</li><li>有很多相关系统依赖老系统</li><li>老系统要推翻重做</li></ol></blockquote><blockquote><p>先阐明观点，TDD没死，只是存活着在一些技术及配合要求比较高的团队，并且是挑业务的。我在互联网行业摸打滚爬了蛮久，历经各种项目，包括PC、游戏、云存储、电商等项目，TDD也是我这几年年一直在推动的事情，大部分失败了，也有些收获，这里大致把所了解以及个人见解说下。拿我所熟悉的互联网行业来说吧，其他传统软件行业经历时间太早，离当前较远，就不乱说了。现在互联网大都流行敏捷开发，其模式大家可自行度娘，但是真正做到的貌似没有，最少我没见过或者听过，很难用定性的词语来形容（语文不好），用个相似度来说吧，当前BAT公司排序为BTA（还是个人见解），用我个人的说法就是作坊式开发，忽略很多流程，只留下骨干的评审、开发、用例评审、转测、回归发布的流程。这个模式特点就是快，从需求提出到发布上线，一般都是一两周的时间，现有三周才能开发完成的业务。当然这里也有提出异议，说我太片面了，不过我说的大部分的互联网公司业务，保守估计60%的比例吧。解释完了互联网公司的开发模式，接下来我们回到TDD，至于TDD的概念，我就不科普了，自行度娘。其中TDD有一个特点非常明确，基本上可以作为是否做到的标签。这就是测试架构先于开发完成，并可对开发完成大部分模块进行测试（个人的理解，标准定义自行百度）。为了达到这个目的，我们搬出几个要素出来：时间、人、效果、方式。时间：什么时候完成，项目时间大约多久可以做TDD，TDD占项目时间大约多少比例合适。人：谁来做，一个人的项目我这里不谈，只谈多人协作项目，开发做还是测试来做？效果：要达成什么效果，以什么为合格的TDD的指标，功能覆盖？代码覆盖率？方式：要怎么做，开发一套自动化框架，还是用先协商接口用单测来完成，这里特别要提出的是，需要考虑后期维护的代价。</p></blockquote><blockquote><p>TDD 推行的最大问题在于，大多数程序员还不会「写测试用例」和「重构」。<br>我认为推行TDD主要在两个方面努力，即意识和能力（好像任何事情都是这两方面哈）。意识方面主要是：认识到自己原有编程方法的不足；搞清楚TDD的价值所在，如何弥补原有方法的不足；心态开放，勇于尝试新鲜事物，不要浅尝辄止，要持续改进。意识和能力没有先后关系，而是在不断学习和实践过程中同时提高。在这篇文章中，我更想谈的是能力。我见到初接触TDD的人常犯下面的错误：在声明测试方法后，便开始写实现代码；写完“所有”的测试代码才开始写实现；一次实现过多的代码（超出当前测试覆盖的业务）；从不重构；测试实现细节而不是接口行为；TDD真是看起来容易，做起来难。</p></blockquote><pre><code>graph LRRed--&gt;GreenGreen--&gt;RefactorRefactor--&gt;Red</code></pre><blockquote><p>上面这个图一目了然，但其实每一步都是对能力有要求的：红测试先行并不是说不需要思考，直接开始写代码。在开始写代码之前要进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断循环去实现。测试代码其实是产品代码的“用户”，在写测试代码时你就要考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实我们就是在做设计，而且设计以代码来体现，比在脑袋中空想要更直观。很多人不懂“意图式编程”，总是习惯先实现一个东西，再去调用它。而测试先行就要求先使用，再实现。这样能少走很多弯路，减少返工。无法把测试前置的原因往往在于，测试的是「实现」，也就是你写的是「白盒」测试。这样的测试根本没有价值，重构的时候会成为维护负担。而好的做法是测试「做什么」，而不是「怎么做」。绿以最快的速度让测试变绿，意味着我们通常用最直接但可能并不优雅的方式，比如复制代码。然后小步重构，直到符合简单设计的原则：通过所有测试每个概念都被清楚地表达没有重复没有多余的东西难的是要让实现刚好满足当前的测试，不做过度的设计，不写多余的代码。因为如果你写多了，除了引入复杂性以外，多的那部分就没有测试能覆盖到。或者你后面的测试写出来就能直接变绿，你就没办法按TDD的节奏进行下去了。重构首先要能识别坏味道，一些低级的Smell，很容易识别，比如：Magic Number，重复代码，太大的类，太长的方法，命名等。但更高级的如Feature Envy，Lazy Class等就比较难以识别。只要识别到Smell，知道用什么手法去重构，剩下的就比较简单了，现代的IDE，尤其是JetBrains的产品，对重构的支持非常强大，几乎都可以用快捷键完成。选对工具非常重要，善假于物能极大提高开发效率。但也不能过分依赖工具，要明白每一个手法背后的原理。所以推荐每个想要实践TDD的开发者，一定要先读《重构》。最后我想说：TDD不是银弹，不可能适合所有的场景，但这不应该成为我们拒绝它的理由。也不要轻易否定TDD，如果要否定，起码要在认真实践过之后。</p></blockquote><h1 id="TDD教程"><a href="#TDD教程" class="headerlink" title="TDD教程"></a>TDD教程</h1><p>总览</p><p>TDD的理解和讲解</p><p>基线描述</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态<br>掌握mock技巧，能够讲出几种mock的场景<br>了解SetUp的作用<br>会写TestCase<br>给出题目可以驱动着写出来<br>细节如下：</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态</p><p>正确的TDD的步骤至少包含下面的几个点，写一个TestCase，运行，得到期望的失败，写实现，重构</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基础数据结构</title>
      <link href="/2017/12/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/12/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>数据结构，数据存储的方法，包括数据对象，和操作集，不包括具体实现。具体实现是算法</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>检索简单，增删难</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Set，不重复的数组</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>增删简单，检索难。插入删除内存和时间消耗小，查询消耗大，适合插入多，查询少的情景</p><p>广义表：是线性表的推广，元素可以是另一个广义表</p><p>多重链表：节点可能属于多个链表，双向链表不是多重链表。树和图就是用多重链表实现</p><p>稀疏矩阵用多重链表存储。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>先进后出</p><p>表达式求值，递归，函数调用，深度优先搜索，回溯算法</p><p>具有一定操作约束的线性表</p><h5 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h5><p>一维数组和一个记录栈顶元素位置的变量</p><p>链表实现，从头部插入</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>也是一种受限制的线性表，先进先出</p><p>普通线性表在所有位置都可以增删，堆栈只在顶部增删，队列只在头尾增删</p><p>用链表实现的时候，因为链表的尾部不能执行删除操作，所以队列的头部只能是链表的头部</p><h5 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h5><ol><li>优先队列</li><li>循环队列</li></ol>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法笔记</title>
      <link href="/2017/12/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h3 id="计算时间复杂度的方法"><a href="#计算时间复杂度的方法" class="headerlink" title="计算时间复杂度的方法"></a>计算时间复杂度的方法</h3><p>数循环次数：循环的嵌套</p><p>均摊分析：(1+n)/2，一次性的操作平均到整体</p><p>递归式:主定理</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p>1:基本运算，+,-,*,/,%,寻址</p><p>logn：二分查找</p><p>根号n:枚举约数，少见</p><p>n:线性查找，很多时候算法的下限就是n，因为数据的读入的复杂度就已经是n了</p><p>nlogn：归并排序，快速排序的期望复杂度，基于比较排序的算法下界</p><hr><p>n的平方：朴素最近点对，冒泡排序，选择排序</p><p>n的三次方：Floyd最短路径，普通矩阵乘法</p><p>2的n次方：枚举全部的子集</p><p>n的阶乘：枚举全排列</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>cs总结</title>
      <link href="/2017/12/21/cs%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/21/cs%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="熟悉"><a href="#熟悉" class="headerlink" title="熟悉"></a>熟悉</h3><pre><code class="coffeescript"># 列表解析result = (item.value for item in array when item.name is &#39;test&#39;)# 前十个全局属性(变量)globals = (name for name of window)[0...10]# 对象解析ages = for key, value of Object  &quot;#{key} is #{value}&quot;# 定义函数square = (x) -&gt;  x * x  # body...  # 定义的时候有括号，调用的时候没括号# 数组song = [  &#39;do&#39;  &#39;re&#39;  &#39;mi&#39;  &#39;fa&#39;  &#39;so&#39;]# 对象singers =  brother:    name:&#39;max&#39;    age:11  sister:    name:&#39;ida&#39;    age:9    s-sister:      name:&#39;haha&#39;      age:2# if elseif one and/or/is/not two  # body...else  # body...# 三元判断date = if one and two then value else other# 函数链式调用$ &#39;body&#39;.click (e) -&gt;  $ &#39;.box&#39;  .fadeIn &#39;fast&#39;  .addClass &#39;show&#39; .css &#39;background&#39;, &#39;white&#39;# 回调写法和胖箭头函数Account = (customer,cart) -&gt;  @customer = customer  @cart = cart  $(&#39;.shapping_cart&#39;)  .on &#39;click&#39;, (event) =&gt;    @customer.purchase @cart# promise写法sleep = (ms) -&gt;  new Promise (resolve) -&gt;    window.setTimeout resovle,ms# async写法直接写在普通函数里，阻塞的执行# 类的写法class Animal  constructor: (@name) -&gt;  move:(meters) -&gt;    alert @name + &quot; moved #{meters}m.&quot;    # body...</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>编译命令，</p><pre><code>coffee -c -o targetfolder filename</code></pre><p>先是两个参数，然后是目标文件夹，最后是编译的文件</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>数组换行可以省略一个逗号，那就都换行吧，彻底抛弃逗号</li><li>直接加尾巴截取数组，还可以直接用来赋值<pre><code>[0...10]</code></pre></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ol><li>对象的花括号用缩进代替</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的区别，</p><ol><li>定义的时候有括号，调用的时候没括号,调用的时候没有参数也需要括号</li><li>函数没有大括号，用箭头识别，箭头左边小括号里放参数，右边是函数体</li><li>函数默认返回函数体最后一个表达式的值，可以省略return</li><li>空return取消return</li><li>变量不需要声明，所以函数名也不需要声明</li><li>默认参数</li><li>胖箭头函数，作用只是绑定this？ 需要返回一个绑定this的函数的时候使用</li></ol><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>直接把await写在普通函数里</p><h3 id="词法作用域和变量安全"><a href="#词法作用域和变量安全" class="headerlink" title="词法作用域和变量安全"></a>词法作用域和变量安全</h3><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><h4 id="变量安全"><a href="#变量安全" class="headerlink" title="变量安全"></a>变量安全</h4><ol><li>函数的所有 CoffeeScript 结果都被一个匿名函数包裹</li></ol><pre><code>(function(){ ... })();</code></pre><p>这层安全的封装, 加上自动生成的 var 关键字,使得不小心污染全局命名空间很难发生.</p><ol><li>因为被包裹了，用顶层变量, 需要将其作为赋值在 window 上, 或者在 CommonJS 里的 exports 上.</li><li>存在操作符(existential operator)可以帮你写出一个可靠的方式找到添加位置; 比如你的目标是同时满足 CommonJS 和浏览器: exports ? this<br>4.</li></ol><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><ol><li>一个判断一个赋值的判断简写</li></ol><pre><code>name = value if condition</code></pre><ol><li>普通写法,和js相比就是省略了条件的小括号和函数体的大括号</li><li>三元判断符</li></ol><pre><code>name = if condition then rightvalue else wrongvalue</code></pre><ol><li>unless: 不是… ，就执行，是就跳过</li></ol><pre><code>return 哈哈哈 unless 嘿嘿嘿//如果不是嘿嘿嘿，就返回哈哈哈//如果是嘿嘿嘿，就跳过往下执行//作用：满足嘿嘿嘿才能往下执行//干嘛不用if？</code></pre><p>if else 和unless都可以，看个人喜好</p><h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>变参函数定义,参数后加上…</p><p>变参函数调用,函数调用后加上…</p><h3 id="循环和推导式"><a href="#循环和推导式" class="headerlink" title="循环和推导式"></a>循环和推导式</h3><h4 id="for-in遍历数组"><a href="#for-in遍历数组" class="headerlink" title="for in遍历数组"></a>for in遍历数组</h4><pre><code>item-operation for item in 数组</code></pre><p>两个参数</p><pre><code>for in 循环的参数，第一个是值，i是index</code></pre><p>加上判断</p><pre><code>item-operation for item in 数组 when item isnt value</code></pre><p>by控制循环的跨度</p><h4 id="for-of-遍历对象"><a href="#for-of-遍历对象" class="headerlink" title="for of 遍历对象"></a>for of 遍历对象</h4><pre><code>#遍历所有键值对ages = for key,value of yearsOld  &quot;#{child is #{age}&quot;#遍历自有非继承键值对for own key,value of yearsOld#遍历gegerator用from</code></pre><h4 id="while和until"><a href="#while和until" class="headerlink" title="while和until"></a>while和until</h4><pre><code># 满足条件就一直执行buy() while supply &gt; demand# 满足条件就不执行了sell() until supply &gt; demand</code></pre><h4 id="for-in-do"><a href="#for-in-do" class="headerlink" title="for in + do"></a>for in + do</h4><p>配合起来，对每一个满足条件的元素执行操作</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><table><thead><tr><th>CoffeeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>is</td><td>===</td></tr><tr><td>isnt</td><td>!==</td></tr><tr><td>not</td><td>!</td></tr><tr><td>and</td><td>&amp;&amp;</td></tr><tr><td>or</td><td></td></tr><tr><td>ture,yes,on</td><td>true</td></tr><tr><td>false,no,off</td><td>false</td></tr><tr><td>@,this</td><td>this</td></tr><tr><td>a in b</td><td>[].indexOf.call(b,a) &gt;=0</td></tr><tr><td>a of b</td><td>a in b</td></tr><tr><td>for a form b</td><td>for (a of b)</td></tr><tr><td>a ** b</td><td>Math.pow(a,b)</td></tr><tr><td>a // b</td><td>Math.floor(a/b)</td></tr><tr><td>a %% b</td><td>(a % b + b) % b</td></tr></tbody></table><h3 id="存在性操作符"><a href="#存在性操作符" class="headerlink" title="存在性操作符"></a>存在性操作符</h3><pre><code>?name# 只要不是null或者undefined就返回truespeed ?= 15# 当speed为null或者undefined的时候执行赋值</code></pre><h1 id="自己的总结"><a href="#自己的总结" class="headerlink" title="自己的总结"></a>自己的总结</h1><ol><li>没有冒号</li><li>没有括号，用换行和缩进控制层级</li><li>数组的省略写法</li><li>编译之后给module.exports外面套一层自执行函数对导出模块没有影响</li><li>if判断里面没有默认return</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>控制返回值，不想让它包裹一层然后返回，可以写<br>return 那么对async函数有影响</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://cnodejs.org/topic/53a64eb1c3ee0b5820b20863" target="_blank" rel="noopener">coffeescript编码风格指南</a></p><h1 id="不喜欢的地方"><a href="#不喜欢的地方" class="headerlink" title="不喜欢的地方"></a>不喜欢的地方</h1><ol><li>关于语义化的思考</li><li>调用函数的时候，前面一个参数较复杂，后面一个参数需要仔细辨别，没有括号直观<br>3.</li></ol>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计需求分析与方案选择</title>
      <link href="/2017/12/21/%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/"/>
      <url>/2017/12/21/%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p>设计师的基本思路是，解决了什么问题，为什么要这样解决</p><p>了解问题比提供解决方案重要</p><h3 id="设计方案不能令人满意的原因"><a href="#设计方案不能令人满意的原因" class="headerlink" title="设计方案不能令人满意的原因"></a>设计方案不能令人满意的原因</h3><ol><li>没有细致的沟通==业务需求==，一直改方案，没有自己的观点</li><li>没有仔细的分析==用户需求==，只是简单的进行页面排版</li><li>没有对==用户体验路径==进行仔细分析，缺乏一个好的方式引导用户使用</li></ol><h4 id="业务需求-业务目的-业务目标"><a href="#业务需求-业务目的-业务目标" class="headerlink" title="业务需求 = 业务目的 + 业务目标"></a>业务需求 = 业务目的 + 业务目标</h4><p>业务目的：为什么要做这块业务，当中存在哪些问题<br>业务目标：做了这块业务之后，产品期望得到怎样的结果</p><h4 id="用户需求-目标用户（特征、经验）-场景-行为-体验目标"><a href="#用户需求-目标用户（特征、经验）-场景-行为-体验目标" class="headerlink" title="用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标"></a>用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标</h4><p>谁在什么时候有什么样的行为，目标是什么</p><h4 id="用户体验路径"><a href="#用户体验路径" class="headerlink" title="用户体验路径"></a>用户体验路径</h4><p>搞清楚用户在使用前，使用中，使用后的各个接触点，确保设计方案能够形成闭环</p><h1 id="需求分析四步"><a href="#需求分析四步" class="headerlink" title="需求分析四步"></a>需求分析四步</h1><h2 id="一-分析业务需求"><a href="#一-分析业务需求" class="headerlink" title="一 分析业务需求"></a>一 分析业务需求</h2><p>业务需求 = 业务目的 + 业务目标<br>业务目的：为什么要做这块业务，当中存在哪些问题<br>业务目标：做了这块业务之后，产品期望得到怎样的结果</p><p>目的是达到了某个目标之后想要做的事情，也就是实现目标的真正动机</p><p>例：</p><table><thead><tr><th>业务需求</th><th>业务目的</th><th>业务目标</th></tr></thead><tbody><tr><td>注册</td><td>通过登记用户信息，以方便产品进行用户管理</td><td>提高注册页面的转化率</td></tr></tbody></table><p>提供用户注册是一个业务需求，提高注册转化率是它的业务目标。当我们提高了注册转化率，就能获得更多的注册用户数，从而实现有效进行用户管理的目的。</p><h3 id="互联网产品常见的目标（提升-降低）"><a href="#互联网产品常见的目标（提升-降低）" class="headerlink" title="互联网产品常见的目标（提升/降低）"></a>互联网产品常见的目标（提升/降低）</h3><table><thead><tr><th>类别</th><th>常见目标</th></tr></thead><tbody><tr><td>产品类</td><td>PV，UV，用户数，转化率，留存率，活跃度等等</td></tr><tr><td>市场类</td><td>传播量，市场份额，各种排名等</td></tr><tr><td>品牌类</td><td>服务认知，品牌认知，品牌忠诚度等等</td></tr><tr><td>营收类</td><td>销售量，销售额，利润率，ROI等等</td></tr></tbody></table><h3 id="制定具体的目标时，要符合smart原则"><a href="#制定具体的目标时，要符合smart原则" class="headerlink" title="制定具体的目标时，要符合smart原则"></a>制定具体的目标时，要符合smart原则</h3><p>S:specific，具体<br>M:measurable，可衡量<br>A:attainable，可实现<br>R:relevant，有关联<br>T:time-based，有时限</p><h3 id="没有目标导致的结果"><a href="#没有目标导致的结果" class="headerlink" title="没有目标导致的结果"></a>没有目标导致的结果</h3><ol><li>方案的讨论容易发散</li><li>方案的评估缺乏评判标准</li><li>方案的效果无法衡量<br>4.</li></ol><h3 id="了解目的和目标之后"><a href="#了解目的和目标之后" class="headerlink" title="了解目的和目标之后"></a>了解目的和目标之后</h3><h2 id="二-分析用户需求"><a href="#二-分析用户需求" class="headerlink" title="二 分析用户需求"></a>二 分析用户需求</h2><p>用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标<br>谁在什么时候有什么样的行为，目标是什么</p><h2 id="三-分解关键因素"><a href="#三-分解关键因素" class="headerlink" title="三 分解关键因素"></a>三 分解关键因素</h2><p>用户的动机，担忧，障碍</p><p>实现业务目标的关键因素</p><ol><li>创造动机，促进用户行为</li><li>排除担忧，排除行为前的担忧</li><li>解决障碍，解决行为中的障碍</li></ol><h2 id="四-归纳设计需求，明确设计策略"><a href="#四-归纳设计需求，明确设计策略" class="headerlink" title="四 归纳设计需求，明确设计策略"></a>四 归纳设计需求，明确设计策略</h2><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>将业务目标，用户目标转化成有效的解决方案</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>如何将==业务目标==转化为==用户行为==，即通过引导用户的使用来帮助产品实现目标</p><p>从设计==用户行为==到设计==用户界面==：<br>用户行为决定了用户界面，用户界面页导致了用户会出现什么样的行为</p><h3 id="如何选择解决方案"><a href="#如何选择解决方案" class="headerlink" title="如何选择解决方案"></a>如何选择解决方案</h3>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用户调研思考</title>
      <link href="/2017/12/21/%E7%94%A8%E6%88%B7%E8%B0%83%E7%A0%94%E6%80%9D%E8%80%83/"/>
      <url>/2017/12/21/%E7%94%A8%E6%88%B7%E8%B0%83%E7%A0%94%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>拿到小房东手里的房源信息</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>让更多的小房东使用我们的房屋租赁管理工具</p><h1 id="问题-远一点"><a href="#问题-远一点" class="headerlink" title="问题 远一点"></a>问题 远一点</h1><p>这是一个怎样的市场</p><p>市场上的房子是什么样的？种类及比例</p><p>市场上的房东是什么样的？种类及比例</p><p>市场上的租客是什么样的？种类及比例</p><p>未来几年内，房子，房东，租客又是什么样的？</p><h1 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户"></a>目标用户</h1><p>手里有几套房的，自己运营的房东</p><p>这群人有多少？他们有多少房？直接决定我们能做成多大的平台。</p><p>个体户足够多才能形成平台，平台足够大才能吸引大房东。</p><p>了解这样的个体户。</p><h2 id="问题-近"><a href="#问题-近" class="headerlink" title="问题 近"></a>问题 近</h2><h4 id="我们的目标用户是什么样的人？"><a href="#我们的目标用户是什么样的人？" class="headerlink" title="我们的目标用户是什么样的人？"></a>我们的目标用户是什么样的人？</h4><p>手里有房子需要租出去的人</p><h4 id="我们的功能"><a href="#我们的功能" class="headerlink" title="我们的功能"></a>我们的功能</h4><p>帮助所有需要把房租出去的人解决问题</p><h4 id="他们的数量"><a href="#他们的数量" class="headerlink" title="他们的数量"></a>他们的数量</h4><p>这决定了我们的平台第一阶段能够有多大</p><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><ol><li>一房东，二房东</li><li>业余，全职</li><li>房子少，房子多</li><li>个人，团队</li><li>用过工具，没用过工具</li><li>学习能力强，不强</li></ol><p>使用设备</p><p>常用APP</p><p>痛点，品牌偏好</p><p>不同的产品，用来描述用户的角度有所不同，即用户画像的内容纬度会有所不同</p><p>==场景故事== 时间，地点，干什么</p><p>一般会有3~6个用户</p><p>==用户画像==：<br>通过用户的目标，行为，观点，基本信息等，对其真实特征进行勾勒，一般会得到3~6个画像/人物角色，每个画像代表一群真实的人</p><p>就像小说里的角色，都是作者观察生活总结出来的典型</p><p>画像之后调研比例，形成定量用户画像</p><h4 id="他们的日常生活"><a href="#他们的日常生活" class="headerlink" title="他们的日常生活"></a>他们的日常生活</h4><h4 id="对于工具的需求如何？"><a href="#对于工具的需求如何？" class="headerlink" title="对于工具的需求如何？"></a>对于工具的需求如何？</h4><h4 id="面向小房东的管理工具？"><a href="#面向小房东的管理工具？" class="headerlink" title="面向小房东的管理工具？"></a>面向小房东的管理工具？</h4><h4 id="房屋租赁管理的基本需求"><a href="#房屋租赁管理的基本需求" class="headerlink" title="房屋租赁管理的基本需求"></a>房屋租赁管理的基本需求</h4><h4 id="我们的工具能在多大程度上帮助他们"><a href="#我们的工具能在多大程度上帮助他们" class="headerlink" title="我们的工具能在多大程度上帮助他们"></a>我们的工具能在多大程度上帮助他们</h4><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个4.6万亿的市场。有前景。</p>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用研笔记</title>
      <link href="/2017/12/21/%E7%94%A8%E7%A0%94%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/%E7%94%A8%E7%A0%94%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="用户研究概述"><a href="#用户研究概述" class="headerlink" title="用户研究概述"></a>用户研究概述</h1><p>==用户研究员的能力==，技术技能和非技术技能</p><h2 id="技术技能"><a href="#技术技能" class="headerlink" title="技术技能"></a>技术技能</h2><ol><li>用户研究能力</li><li>人机交互能力</li><li>产品分析能力</li></ol><h3 id="一，用户研究能力"><a href="#一，用户研究能力" class="headerlink" title="一，用户研究能力"></a>一，用户研究能力</h3><p>针对产品开发的不同阶段，能够灵活运用各种调研方法，权衡利弊，制定适合的用户研究方案</p><p>能够输出高质量的用户调研报告，为产品设计提出合理化建议</p><p>用户研究能力包括：</p><ol><li>定量分析能力</li><li>定性分析能力</li></ol><h4 id="定量分析能力："><a href="#定量分析能力：" class="headerlink" title="定量分析能力："></a>定量分析能力：</h4><ol><li>数据的敏感度</li><li>数据分析能力</li><li>可熟练使用各类定量研究方法</li><li>掌握各类定量研究方法的应用场景及优缺点</li><li>独立完成分析的能力</li></ol><h4 id="定性分析能力："><a href="#定性分析能力：" class="headerlink" title="定性分析能力："></a>定性分析能力：</h4><ol><li>对常见定性研究方法，可熟练使用</li><li>对各个研究方法有自己的心得体会，掌握技巧</li><li>掌握各类定性研究方法的应用场景及优缺点</li><li>独立执行研究的能力</li></ol><h3 id="二，人机交互能力"><a href="#二，人机交互能力" class="headerlink" title="二，人机交互能力"></a>二，人机交互能力</h3><ol><li>熟练掌握人机交互的理论知识</li><li>熟悉掌握各终端设计规范</li><li>有良好的用户体验意识</li><li>可通过用户研究，发现产品设计中的不足，并能提供设计改善建议</li></ol><h3 id="三，产品分析能力"><a href="#三，产品分析能力" class="headerlink" title="三，产品分析能力"></a>三，产品分析能力</h3><ol><li>对所应聘行业非常了解，有充分准备</li><li>对所应聘行业的竞品非常熟悉</li><li>对所应聘部门的产品非常熟悉，并有自己的见解</li><li>有良好的产品感</li><li>热爱互联网产品，对于新兴产品有好奇心，保持对互联网产品的关注和体验</li></ol><h2 id="非技术技能"><a href="#非技术技能" class="headerlink" title="非技术技能"></a>非技术技能</h2><ol><li>沟通技巧</li><li>好奇心</li><li>学习能力</li><li>敏锐力</li></ol><h1 id="用户研究方法论"><a href="#用户研究方法论" class="headerlink" title="用户研究方法论"></a>用户研究方法论</h1><p>工作中会用到的知识与技能</p><h3 id="一，基本研究方法"><a href="#一，基本研究方法" class="headerlink" title="一，基本研究方法"></a>一，基本研究方法</h3><ol><li>研究设计，采集工具</li><li>数据的获取：外部数据，内部数据</li></ol><h3 id="二，统计学知识"><a href="#二，统计学知识" class="headerlink" title="二，统计学知识"></a>二，统计学知识</h3><ol><li>基础统计方法</li><li>高级统计学方法</li><li>数据挖掘（了解，可拓展学习）</li></ol><h4 id="基础统计分析"><a href="#基础统计分析" class="headerlink" title="基础统计分析"></a>基础统计分析</h4><h5 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>集中趋势</li><li>离散趋势</li><li>分布特征</li><li>推论统计</li><li>相关分析</li></ol><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>日常数据的初步加工分析</li><li>简单分析变量间关系</li><li>需要快速输出结果</li><li>进行简单分析</li></ol><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>用研岗要求掌握，相关岗位建议掌握</p><h4 id="高级统计方法"><a href="#高级统计方法" class="headerlink" title="高级统计方法"></a>高级统计方法</h4><h5 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>聚类</li><li>回归</li><li>主成分</li><li>因子分析</li><li>判别分析</li><li>对应分析</li><li>多维尺度分析</li><li>生存分析</li><li>路径分析</li><li>结构方程</li></ol><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>对数据进行深挖掘和分析</li><li>分析变量间的关系</li><li>趋势预测，用户细分等</li></ol><h5 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h5><p>用研岗要求掌握，相关岗位了解</p><h4 id="数据挖掘方法"><a href="#数据挖掘方法" class="headerlink" title="数据挖掘方法"></a>数据挖掘方法</h4><h5 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>神经网络</li><li>决策树</li></ol><h5 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>可实现实时，自动化分析</li><li>具备自适应和自学习性</li></ol><h5 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h5><p>拓展学习</p><h3 id="三，数据分析思路及框架"><a href="#三，数据分析思路及框架" class="headerlink" title="三，数据分析思路及框架"></a>三，数据分析思路及框架</h3><ol><li>常用的分析框架</li><li>基于理论的分析模型</li></ol><p>比如：</p><ol><li>宏观的行业分析框架</li><li>微观的分析用户需求</li><li>用户满意度</li><li>品牌认知</li><li>转化</li><li>留存的分析框架</li></ol><h3 id="四，分析工具及软件"><a href="#四，分析工具及软件" class="headerlink" title="四，分析工具及软件"></a>四，分析工具及软件</h3><ol><li>Excel</li><li>SPSS，专业数据分析软件，比Excel高阶</li><li>SPSS modeler， R语言， Amos（拓展学习），LISREL，Python</li></ol><h3 id="五，图表制作"><a href="#五，图表制作" class="headerlink" title="五，图表制作"></a>五，图表制作</h3><ol><li>基本图表制作</li><li>数据可视化</li></ol><h3 id="六，报告撰写及演示"><a href="#六，报告撰写及演示" class="headerlink" title="六，报告撰写及演示"></a>六，报告撰写及演示</h3><ol><li>PPT制作，演讲能力</li></ol><h3 id="七，行业及业务领域知识"><a href="#七，行业及业务领域知识" class="headerlink" title="七，行业及业务领域知识"></a>七，行业及业务领域知识</h3><h4 id="行业领域知识"><a href="#行业领域知识" class="headerlink" title="行业领域知识"></a>行业领域知识</h4><p>互联网，垂直细分行业知识</p><h4 id="业务相关知识"><a href="#业务相关知识" class="headerlink" title="业务相关知识"></a>业务相关知识</h4><ol><li>产品经理</li><li>设计</li><li>运营</li><li>市场营销相关知识</li></ol><h4 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h4><ol><li>用户体验</li><li>经济学</li><li>心理学</li><li>社会学</li><li>市场营销等</li></ol><h3 id="八，数据洞察和落地"><a href="#八，数据洞察和落地" class="headerlink" title="八，数据洞察和落地"></a>八，数据洞察和落地</h3><ol><li>通过数据给出有用的建议</li><li>落地跟进</li></ol><h1 id="用户定位与需求分析"><a href="#用户定位与需求分析" class="headerlink" title="用户定位与需求分析"></a>用户定位与需求分析</h1><h2 id="用户研究的‘用户’是谁？"><a href="#用户研究的‘用户’是谁？" class="headerlink" title="用户研究的‘用户’是谁？"></a>用户研究的‘用户’是谁？</h2><h3 id="用户的定义"><a href="#用户的定义" class="headerlink" title="用户的定义"></a>用户的定义</h3><p>狭义的用户：产品的使用者</p><p>广义的用户还有业务方</p><p>用户研究的意义</p><pre><code>graph TDa((业务方-所服务产品))--&gt;b((用户研究-桥梁))b--&gt;c((用户方-产品的目标用户))</code></pre><p>不是简单的将用户的需求告诉业务方，而是要考虑业务方为什么要提供这个产品/功能</p><p>业务方也是有需求的</p><p>了解双方的需求</p><h1 id="测试评估提升用户体验"><a href="#测试评估提升用户体验" class="headerlink" title="测试评估提升用户体验"></a>测试评估提升用户体验</h1><h3 id="用户体验优化设计"><a href="#用户体验优化设计" class="headerlink" title="用户体验优化设计"></a>用户体验优化设计</h3><p>目的&amp;内容：使产品更好用易用，产生更大的用户价值</p><h3 id="生命是数据分析"><a href="#生命是数据分析" class="headerlink" title="生命是数据分析"></a>生命是数据分析</h3><h3 id="案例分析：数据分析如何驱动体验优化"><a href="#案例分析：数据分析如何驱动体验优化" class="headerlink" title="案例分析：数据分析如何驱动体验优化"></a>案例分析：数据分析如何驱动体验优化</h3><h1 id="用户分群与追踪研究"><a href="#用户分群与追踪研究" class="headerlink" title="==用户分群与追踪研究=="></a>==用户分群与追踪研究==</h1><p>用户行为来自于用户动机（目标）</p><p>用户使用我们的产品（用户行为）产生用户态度</p><p>当前时间点下的用户情况</p><h2 id="用户画像例子，考霸族"><a href="#用户画像例子，考霸族" class="headerlink" title="用户画像例子，考霸族"></a>用户画像例子，考霸族</h2><h3 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h3><ol><li>人生阶段：毕业生</li><li>自驱力：强</li></ol><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>姓名，职业，年龄，家庭状况，互联网使用习惯</p><h3 id="个性特征"><a href="#个性特征" class="headerlink" title="个性特征"></a>个性特征</h3><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><h3 id="学习习惯"><a href="#学习习惯" class="headerlink" title="学习习惯"></a>学习习惯</h3><h3 id="付费经历及态度"><a href="#付费经历及态度" class="headerlink" title="付费经历及态度"></a>付费经历及态度</h3><h2 id="用户画像方法简介"><a href="#用户画像方法简介" class="headerlink" title="用户画像方法简介"></a>用户画像方法简介</h2><ol><li>定性用户画像，简单快速</li><li>定量用户画像</li><li>方法选择的原则</li></ol><h3 id="选择定性还是定量"><a href="#选择定性还是定量" class="headerlink" title="选择定性还是定量"></a>选择定性还是定量</h3><p>取决于</p><ol><li>用户画像的受众是谁？设计师?产品经理？</li><li>希望用户画像结果来支持什么类型的决定</li><li>打算花多少时间和钱</li></ol><h2 id="用户画像的特点"><a href="#用户画像的特点" class="headerlink" title="用户画像的特点"></a>用户画像的特点</h2><ol><li>越早越好，方向准确比行动重要</li><li>任何阶段都可以，任何阶段都有用，迟到比旷工好</li><li>不断迭代更新，用户会变化</li></ol><h1 id="从用户研究到商业分析"><a href="#从用户研究到商业分析" class="headerlink" title="从用户研究到商业分析"></a>从用户研究到商业分析</h1><p>用户研究为什么要学习商业分析</p><h3 id="产品人要具有大局观"><a href="#产品人要具有大局观" class="headerlink" title="产品人要具有大局观"></a>产品人要具有大局观</h3><p>理解用户只是基础，最终的目的都是创造商业价值，所以要懂商业分析</p><h3 id="商业与用户价值的平衡"><a href="#商业与用户价值的平衡" class="headerlink" title="商业与用户价值的平衡"></a>商业与用户价值的平衡</h3><p>豆瓣：过于重视用户体验而轻视商业发展</p><p>百度：过于重视商业发展而忽视用户体验</p><p>微信：取得用户体验和商业价值的平衡</p><p>在==正确的时机==找到产品在==商业价值和用户体验间的平衡点==至关重要</p><p>商业价值和用户价值的平衡就是</p><p>产品诉求和用户诉求的平衡</p><p>一名成功的用户研究员，需要研究和考量外部市场因素，驱动产品在商业价值和用户体验中取得平衡点</p><h3 id="创业公司中人员配置的不完备"><a href="#创业公司中人员配置的不完备" class="headerlink" title="创业公司中人员配置的不完备"></a>创业公司中人员配置的不完备</h3>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
