<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/08/09/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/09/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><pre><code class="shell">ps -a| grep name# 查看指定程序的进程id#用于显示tcp，udp的端口和进程等相关情况netstat -tunlp# 切换用户su name</code></pre>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>部署流程</title>
      <link href="/2018/07/09/%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/07/09/%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>项目写好了。有一台服务器。</p><h1 id="服务器基本配置"><a href="#服务器基本配置" class="headerlink" title="服务器基本配置"></a>服务器基本配置</h1><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code class="shell">ssh username@ip</code></pre><p>这是是root用户，权限太大不安全。</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><pre><code class="shell">新建用户 adduser name 给sudo权限 vim /etc/sudoers在root ALL=(ALL)ALL这一行下增加name ALL=(ALL)ALL</code></pre><h3 id="简化登录"><a href="#简化登录" class="headerlink" title="简化登录"></a>简化登录</h3><p>本机.zshrc文件给命令配置别名</p><pre><code>alias tx=&quot;ssh name@ip&quot;</code></pre><h3 id="无密码登录"><a href="#无密码登录" class="headerlink" title="无密码登录"></a>无密码登录</h3><p>和git仓库配置秘钥原理一样。</p><pre><code>1. 两边都要有生成秘钥ssh-keygen -t rsa -C “email”2. 服务器保存本地公钥echo pubkey &gt;&gt; .ssh/authorized_keys3. 重启服务器sshservice ssh restart</code></pre><h3 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h3><pre><code>1. 修改端口文件/etc/ssh/sshd_config port属性,换成其他端口2. 关闭root密码登录PermitRootLogin属性，换成without-password3. 重启ssh4. 还可以配置iptables</code></pre><h3 id="nginx配置端口代理"><a href="#nginx配置端口代理" class="headerlink" title="nginx配置端口代理"></a>nginx配置端口代理</h3><p>在/etc/nginx/nginx.conf中添加</p><pre><code class="sh"># 让nginx加载配置文件include /etc/nginx/conf.d/*.conf;</code></pre><p>然后在/etc/nginx/conf.d文件夹下新建配置文件name-port.conf</p><pre><code class="sh">upstream dappdemo {    server localhost:3000;}server {    listen 80;    server_name 127.0.0.1;    location / {        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;        proxy_set_header Host $http_host;        proxy_set_header X-Nginx-Proxy true;        proxy_pass http://dappdemo;        proxy_redirect off;    }}</code></pre><p>匹配到server_name的流量转发到proxy_pass</p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><pre><code>1. 安装dockerwget -qO- https://get.docker.com/ | sh2. 检验docker是否被正确安装sudo docker run hello-world</code></pre><h3 id="从仓库拉取代码"><a href="#从仓库拉取代码" class="headerlink" title="从仓库拉取代码"></a>从仓库拉取代码</h3><ol><li>服务器连接仓库<br><a href="https://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="noopener">教程</a></li><li>git clone</li></ol><h3 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h3><p>根据dockerfile新建一个镜像</p><pre><code>docker build -t yourname/imagename:tag .docker build -t benny/dapp:latest .</code></pre><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p>用了Makefile</p><pre><code class="sh">pjName := dappdemodocker:    docker run \        --name ${pjName} \        --rm \        -ti \        -p 3000:3000 \        benny/dapp:0.1 \        /bin/bash</code></pre><pre><code>make docker</code></pre><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>npm run start，使用pm2管理进程</p><pre><code>pm2 start pm2.json==================================={  &quot;apps&quot;: [    {      &quot;name&quot;: &quot;ico-dapp&quot;,      &quot;script&quot;: &quot;./server.js&quot;,      &quot;out_file&quot;: &quot;./logs/out.log&quot;,      &quot;error_file&quot;: &quot;./logs/error.log&quot;,      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;,      &quot;instances&quot;: 0,      &quot;exec_mode&quot;: &quot;cluster&quot;,      &quot;max_memory_restart&quot;: &quot;500M&quot;,      &quot;merge_logs&quot;: true,      &quot;env&quot;: {        &quot;NODE_ENV&quot;: &quot;production&quot;      }    }  ]}</code></pre>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx笔记</title>
      <link href="/2018/07/09/Nginx%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/09/Nginx%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>nginx是web服务器，性能高，并发性好。</p><p>可以用作代理服务器。</p><p>正向：直接转发</p><p>反向：分发请求</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>nginx -s reload 重新加载</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="这和用程序起一个服务有什么区别呢？"><a href="#这和用程序起一个服务有什么区别呢？" class="headerlink" title="这和用程序起一个服务有什么区别呢？"></a>这和用程序起一个服务有什么区别呢？</h3><p>语言自带类库实现的服务器比较简单。nginx是专业的，更强大。</p><p>为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h3 id="动静态资源分离"><a href="#动静态资源分离" class="headerlink" title="动静态资源分离"></a>动静态资源分离</h3><p>运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理</p><h1 id="实现打点计数"><a href="#实现打点计数" class="headerlink" title="实现打点计数"></a>实现打点计数</h1><p>用到了服务器功能，和日志功能。</p><p>服务器只返回一个像素的gif图，很高效。</p><p>日志路径为”/usr/local/Cellar/nginx/1.15.0/logs”</p><p>nginx.conf </p><pre><code>server {    location = /report {        empty_gif;    }}</code></pre><h1 id="实现负载均衡和端口代理"><a href="#实现负载均衡和端口代理" class="headerlink" title="实现负载均衡和端口代理"></a>实现负载均衡和端口代理</h1><p>nginx运行在80端口，将请求分发到对应的端口上</p><p>/etc/nginx/conf.d/name-port.conf</p><p>把入口的流量转发到dappdemo</p><pre><code class="sh">upstream dappdemo {    server 127.0.0.1:3000;#    down  表示单前的 server 暂时不参与负载     server 127.0.0.1:8083 down;#   weight  默认为 1 weight 越大，负载的权重就越大。     server 127.0.0.1:8084 weight=3;   #    backup 其它所有的非 backup 机器 down 或者忙的时候，请求 backup机器。所以这台机器压力会最轻    server 127.0.0.1:8002 backup;   }server {    listen 8080;#    匹配的入口    server_name 127.0.0.1;    location / {        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;        proxy_set_header Host $http_host;        proxy_set_header X-Nginx-Proxy true;        proxy_pass http://dappdemo;        proxy_redirect off;    }}</code></pre>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>非暴力沟通</title>
      <link href="/2018/07/03/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
      <url>/2018/07/03/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
      <content type="html"><![CDATA[<h1 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h1><p>沟通的目的：不是为了改变他人符合我们的利益，而是诚实基础上，获知双方的需要达成匹配</p><p>暴力行为的背后，往往隐藏着人性本恶的价值取向。接受人性本善的价值取向，暴力因素就会远离。</p><h1 id="交流如何变成暴力行为"><a href="#交流如何变成暴力行为" class="headerlink" title="交流如何变成暴力行为"></a>交流如何变成暴力行为</h1><h3 id="道德批判"><a href="#道德批判" class="headerlink" title="道德批判"></a>道德批判</h3><p>用自己的价值观给别人贴标签。这种标签实际上反应了我们的需要和价值观。贴完标签，偏见就产生了，偏见会阻碍交流。</p><h3 id="进行比较"><a href="#进行比较" class="headerlink" title="进行比较"></a>进行比较</h3><p>比较也是一种评判。强迫别人参加一场比赛，然后判他输。</p><h3 id="回避责任"><a href="#回避责任" class="headerlink" title="回避责任"></a>回避责任</h3><p>这是一种表达方式的问题。“不得不做”是一种回避责任的表达方式，需要换成负责任的方式。</p><h3 id="强人所难"><a href="#强人所难" class="headerlink" title="强人所难"></a>强人所难</h3><p>字面意思。对别人的要求往往暗含威胁。</p><h1 id="暴力行为的背后"><a href="#暴力行为的背后" class="headerlink" title="暴力行为的背后"></a>暴力行为的背后</h1><p>行为只是表面原因，问题的根源是对自己和世界的看法。比如优胜劣汰，人性本恶。</p><p>优胜劣汰在社会运作的规则之一，但我们的生活不是。在社会中我们不得不去竞争，比输了很正常，要能够接受。尽人事，听天命，实在是智慧之言。很多情况下，让我懊恼的失败都是没有“尽人事”。</p><p>这个世界好人有很多，坏人也不少，好人可能也做过坏事，坏人大概率也不是彻头彻尾的坏。沟通的时候应该采用“无罪推定”原则，重大利益面前还是“有罪推定”吧。小亏吃了也没啥，大亏万万不能吃。有些场景本来就是暴力的战争，非暴力适用的场景是沟通。</p><h1 id="非暴力沟通要素"><a href="#非暴力沟通要素" class="headerlink" title="非暴力沟通要素"></a>非暴力沟通要素</h1><p>技能是需要练习的，沟通这项技能有四个要素，<strong>观察</strong>、<strong>感受</strong>、<strong>需要</strong>和 <strong>请求</strong>。通过四要素的逻辑来组织语言，语言结构就不再是随意的、任性的甚至是暴力的，而是一种平等的、尊重的语言。</p><p>比如，你给我一份重要文件，中午出去吃饭我把他放在桌子上了，没有收起来。你看见了然后生气的说：“我给你这么重要的文件，你怎么随便扔在桌子上？”</p><p>用非暴力沟通的方式来组织语言就是这样的：</p><ol><li>观察：我看到你把文件放在桌子上</li><li>感受：我郑重交给你的重要文件，你却随意仍在桌子上，我感到失望</li><li>需要：保管好文件，尊重我的嘱咐</li><li>请求：保管好文件</li></ol><p>经过组织后的语言是这样的：我看见刚才交给你的重要文件没有放在桌子上没有收起来(观察)，我担心不安全(感受)，重要的文件应该妥善保管(需要、请求)</p>]]></content>
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Fabric基础笔记</title>
      <link href="/2018/07/01/Fabric%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/01/Fabric%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>Fabric的目标是实现一个通用的权限区块链(Permissioned Chain)的底层基础框架。</p><p>为了适用于不同的场合，采用模块化架构，提供可切换和可扩展的组件，包括</p><ol><li>共识算法</li><li>加密安全</li><li>数字资产</li><li>记录仓库</li><li>智能合约</li><li>身份鉴权</li></ol><p>Fabric克服了比特币等公有链项目的缺陷，如吞吐量低、无隐私性、无最终确定性以及共识算法低效等，使得用户能够方便地开发商业应用</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>超级账本的一个重要的设计原则是“用例驱动”(use case driven),所有的功能都有对应的用例需求。Farbic主要针对以下几种用例</p><h3 id="金融资产管存"><a href="#金融资产管存" class="headerlink" title="金融资产管存"></a>金融资产管存</h3><p>资产上链后，权益人可以直接访问资产数据，而无需经过传统的中间人，可大幅度提高效率和节约成本。另外资产附加自动执行的业务规则后，可以进一步降低运营成本。</p><p>与公有链应用的较大区别是，金融资产及其相关的交易、业务规则通常是保密的。</p><h3 id="公司行为"><a href="#公司行为" class="headerlink" title="公司行为"></a>公司行为</h3><p>上市公司发起的有关公司证券的事件一般和股东有关，需要股东做适时的回应。事件的完整信息需要及时传递给股东。股东作出决定后，该结果会实时处理货结算。整个过程应保护股东的隐私，确保投资者的决定不受外界影响</p><h3 id="供应链"><a href="#供应链" class="headerlink" title="供应链"></a>供应链</h3><p>在供应链中，所有的参与者都通过区块链记录、追踪和共享各种数据，例如原材料来源、零部件检测结果以及货物的出处等。数据上链，并贯穿货物的生产、运输和销售等环节，从而提供深度回溯查询等核心功能。</p><h3 id="主数据管理"><a href="#主数据管理" class="headerlink" title="主数据管理"></a>主数据管理</h3><p>在很多行业里，不同的组织之间往往共享一些主数据(master data)。例如，不同移动运营商之间，需要共同维护一份发射基站地理位置的数据。<br>通过区块链来保证数据的质量和完整性。</p><h3 id="分享经济"><a href="#分享经济" class="headerlink" title="分享经济"></a>分享经济</h3><p>分享经济是指将闲置或没有被充分利用的实物资源分享出来，有偿供陌生人暂时使用的一种商业模式。最需要解决的是陌生人之间的信任问题，即资源的提供方和资源的租用者，如何在缺乏信任的基础上安全地完成交易。目前的主要手段是通过分享经济平台来确保信任度。区块链将是一种去信任的方式，不使用任何中间平台，便可达到各方参与者可靠交易的目的</p><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric.JPG" alt="farbic架构"></p><h3 id="身份服务"><a href="#身份服务" class="headerlink" title="身份服务"></a>身份服务</h3><p>权限区块链与公链最大的区别就是具有身份识别能力。参与者都有明确的身份信息，身份服务管理着系统中各种实体、参与者和对象的身份信息。</p><h3 id="策略服务"><a href="#策略服务" class="headerlink" title="策略服务"></a>策略服务</h3><p>Fabric的许多功能需要用策略(policy)方式驱动,因此有独立的策略服务来提供系统的策略配置和管理功能。包括访问控制、授权、身份的注册、验证、隐私和保密、共识策略等。</p><h3 id="区块链服务"><a href="#区块链服务" class="headerlink" title="区块链服务"></a>区块链服务</h3><p>提供构建分布式账本最基础的能力，实现数据传输、共识达成等底层功能，并且提供发布/订阅的事件管理框架，分布式账本内部的各种事件可通知到外部监听的应用。主要包含四个组件</p><h5 id="P2P协议组件"><a href="#P2P协议组件" class="headerlink" title="P2P协议组件"></a>P2P协议组件</h5><p>主要提供区块链节点之间直接双向通信的能力，包括流式数据传输、流控制、多路复用等方面。</p><h5 id="分布式账本组件"><a href="#分布式账本组件" class="headerlink" title="分布式账本组件"></a>分布式账本组件</h5><p>维护区块链数据。该组件性能直接影响整个网络的吞吐量，因此需要较高的处理效率</p><h5 id="共识管理组件"><a href="#共识管理组件" class="headerlink" title="共识管理组件"></a>共识管理组件</h5><p>在各种公式算法之上定义里抽象的接口，可以根据场景切换公式算法</p><h5 id="账本存储组件"><a href="#账本存储组件" class="headerlink" title="账本存储组件"></a>账本存储组件</h5><p>链外存储大文件</p><h3 id="智能合约服务"><a href="#智能合约服务" class="headerlink" title="智能合约服务"></a>智能合约服务</h3><p>为合约代码提供安全的运行环境以及合约的声明周期管理</p><h1 id="网络与部署"><a href="#网络与部署" class="headerlink" title="网络与部署"></a>网络与部署</h1><p>Fabric网络由4类节点组成<br><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric节点"></p><h3 id="身份服务节点"><a href="#身份服务节点" class="headerlink" title="身份服务节点"></a>身份服务节点</h3><p>负责发放和管理用户的身份，具体来说就是在注册、交易、传输过程中使用的各类数字证书，以及区块链相关的秘钥</p><h3 id="验证节点"><a href="#验证节点" class="headerlink" title="验证节点"></a>验证节点</h3><p>创建和校验交易，并且维护智能合约的状态。在执行交易时，一般需要和其他多数的验证节点达成共识(取决于共识算法),然后才能更新本地的账本数据。每个验证节点在本地都保存一份账本的副本。</p><h3 id="非验证节点"><a href="#非验证节点" class="headerlink" title="非验证节点"></a>非验证节点</h3><p>主要是接受客户端的请求，组装交易，并发往验证节点处理，从这个角度看，非验证节点像交易预处理器，并不负责交易的实际执行。为了加速客户端的查询响应速度，非验证节点在本地也保留一份账本数据的拷贝</p><h3 id="应用节点"><a href="#应用节点" class="headerlink" title="应用节点"></a>应用节点</h3><p>主要提供用户端的后台服务，在收到请求后，把交易请求直接发往(或经由非验证节点转发)验证节点处理</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由于节点部署的多样性，应该考虑通信延迟、网络故障、节点失效、网络恢复等因素</p><h1 id="交易的执行"><a href="#交易的执行" class="headerlink" title="交易的执行"></a>交易的执行</h1><p><img src="http://pb6216bvl.bkt.clouddn.com/Fabric%E8%8A%82%E7%82%B9.JPG" alt="Fabric执行步骤"><br>交易(transaction)分两种:部署智能合约，执行智能合约</p><p>部署步骤：</p><ol><li>客户端通过API提交代码给验证节点</li><li>验证节点确认代码有效</li><li>验证节点同步到其他节点</li></ol><p>执行步骤：</p><ol><li>客户端发送执行请求给验证节点</li><li>验证节点收到请求后，向本地账本发送启动交易的指令</li><li>验证节点创建隔离的运行环境，启动应用(智能合约)代码</li><li>应用执行过程中，更新本地账本的状态</li><li>应用完成后，验证节点想本地账本确认交易</li><li>验证节点向其他验证节点广播交易</li></ol>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>智能合约基础笔记</title>
      <link href="/2018/06/30/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/30/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="智能合约简介"><a href="#智能合约简介" class="headerlink" title="智能合约简介"></a>智能合约简介</h1><h3 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h3><ol><li>法律角度，智能合约是否是一个真正意义上的合约还有待确认</li><li>计算机科学角度，智能合约是一种计算机协议，一旦制定和部署就能实现自我执行(self-executing)和自我验证(self-verifying)，而且不再需要人为的干预</li><li>技术角度，一种计算机程序，能够自主执行合约相关的操作，并产生相应的可验证的证据，来说明执行合约操作的有效性</li></ol><p>例如，银行账户的存取款可以用合约来替代，以及任何需要记录信息的场合</p><h3 id="智能合约的历史"><a href="#智能合约的历史" class="headerlink" title="智能合约的历史"></a>智能合约的历史</h3><ol><li>20世纪七八十年代，人们提出了让计算机代替人类进行商业市场管理的想法。</li><li>九十年代，研究数字合约和数字货币的Nick Szabo提出了“智能合约”</li><li>08年比特币出现，借由其背后的区块链技术，智能合约飞速发展</li></ol><h5 id="Nick-Szabo对智能合约的定义"><a href="#Nick-Szabo对智能合约的定义" class="headerlink" title="Nick Szabo对智能合约的定义"></a>Nick Szabo对智能合约的定义</h5><p>智能合约是一个由计算机处理的、可执行合约条款的交易协议。其总体目标是能够满足普通的合约条件，例如支付、抵押、保密甚至强制执行，并最小化恶意或意外事件发生的可能性、以及最小化对信任中介的需求。智能合约所要达到的相关经济目标包括降低合约欺诈所造成的损失，降低仲裁和强制执行所产生的成本以及其他交易成本等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高效的实时更新</li><li>准确执行</li><li>较低的认为干预风险</li><li>去中心化权威</li><li>较低的运行成本<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3></li><li>现实中的合同出现漏洞可以协商或者通过法律和仲裁解决，智能合约的漏洞执行后无法修补</li><li>智能合约的自我验证特性导致隐私性低</li></ol><h1 id="以太坊智能合约详解"><a href="#以太坊智能合约详解" class="headerlink" title="以太坊智能合约详解"></a>以太坊智能合约详解</h1><h3 id="合约操作流程"><a href="#合约操作流程" class="headerlink" title="合约操作流程"></a>合约操作流程</h3><ol><li>启动一个节点</li><li>编写合约</li><li>编译</li><li>部署，矿工确认。得到地址与接口</li><li>使用web3.js接口调用合约<h3 id="以太坊上的账户"><a href="#以太坊上的账户" class="headerlink" title="以太坊上的账户"></a>以太坊上的账户</h3>两类账户，公用一个空间地址。</li></ol><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="钥匙文件"><a href="#钥匙文件" class="headerlink" title="钥匙文件"></a>钥匙文件</h5><ol><li>账户通过私钥和公钥确定</li><li>账户地址是公钥的最后20个字节</li><li>账户地址和私钥密文存储在钥匙文件keyfile中</li><li>私钥总是处于加密状态，秘钥是创建账户时输入的密码</li><li>通过秘钥和keyfile中的私钥密文才能得到私钥，进行交易</li><li>要确保备份好keyfile和秘钥<h5 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h5><code>`</code>shell<br>安装客户端<br>brew install ethereum</li></ol><p>创建账户<br>geth account new</p><p>同步区块<br>geth</p><p><code>`</code></p><h5 id="账户的备份"><a href="#账户的备份" class="headerlink" title="账户的备份"></a>账户的备份</h5><p>~/Library/Ethereum/keystore/keyfile<br>这是账户数据，备份好</p><h3 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h3><p>为防止用户恶意部署无限循环运行的合约，合约执行的每一步都需要支付费用，就是gas。</p><ol><li><strong>Gas花销Gascost</strong>：针对具体操作是不变的。保证每种操作所需的计算资源保持不变</li><li><strong>Gas价格Gasprice</strong>：每个gas所需的以太币。由用户控制，价格高的确认快。并且随以太币的市值波动，以保证运行智能合约所需的真实花费不会出现大幅度变化</li><li><strong>Gasfee</strong>：Gascost*Gasprice，真实费用，单位是以太币</li></ol><h3 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h3><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>合约账户有能力向其他合约账户发送消息，它是一个虚拟的对象，不会具体的存储在以太坊的区块链内，可以看做一个函数调用的过程</p><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指外部所有账户将一个经过签名的数据包发送到另一个账户的过程，这个过程中产生的账户状态变化被存储到区块链上</p><p>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h1 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h1><h3 id="Gas的消耗"><a href="#Gas的消耗" class="headerlink" title="Gas的消耗"></a>Gas的消耗</h3><ol><li>最常见的，执行特定的内部抽象操作。例如运行SHA3散列运算</li><li>进行一个从属的消息调用或合约创建时，例如执行CREATE、CALL、CALLCODE操作</li><li>增加账户内存使用量</li></ol><p>内存使用计费机制鼓励用户使用较少的内存。执行账户内存清理操作不消耗GAS，还会得到折扣。</p><h3 id="虚拟机运行环境"><a href="#虚拟机运行环境" class="headerlink" title="虚拟机运行环境"></a>虚拟机运行环境</h3><ol><li>以太坊网络状态</li><li>合约剩余GAS</li><li>当前代码合约地址</li><li>合约发起者地址</li><li>Gasprice</li><li>交易的输入数据</li><li>执行合约交易的账户地址</li><li>合约账户的余额</li><li>用于执行虚拟机代码所需的数组</li><li>目前区块的数据头</li><li>目前执行的CALL操作和CREATE操作的数量</li></ol><h3 id="区块链系统状态的验证"><a href="#区块链系统状态的验证" class="headerlink" title="区块链系统状态的验证"></a>区块链系统状态的验证</h3><p>每产生一个新的有效区块，以太坊系统需要以下几个步骤将该区块加入权威区块链上</p><ol><li>验证新区快的ommer区块的有效性。验证叔区块？</li><li>验证新区快所包含交易的有效性，即所有交易所花费的GAS是否与新区块链中标记的花费量一致，并且每笔交易一一对应</li><li>给该区块和ommer区块的矿工发放奖励</li><li>验证新区快的工作量证明，连接主链，然后将整个系统更新</li></ol><h1 id="智能合约操作"><a href="#智能合约操作" class="headerlink" title="智能合约操作"></a>智能合约操作</h1><h3 id="钱包部署"><a href="#钱包部署" class="headerlink" title="钱包部署"></a>钱包部署</h3><p>Mist或者Eth Wallet</p><h3 id="命令行部署"><a href="#命令行部署" class="headerlink" title="命令行部署"></a>命令行部署</h3><p>通过web3.js的API在命令行部署</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Makefile笔记</title>
      <link href="/2018/06/29/makefile%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/29/makefile%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>根据指定的Shell命令进行构建的工具</p><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></p><pre><code class="makefile">pjName := wordpress# 变量docker:    docker run \        --name ${pjName} \# 容器名        --rm \# 停止运行后自动删除当前容器        -ti \# t for terminal,i for interact        -v $$(pwd):/var/www/html \# 映射当前目录到容器指定目录        -p 3000:3000 \# 映射端口到容器端口        mooxe/node \        /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell</code></pre>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker笔记</title>
      <link href="/2018/06/29/Docker%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/29/Docker%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>可以粗糙的理解为轻量级的虚拟机，把程序放在单独的环境中运行</p><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p> 获取image</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p> 创建image</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p> 列出image</p><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p> 运行container，跑一个项目</p><pre><code class="dockerfile">    docker run \        --name ${pjName} \# 容器名        --rm \# 停止运行后自动删除当前容器        -ti \# t for terminal,i for interact        -v $$(pwd):/var/www/html \# 映射当前目录到容器指定目录        -p 3000:3000 \# 映射端口到容器端口        mooxe/node \        /bin/bash# 额外加一个命令，只能加一个# 这是运行bash shell</code></pre><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p> 列出container，项目们<br> -a</p><p> 列出隐藏的</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p> 删除container</p><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><p> 删除image</p><h2 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h2><p> 在host和container之间拷贝文件</p><h2 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h2><p> 保存改动为新的image</p><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>FROM: base image</p><p>RUN: 执行命令</p><p>ADD： 添加文件</p><p>COPY： 拷贝文件</p><p>CMD： 执行命令，打包完成之后</p><p>EXPOSE： 暴露端口</p><p>WORKDIR： 指定路径</p><p>MAINTAINER: 维护者</p><p>ENV: 设定环境变量</p><p>ENTRYPOINT: 容器入口</p><p>USER: 指定用户</p><p>VOLUME: mount point</p><pre><code class="sh"># 可以指定依赖的node镜像的版本 node:&lt;version&gt;，如果不指定，就会是最新的FROM node:8.6.0# 创建工作目录，对应的是应用代码存放在容器内的路径WORKDIR /usr/src/app# 把 package.json，package-lock.json(npm@5+) 或 yarn.lock 复制到工作目录(相对路径)COPY package.json *.lock .# 只安装dependencies依赖# node镜像自带yarnRUN yarn --only=prod --registry=https://registry.npm.taobao.org# 把其他源文件复制到工作目录COPY . .# 替换成应用实际的端口号EXPOSE ${app_port}# 这里根据实际起动命令做修改CMD [ &quot;npm&quot;, &quot;start&quot; ]</code></pre><pre><code class="shell">touch Dockerfiledocker build -t hello_docker .使用.目录下的dockerfile文件创建一个叫做hello_docker的镜像，</code></pre><h1 id="使用docker步骤"><a href="#使用docker步骤" class="headerlink" title="使用docker步骤"></a>使用docker步骤</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><pre><code>&lt;!-- 拉取镜像 --&gt;docker image pull imagename&lt;!-- 查看镜像 --&gt;docker images</code></pre><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>docker commit将指定容器保存为新的镜像</p><pre><code>docker commit &lt;Container ID&gt; &lt;Name&gt;:&lt;Tag&gt;docker commit fldhsa5342hkjhs bitcoin:0.1</code></pre><p>根据dockerfile创建镜像</p><pre><code>docker build -t imagename .</code></pre><h2 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><pre><code class="sh"># 运行镜像 docker run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash# 删除容器 docker rm [containerID]</code></pre><ul><li>-p参数：容器的 3000 端口映射到本机的 8000 端口。</li><li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区块链基础知识</title>
      <link href="/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      <content type="html"><![CDATA[<h1 id="区块链简介"><a href="#区块链简介" class="headerlink" title="区块链简介"></a>区块链简介</h1><p> 去中心化的方式建立信任，不需要大机构的背书。</p><p> 区块链定义：基于区块链技术形成的公共数据库(公共账本)<br> 区块链技术：多个参与方之间基于现代密码学、分布式一致性协议、点对点网络通信技术和智能合约编程语言等形成的数据交换、处理和存储的技术组合。同时，仍在不断发展和演化中。</p><h3 id="区块链分类"><a href="#区块链分类" class="headerlink" title="区块链分类"></a>区块链分类</h3><p>从参与方的角度来分，可以分为公共链、联盟链和私有链。从链与链的关系的角度来分，可以分为主链和侧链。不同区块链还可以形成网络，网络总链与链的互联互通。产生互联链Interchain的概念</p><h5 id="公共链"><a href="#公共链" class="headerlink" title="公共链"></a>公共链</h5><p>对外公开，用户不用注册就能匿名参与。<br>比特币和以太坊都是公链。<br>也叫非许可链Permissionless Blockchain。</p><p>公链适用于虚拟货币、面向大众的电子商务、互联网金融等B2C、C2C或C2B场景</p><h5 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h5><p>联盟链Consortium Blockchain，仅限联盟成员参与。读写权限、参与记账权限按照联盟规则来制定。也叫做许可链Permissioned Blockchain.<br>例如有四十多家银行参与的R3和Linux基金会支持的超级账本Hyperleder。</p><p>联盟链适用于机构间的交易、结算或清算等B2B场景。</p><h5 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h5><p>私有组织使用，区块链上的读写权限、参与记账权限按私有组织股则来制定。应用场景一般是企业内部的应用，如数据库管理、审计。<br>把制度写在区块链上。还有政府的一些应用，比如政府的预算和执行，或者政府的行业统计数据。</p><p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范内部和外部对数据的安全攻击。</p><p>Coin Science的Multichain平台提供一个在企业内部快速部署私链的解决方案。可以用于去中心化交易所、数据库同步、货币结算、债券发行和P2P交易、消费行业积分奖励机制等场景。</p><h5 id="侧链"><a href="#侧链" class="headerlink" title="侧链"></a>侧链</h5><p>侧链是能和比特币区块链交互，并与比特币挂钩的区块链。<br>主链不易改动。<br>比特币每秒只能确认7笔交易，通过侧链Side Chains提升效率，扩展比特币功能是一个有效的做法。例如闪电网络把交易放在侧链，只有在做清算时才用上主链。矿工打包少了，回报就少了。</p><h5 id="互联链"><a href="#互联链" class="headerlink" title="互联链"></a>互联链</h5><p>针对特定领域的应用可能会形成各自垂直领域的区块链，这些区块链会有互联互通的需求，通过某种协议连接起来。可以类比互联网</p><h3 id="区块链的价值与应用"><a href="#区块链的价值与应用" class="headerlink" title="区块链的价值与应用"></a>区块链的价值与应用</h3><p>区块链技术是一揽子技术，根据业务需要可以针对性的组合和创新。<br>价值很多，很大，这个需要慢慢理解，放一放，先上手技术。</p><h1 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h5 id="数据区块"><a href="#数据区块" class="headerlink" title="数据区块"></a>数据区块</h5><p>区块结构分为区块头和区块体</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区快加上随机数的哈希值满足一定的难度条件。找到了就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。<br>然后把新节点广播出去。</p><h5 id="挖矿与分叉问题"><a href="#挖矿与分叉问题" class="headerlink" title="挖矿与分叉问题"></a>挖矿与分叉问题</h5><p>穷举随机数算法，把上个区块的哈希值加上十分钟内的全部交易单打包，再加上一个随机数，算出一个256位的字符串哈希值，输入的随机数nonce使哈希值满足一定条件就获得这个区块的交易记账权。</p><p>后续矿工总是选择累计工作量证明最大的区块链。结果就是自动抛弃分叉处的短链。</p><h5 id="时间戳与不可篡改性"><a href="#时间戳与不可篡改性" class="headerlink" title="时间戳与不可篡改性"></a>时间戳与不可篡改性</h5><p>时间戳是歌灵位置时间到现在的总秒数，通常是一个字符序列，唯一标识某一刻的时间。在比特币系统中，获得记账权的节点在链接区块时需要在区块头中加盖时间戳，用于记录当前区块数据的写入时间。</p><p>时间戳技术很简单，但意义重大，极大的增强了不可篡改性</p><h5 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h5><p>可以理解为一个分布式数据库</p><h5 id="UTXO交易模式"><a href="#UTXO交易模式" class="headerlink" title="UTXO交易模式"></a>UTXO交易模式</h5><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><h5 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h5><h5 id="双花"><a href="#双花" class="headerlink" title="双花"></a>双花</h5><ol><li>双花如何发生？</li></ol><p>花了一次，还没有上链的时候再花一次</p><ol><li>如何避免</li></ol><p>时间戳+UTXO+数字签名</p><h5 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h5><p>P2P网络是一种在peer(对等者)之间分配任务和工作负载的分布式架构，是对等计算模型在应用层形成的一种组网或网络形式。</p><p>每个节点均承担网络路由，验证数据区块等功能。根据存储数据量分为全节点和轻节点。</p><p>全节点存储了所有区块链数据，数据校验不需要别的节点，硬件成本高。</p><p>轻节点只存储部分，需要别的数据时通过建议支付验证(Simplified Payment Verification, SPV)向临近节点请求数据来完成验证更新</p><h5 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h5><p>非对称加密算法(椭圆曲线加密算法，ECC)</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名就是在信息后加上一段内容，作为发送者的证明并且证明信息没有被篡改</p><p>要传送的信息先经过哈希得到一个值，再用私钥加密得到签名。对信息进行两次操作得到签名。</p><p>接受方通过发送方的公钥解密，然后对信息哈希，然后比对，验证需要三步。</p><p>公钥锁定比特币，私钥解锁，拥有私钥才能使用。</p><h5 id="比特币的隐私模型"><a href="#比特币的隐私模型" class="headerlink" title="比特币的隐私模型"></a>比特币的隐私模型</h5><p>匿名性好一截。进行交易不需要身份信息。</p><h3 id="框架与特点"><a href="#框架与特点" class="headerlink" title="框架与特点"></a>框架与特点</h3><h5 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h5><ol><li>网络层</li></ol><p>两个部分，P2P网络和TCP/IP协议。P2P网络提供了更好的安全性，任何一个节点被攻击都不会影响整个网络</p><ol><li>数据层</li></ol><p>三个部分，公共总账本，共识算法，密码学。在数据层面上，区块链就是一个只能追加、不可更改的分布式数据库系统，是一个分布式账本。通过公式算法保持账本的一致性。通过密码学的签名和哈希算法来确保这个账本不可篡改、不能作为，并且可追溯。</p><p>同时带有经济激励的工作量证明机制，使得即使拥有51%算力的人也不会损害自身利益去发起攻击</p><ol><li>应用层</li></ol><p>三个部分，可编程货币，可编程金融，可编程社会</p><p>区块链平台提供编程环境让用户编写智能合约。通过智能合约，可以把业务规则转化成在区块链平台自动执行的合约，该合约的执行不依赖可信任的第三方上。<br>因此，智能合约可以降低合约建立、执行和仲裁中所涉及的中间机构成本。</p><h5 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h5><ol><li>去中心化</li><li>可靠数据库</li><li>开源可编程</li><li>集体维护</li><li>安全可信</li><li>准匿名性<h3 id="区块链运作的核心技术"><a href="#区块链运作的核心技术" class="headerlink" title="区块链运作的核心技术"></a>区块链运作的核心技术</h3><h5 id="区块链的连接"><a href="#区块链的连接" class="headerlink" title="区块链的连接"></a>区块链的连接</h5>区块头中上一区块的哈希值用来实现区块的连接，区块头中的随机数用来实现挖矿机制<h5 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h5>1 PoW<br>工作量证明</li></ol><p>优点： 完全去中心化，节点自由进出</p><p>缺点： 浪费大量资源，挖矿激励机制导致矿池算力集中，不去中心化了。更大的问题是，PoW机制达成共识的周期长，每秒智能作7笔交易，不适合商业应用</p><p>2 PoS</p><p>Proof of Stake，权益证明，要求节点提供拥有一定数量的代币证明来获取竞争区块链记账权的一种分布式共识机制。拥有代币越多的节点获得记账权的概率越大。为了平衡会引入其他机制。</p><p>优点： 一定程度上缩短了共识达成的时间，降低了资源浪费</p><p>缺点： 破坏者攻击网络的成本低。拥有代币数量大的节点获得记账权的几率更大，会使得网络的共识受少数富裕账户支配，从而失去公正性</p><p>3 DPoS</p><p>股份授权机制，类似于董事会投票。持股人投票选出一定数量的见证人，见证人生成区块。持股人可以随时通过投票更换这些见证人。</p><p>优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证</p><p>缺点： 选举固定数量的见证人作为记账候选人有可能不适用与完全去中心化的场景。另外在网络节点数少的场景，选举的见证人的代表性也不强。</p><p>4 分布式一致性算法<br>基于传统的分布式技术。有解决拜占庭将军问题的拜占庭容错算法，如PBFT。还有解决非拜占庭问题的分布式一致性算法(Pasox, Raft)。 目前联盟链和私有链场景中常使用。</p><p>优点： 实现妙计的快速共识机制，保证一致性</p><p>缺点： 去中心化程度不如公链上的共识机制，更适合多方参与的多中心商业模式</p><h5 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h5><p>交易的输出其实是指向一个脚本，而不是地址。它类似一套规则，约束着接收方怎样才能划掉这个输出上锁定的资产。</p><p>交易的合法性也依赖于脚本。锁定脚本和解锁脚本。</p><p>比特币的脚本机制相对简单，不能实现复杂的逻辑。但为后来者们提供了可编程区块链的原型。</p><h5 id="交易规则"><a href="#交易规则" class="headerlink" title="交易规则"></a>交易规则</h5><h5 id="交易优先级"><a href="#交易优先级" class="headerlink" title="交易优先级"></a>交易优先级</h5><h5 id="Merkle证明"><a href="#Merkle证明" class="headerlink" title="Merkle证明"></a>Merkle证明</h5><p>Merkle树的重要使用场景是快速支付验证。轻节点只下载区块头，数据大小为80字节。</p><p>能证明包含的交易，但无法证明任何当前的状态。</p><p>以太坊中有三棵树，分别对应交易transactions，收据recipts和状态State</p><h5 id="RLP"><a href="#RLP" class="headerlink" title="RLP"></a>RLP</h5><p>Recursive Length Prefix，递归长度前缀编码，是以太坊中对象序列化的一个主要编码方式。先放着</p><h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><ol><li>交易的生成：新交易创建</li><li>交易的传播：交易通过P2P网络传播</li><li>工作量证明：交易验证</li><li>整个网络节点验证：3的验证结果在P2P网络中传播</li><li>记录到区块链：交易写入账本</li></ol>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>比特币基础知识</title>
      <link href="/2018/06/29/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
      <url>/2018/06/29/%E6%AF%94%E7%89%B9%E5%B8%81/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="比特币特性"><a href="#比特币特性" class="headerlink" title="比特币特性"></a>比特币特性</h3><h5 id="硬通货"><a href="#硬通货" class="headerlink" title="硬通货"></a>硬通货</h5><p>跨境交易</p><h5 id="易携带"><a href="#易携带" class="headerlink" title="易携带"></a>易携带</h5><p>只需一个私钥</p><h5 id="私密性"><a href="#私密性" class="headerlink" title="私密性"></a>私密性</h5><ol><li>只暴露钱包地址</li><li>非法应用</li></ol><h5 id="无货币超发"><a href="#无货币超发" class="headerlink" title="无货币超发"></a>无货币超发</h5><p>通货紧缩</p><ol><li>去中心化，P2P分布式的数字货币系统</li><li>共识机制 - POW工作量证明</li><li>非对称密码学，公钥私钥</li><li>区块链作为账本</li></ol><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>比特币就是UTXO，<br>交易UTXO + 区块链 = 比特币系统</p><h3 id="POW共识机制"><a href="#POW共识机制" class="headerlink" title="POW共识机制"></a>POW共识机制</h3><p>proof of work<br>通过挖矿保证我是个善意的节点，并获得生成区块，和在这个区块里记账的权利</p><h3 id="区块的生成和连接"><a href="#区块的生成和连接" class="headerlink" title="区块的生成和连接"></a>区块的生成和连接</h3><ol><li>比特币由挖矿而产生，通过计算出一个算计数字nonce</li><li>生成的BTC被记录在矿工名下，通过矿工的公钥的哈希值锁定</li><li>交易的输出被称为UTXO，unspent transaction output,未花费交易</li><li>比特币钱包余额就是根据众多UTXO计算出来的</li><li>新区块通过包含前一个区块头部的哈希值建立链接关系。</li><li>区块链有时会产生临时的分叉而生成两条链，最终较短的链将被舍弃</li></ol><h3 id="UTXO的生成和销毁"><a href="#UTXO的生成和销毁" class="headerlink" title="UTXO的生成和销毁"></a>UTXO的生成和销毁</h3><p>交易包含三项，</p><ol><li>交易的输入，UTXO指针</li><li>交易的输出，UTXO</li><li>解锁脚本，私钥签名，公钥</li></ol><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区块链中的密码学技术</title>
      <link href="/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>一类数学函数，在有限合理的时间内，将任意长度的消息压缩为固定长度的二进制串，其输出值成为哈希值。长用于实现数据完整性和实体认证。</p><p>在比特币系统中，基于寻找给定前缀的SHA256哈希值，设计了工作量证明的共识机制</p><h3 id="哈希算法的性质与应用"><a href="#哈希算法的性质与应用" class="headerlink" title="哈希算法的性质与应用"></a>哈希算法的性质与应用</h3><h5 id="抗碰撞性"><a href="#抗碰撞性" class="headerlink" title="抗碰撞性"></a>抗碰撞性</h5><p>就是 两个信息具有相同的哈希值是不可能的</p><h5 id="原像不可逆"><a href="#原像不可逆" class="headerlink" title="原像不可逆"></a>原像不可逆</h5><p>不能根据哈希值推导出原值</p><h5 id="难题友好性"><a href="#难题友好性" class="headerlink" title="难题友好性"></a>难题友好性</h5><p>没有便捷的方式去产生一个特定要求的哈希值，只能穷举。</p><h3 id="哈希指针链"><a href="#哈希指针链" class="headerlink" title="哈希指针链"></a>哈希指针链</h3><p>用于验证信息是否发生改变。区块链可以看做一类使用哈希指针的链表。</p><h1 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h1><p>一类基于哈希值的二叉树或多叉树。<br>区块链中的Merkle树是二叉树，用于存储交易信息。</p><p>叶子： 数据块的哈希值</p><p>节点： 孩子节点的哈希值</p><p>用于检测数据副本的一致性，以减少传输的数据量。</p><h1 id="公钥密码算法"><a href="#公钥密码算法" class="headerlink" title="公钥密码算法"></a>公钥密码算法</h1><h3 id="椭圆曲线密码算法"><a href="#椭圆曲线密码算法" class="headerlink" title="椭圆曲线密码算法"></a>椭圆曲线密码算法</h3><h3 id="secp256k1椭圆曲线"><a href="#secp256k1椭圆曲线" class="headerlink" title="secp256k1椭圆曲线"></a>secp256k1椭圆曲线</h3><h3 id="椭圆曲线签名与验证签名"><a href="#椭圆曲线签名与验证签名" class="headerlink" title="椭圆曲线签名与验证签名"></a>椭圆曲线签名与验证签名</h3><p>先放一放，现在不感兴趣。等需要的时候再来学</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>敏捷编码</title>
      <link href="/2018/06/23/%E6%95%8F%E6%8D%B7%E7%BC%96%E7%A0%81/"/>
      <url>/2018/06/23/%E6%95%8F%E6%8D%B7%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本文为《敏捷开发修炼之道》中敏捷编码一章的总结</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>随着项目变大变复杂，不恰当的编码会让后期的开发变得困难。所以有必要在早期就践行正确的代码编写方式。</p><ol><li>代码要清晰地表达意图</li><li>用代码沟通</li><li>动态评估取舍</li><li>增量式编程</li><li>保持简单</li><li>编写内聚的代码</li><li>告知，不要询问</li><li>根据契约进行替换</li></ol><h1 id="代码要清晰地表达意图"><a href="#代码要清晰地表达意图" class="headerlink" title="代码要清晰地表达意图"></a>代码要清晰地表达意图</h1><p>PIE(Program Intently and Expressively)原则，意图清晰，表达明确</p><ol><li>充分语义化，尽量不看定义也能明白</li><li>使用方法名传达意向，方法参数名帮助读者理解背后的想法</li><li>正确的使用和命名异常</li><li>使用语言特性提升表现力</li><li>好的编码规范可以让代码容易理解，同时减少不必要的注释和文档</li><li>编写清晰而不是讨巧的代码，比如位移操作可读性就不好</li><li>想象一年后的自己来阅读代码，读一次就能明白</li><li>有意图的编程不是创建更多的类或者类型，这不是过分抽象的理由</li><li>使用合适的耦合。例如，通过散列表进行松耦合。散列表存储紧密耦合的组件没有明确的表示意图</li></ol><h1 id="用代码沟通"><a href="#用代码沟通" class="headerlink" title="用代码沟通"></a>用代码沟通</h1><p>读代码的方式：先阅读注释，然后快速浏览代码。从而理解它做了什么，为什么这么做</p><p>建立代码文档有两种方式，利用代码本身以及利用注释来沟通代码之外的事情</p><p>适当的注释和良好的代码能让人快速理解代码。知道代码的意图，结果和需要注意的地方。</p><h3 id="优雅清晰的代码"><a href="#优雅清晰的代码" class="headerlink" title="优雅清晰的代码"></a>优雅清晰的代码</h3><p>优雅的代码易于辨识和理解，简洁，第一眼看上去就知道它的用处</p><ol><li>变量名运用正确</li><li>空格使用得当</li><li>逻辑分离清晰</li><li>表达式简洁</li><li>清晰的执行路径</li></ol><h5 id="好名字"><a href="#好名字" class="headerlink" title="好名字"></a>好名字</h5><ol><li>好名字向读者传递大量信息，不好的名字无法传递信息，糟糕的名字传递错误的信息</li><li>遵循习惯用法。比如i表示循环索引量，s表示字符串</li></ol><h3 id="适当的注释"><a href="#适当的注释" class="headerlink" title="适当的注释"></a>适当的注释</h3><ol><li>克制在方法体内部的注释。</li><li>为读者指定一条正确的代码访问路线图</li><li>为代码中的每个类或模块添加一个短小的描述，说明目的以及要求</li><li>对于类中的每个方法，可能要说明四点。目的，输入，输出和异常</li><li>注释不能替代优秀的代码</li><li>在代码可以传递意图的地方不要使用注释</li><li>解释代码做了什么的注释用处不大。注释要说明为什么这样做</li><li>重写方法时，保留描述原有方法意图和约束的注释</li></ol><h1 id="动态评估取舍"><a href="#动态评估取舍" class="headerlink" title="动态评估取舍"></a>动态评估取舍</h1><p><strong>错误观点</strong>：性能、生产力、优雅、成本、以及上市时间，在软件开发过程中都是至关重要的因素，每一项都必须达到最理想状态<br><strong>正确观点</strong>：如果性能表现足够了，就把注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化</p><ul><li>由用户或者利益相关者来评估性能是否足够，界面是否吸引人</li><li>即使不能面面俱到，你也应该得到最重要的东西——客户认为有价值的特性</li><li>如果现在要投入额外的资源和精力是为了将来可能得到的好处，那么要确认投入一定要得到回报</li><li>真正的高性能系统，从一开始设计时就在向这个方向努力</li><li>过早的优化是万恶之源</li></ul><h1 id="增量式编程"><a href="#增量式编程" class="headerlink" title="增量式编程"></a>增量式编程</h1><p><strong>在很短的编辑/构建/测试循环中编写代码</strong>，可以创建更加清晰、简单、易于维护的代码</p><p>采取增量式编程，会更倾向于创建更小的方法和更具内聚性的类</p><ul><li>如果构建和测试花费的时间过长，你就不会经常运行它们了。要保证测试可以快速运行</li><li>在编译和测试中，停下来想一想，并暂时远离代码细节，这是保证不会偏离正确方向的好办法</li><li>要像重构代码一样重构测试，并且经常重构测试</li></ul><h1 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h1><ul><li>不要过度设计</li><li>开发可以工作的、最简单的解决方案。就是没有一行多余代码，并且仍能交付全部功能</li><li>使用模式、原则和高难度技术要有明确的目的</li><li>代码几乎总可以得到进一步精炼，但是到了某个点之后，再做改进就不会带来实质性的好处了。这时就改停下来去做其他的事情了</li><li>强行让代码变得优雅与过早优化一样，会产生恶劣的影响</li><li>简单不是在功能上妥协</li><li>简单不是单纯的代码量少，要兼顾可读性</li><li>一个人认为简单的东西，可能对另一个人意味着复杂</li></ul><h1 id="编写内聚的代码"><a href="#编写内聚的代码" class="headerlink" title="编写内聚的代码"></a>编写内聚的代码</h1><p>内聚性用来评价一个组件中成员的功能相关性。内聚性高说明各成员共同完成了一个或一组功能特性</p><p>好处：</p><ol><li>稳定，维护成本低</li><li>可重用性高</li><li>责任清晰，易跟踪，易修改</li></ol><p>方法：</p><ul><li>在创建一个类的时候，想一下，这个类的功能是否与其他类的功能相似</li><li>让类的功能尽量集中，组件尽量小，避免创建很大的类</li><li>拆分太小也不行。</li></ul><h1 id="告知，不要询问"><a href="#告知，不要询问" class="headerlink" title="告知，不要询问"></a>告知，不要询问</h1><p>作为某段代码的调用者，开发人员绝不应该基于<em>被调用对象的状态</em>来做任何决策，更<em>不能改变该对象的状态</em>，这是被调用对象的责任。在对象之外替他做决策，违反了封装原则，而且为bug提供了土壤。</p><p>这一条我没理解。想象不出场景</p><h1 id="根据契约进行替换"><a href="#根据契约进行替换" class="headerlink" title="根据契约进行替换"></a>根据契约进行替换</h1><p>替换组件代码，其他代码无感知</p><p>通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。委托比继承灵活</p>]]></content>
      
      <categories>
          
          <category> 程序员修养 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>合作的进化</title>
      <link href="/2018/06/17/%E5%90%88%E4%BD%9C%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
      <url>/2018/06/17/%E5%90%88%E4%BD%9C%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>博弈论经典之作。罗小蔓解读。</p><h1 id="囚徒困境"><a href="#囚徒困境" class="headerlink" title="囚徒困境"></a>囚徒困境</h1><p>从个人利益来说，背叛比合作好。从共同利益来说，合作比背叛好。<br>“重复囚徒困境”就是背叛还是合作的选择会进行多次</p><h1 id="一报还一报策略"><a href="#一报还一报策略" class="headerlink" title="一报还一报策略"></a>一报还一报策略</h1><p>一句话总结就是，合作就奖励，背叛就惩罚。</p><p>它有四个优点。</p><ol><li>善良性：在一开始主动释放善意</li><li>报复性：坚持自己的原则，对合作和背叛都给与相应的回报</li><li>宽容性：对给背叛者改正的机会</li><li>清晰性：通过善意与规则清楚地传达合作意愿</li></ol><h1 id="利益"><a href="#利益" class="headerlink" title="利益"></a>利益</h1><p>追逐自身利益是个体的本能，因此想要鼓励合作的产生，最好的办法就是让合作带来的利益大于背叛能够带来的。</p><p>如果想要委婉一些或者降低成本，可以增加合作的步骤，给双方制造更多互相报复的机会，避免一锤子买卖。忌惮于对方的报复，就会更倾向于合作。</p><h1 id="信誉"><a href="#信誉" class="headerlink" title="信誉"></a>信誉</h1><p>信誉不只有诚信度，还包括行事风格，是宽容大度的老好人还是报复心中的小心眼。老好人容易吸引爱占便宜的坏蛋。</p><p>良好的信誉既能吸引好的合作方，也会警告哪些爱占便宜的人与你保持距离</p><h1 id="促进合作的条件"><a href="#促进合作的条件" class="headerlink" title="促进合作的条件"></a>促进合作的条件</h1><ol><li>增加未来对现在的影响，增加基础频率</li><li>提高合作收益，未来收益大于眼前收益的2/3</li><li>塑造信誉，一报还一报</li></ol><h1 id="维持合作的方法"><a href="#维持合作的方法" class="headerlink" title="维持合作的方法"></a>维持合作的方法</h1><ol><li>不要嫉妒</li><li>不刷小聪明</li><li>对合作和背叛都要给与回报</li></ol>]]></content>
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>iterm快捷键总结</title>
      <link href="/2018/06/04/iterm/"/>
      <url>/2018/06/04/iterm/</url>
      <content type="html"><![CDATA[<p>iterm2的快捷键总结</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>新建tab：⌘ + t</p><p>切换 tab： ⌘+←, ⌘+→</p><p>​ ⌘+{, ⌘+}</p><p>​ ⌘ + Num</p><p>切换全屏：⌘ + enter</p><p>关闭tab：⌘ + w</p><h1 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h1><p>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分；</p><p>切换Tab中的pane：⌘ + [ / ]</p><p>按方向切换 pane：⌘+Option+方向键</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次则还原</p><p>关闭panel：⌘ + w</p><h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><p>智能查找，支持正则查找：⌘+f</p><p>全屏展示所有的 tab，可以搜索：⌘+Option+e</p><p>自动填充：⌘ + ； 命令补全提示</p><p>打开最近目录： ⌘ + alt + /</p><p>窗口太多，快速定位到光标所在位置：⌘ + /</p><p>鼠标所在行高亮显示： ⌘ + alt + ；</p><p>⌘+Option可以以矩形选中，类似于vim中的ctr l+ v操作</p><p>⌘+Shift+h弹出历史记录窗口</p><p>快照返回功能：按下 Cmd + Option + B 就会在界面上显示一个时间轴，按下键盘的左右箭头，时间轴就会自由的穿梭，这时 iTerm 上的命令行界面也随着变化成你选中的时间点的内容了</p><p>双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。选中即复制。</p><h1 id="按住⌘键"><a href="#按住⌘键" class="headerlink" title="按住⌘键"></a>按住⌘键</h1><p>可以拖拽选中的字符串</p><p>可以点击 url：调用默认浏览器访问该网址</p><p>可以点击文件：调用默认程序打开文件</p><p>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行</p><p>点击文件夹：在 finder 中打开该文件夹</p><h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><p>设置标记：⌘ + shift + m</p><p>跳转到上个标记：⌘ + shift + j</p><p>多个标记切换：⌘ + shift + arrow(上下)</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>置空屏幕: clear</p><p>​ ctrl + l</p><p>​ ⌘ + k</p><p>清空屏幕: command + k/r</p><p>字体调大: command + +</p><p>字体调小: command + -</p><p>清除当前行：ctrl + u</p><p>到行首：ctrl + a</p><p>到行尾：ctrl + e</p><p>从光标处删至字首/尾：ctrl + w / k</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>区块链架构</title>
      <link href="/2018/05/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/05/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>这里有一段很好的关于架构的讲述，就不完整的抄了</p><p>架构有两层含义，静态的和动态的。静态层面主要勾画系统边界、结构、组成的组件以及组件之间的关联关系。动态层面主要规范组件的行为以及组件之间的交互协议。根据系统的架构，可以界定系统的功能特性和非功能特性。<br>功能特性是特点，非功能特性是不可缺少的共性部分。</p><p>架构设计要考虑不断变化和恒久不变的两方面。</p><p>一个有长久生命力的系统都有一个设计高明的架构，其精髓在于架构能支持系统功能的变化、发展、演化，允许系统功能不断变化，也就是架构必须提供灵活性。</p><p>而系统对易用性、安全性、稳定性和性能却应该是恒久不变的，因此IT架构的设计必须强调非功能特性，其中</p><ol><li>开放性</li><li>可扩展性</li><li>可移植性</li><li>可维护性</li><li>灵活性</li><li>安全性</li><li>性能(响应时间、吞吐率、并发数)</li></ol><h3 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h3><p> 例如比特币，支撑虚拟货币应用，也就是与转账、汇款和数字化支付相关的密码学货币应用。</p><h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><p> 2.0支撑智能合约应用，合约是经济、市场和金融的区块链应用的基石。2.0应用包括股票、债券、期货、贷款、抵押、产权、智能财产和智能合约。</p><h3 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h3><p> 超越货币、金融和市场的范围的去中心化应用，特别是在政府、健康、科学、文化和艺术领域的应用。</p><h1 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h1><h3 id="比特币前端"><a href="#比特币前端" class="headerlink" title="比特币前端"></a>比特币前端</h3><h5 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h5><p>保存用户的私钥数据库，管理用户余额，提供比特币交易(支付、转账)。</p><p>签名、钱包加密、备份、密钥导入、导出。</p><p>钱包分为两种，非决定性和决定性的。决定性(deterministic)指的是私钥是否有种子生成。</p><p>非决定性钱包： 直接保存私钥，私钥数据保存在Berkeley DB上。安全性不高。比特币核心带有一个非决定性钱包，不推荐使用。</p><p>决定性钱包： 所有私钥都由一个私钥种子(Seed)通过单向哈希算法生成。通过种子生成私钥，因此备份容易。又分为普通决定性钱包和层级决定性钱包。</p><p>根据部署场景分为，移动钱包，桌面钱包，互联网钱包以及纸钱包。</p><ol><li>移动钱包就是移动端的钱包，因为资源有限，多数采用SPV来验证交易。</li><li>桌面钱包分厚钱包Thick Wallet和薄钱包Thin Wallet。厚钱包下载整条区块链，进行完整的交易校验。比特币核心Bitcoin Core就是厚钱包。提供完整的钱包功能。厚钱包安全性高，交易开销大，适合大额交易。薄钱包灵活性高，安全性不高，适合小额交易</li><li>互联网钱包。依托第三方平台提供对用户隐私的保护，使用灵活，安全性不高。</li><li>纸钱包，字面意思</li></ol><h5 id="HTTP-JSON-RPC-API"><a href="#HTTP-JSON-RPC-API" class="headerlink" title="HTTP/JSON RPC API"></a>HTTP/JSON RPC API</h5><p>API，给外部提供查询余额，支付和转账的接口</p><h5 id="命令行工具bitcoin-cli"><a href="#命令行工具bitcoin-cli" class="headerlink" title="命令行工具bitcoin-cli"></a>命令行工具bitcoin-cli</h5><p>基于API开发的命令行工具</p><h5 id="比特币浏览器bx"><a href="#比特币浏览器bx" class="headerlink" title="比特币浏览器bx"></a>比特币浏览器bx</h5><p>比命令行工具更强大的工具</p><h5 id="图形开发工具Qt"><a href="#图形开发工具Qt" class="headerlink" title="图形开发工具Qt"></a>图形开发工具Qt</h5><p>比特币核心是Qt开发的，是比特币使用最广的客户端</p><h3 id="比特币节点后端"><a href="#比特币节点后端" class="headerlink" title="比特币节点后端"></a>比特币节点后端</h3><p>比特币节点后台负责参与比特币网络的通信互联，维护区块链，验证区块、交易，广播、转播传递区块交易信息。比特币后台主要是bitcoind，以及挖矿节点程序。比特币核心bitcoin-qt实际上是包含前后端的一体化节点(挖矿功能除外)。</p><h5 id="区块链管理"><a href="#区块链管理" class="headerlink" title="区块链管理"></a>区块链管理</h5><p>区块链管理涉及初始区块链下载、连接区块、断开区块、校验区块和保存区块，以及发现最长链条的顶区块。</p><ol><li>下载区块链，先下区块头，再并发下载区块体</li><li>接收区块链，节点在开始时将整个区块链的索引从LevelDB调进内存。索引不是单跳的链，在末端可能会形成树，因为会分叉。这一步将新的加点加入树的末梢。</li><li>区块链验证，这一步比较复杂，验证完之后，新的区块就被加入到这个节点的链中了</li><li>重组区块链，节点发现一条更长的链会断开重组。会更改UTXO，被断开的区块中交易会会退到交易内存池(mempool)，用回滚记录来断开区块中的交易<h5 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h5>比特币的一个很大的创新是依靠脚本来验证交易的合法性，即每一个将要花掉的比特币必须有相应的来源。</li></ol><p>脚本是基于堆栈的一些命令。</p><h5 id="内存池管理"><a href="#内存池管理" class="headerlink" title="内存池管理"></a>内存池管理</h5><p>mempool也就是交易池管理。节点将通过验证的交易放在一个交易池中，准备放在一个挖到的区块中。当矿工挖到一个合格的区块后，他将按一定的优先级从交易池中选出交易放到区块中。优先级按UTXO的链龄和交易额的大小来划分。当区块填满后，剩下的交易会留在内存池。</p><p>内存池的交易不保存在硬盘上，当挖矿节点重启时，内存池的交易会被清空。如果在一定时间内一个交易一直不能被矿工包括在区块链上，钱包软件需要重新发送该交易，并附上较高的交易费。</p><h5 id="邻节点管理"><a href="#邻节点管理" class="headerlink" title="邻节点管理"></a>邻节点管理</h5><p>当一个新节点做初始启动(bootstrap)的时候，它需要发现网络中的其他节点，并与至少一个节点连接。一般是与一个已知的节点在8333端口建立TCP连接。连接的握手流程发送一个版本信息。对方回复确认消息。</p><p>发现邻节点的方法。</p><ol><li>用DNS种子查询DNS。比特币核心带有5个DNS种子</li><li>把一个已知的邻节点作为种子节点。<h5 id="共识管理"><a href="#共识管理" class="headerlink" title="共识管理"></a>共识管理</h5>比特币的关键是在陌生P2P环境监理共识机制。</li></ol><p>比特币中广义的共识管理(consensus)包括挖矿、区块验证和交易验证规则。但这些功能实现分散在不同的程序中。社区在尝试将其独立。</p><p>比特币的共识管理必须向前兼容，即使过去有bug也要保持，否则比特币网络会出现分叉。</p><h5 id="规则管理"><a href="#规则管理" class="headerlink" title="规则管理"></a>规则管理</h5><p>比特币的共识规则是所有节点都必须遵守的规则。而每个节点可以采用一些共识规则以外的个性化规则。这部分的规则有规则管理模块实现。比如一个节点可以拒绝保存、中转大于200KB的交易。另外像对交易费用的一些规则。也可以通过规则模块来管理</p><h5 id="密码模块"><a href="#密码模块" class="headerlink" title="密码模块"></a>密码模块</h5><p>crypto模块主要是处理比特币地址。</p><p>私钥产生公钥。公钥经过几步产生地址</p><ol><li>SHA256哈希处理</li><li>RIPEMD160哈希处理得到一个160位的结果</li><li>Base58Check编码</li></ol><p>Base58Check的校验码对地址信息进行双重SHA256哈希处理，并取前4位做校验码，加载比特币地址的后面，因此比特币地址带有校验信息，可以防止人为错误</p><h5 id="签名模块"><a href="#签名模块" class="headerlink" title="签名模块"></a>签名模块</h5><p>比特币采用椭圆曲线数字签名算法(ECDSA)来实现数字签名及生成公钥。这是一种非对称加密算法，是基于椭圆曲线离散对数问题的计算困难性的一种公钥密码的方法。</p><p>secp256k1曲线比其他曲线具有更高的性能。</p><h5 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h5><p>基于堆栈的运算平台，非图灵完备。不能跳转，只能执行一次。<br>这样设计是不希望矿工有能力提交一个可能有死循环的脚本。</p><p>比特币作为一个虚拟货币系统，这样的设计已经足够。</p><h5 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h5><p>中本聪当初设计比特币的目标是建立一个完全去中心化的虚拟货币，采用一个CPU一票的理念。后面的矿池是他没有预料到的。</p><p>CPU&gt;GPU&gt;FPCA&gt;ASIC</p><h5 id="HTTP-JSON-RPC-服务端"><a href="#HTTP-JSON-RPC-服务端" class="headerlink" title="HTTP/JSON RPC 服务端"></a>HTTP/JSON RPC 服务端</h5><p>提供接口来控制比特币节点</p><h5 id="Berkeley-DB和LevelDB数据库"><a href="#Berkeley-DB和LevelDB数据库" class="headerlink" title="Berkeley DB和LevelDB数据库"></a>Berkeley DB和LevelDB数据库</h5><p>Berkeley DB做钱包数据库，这是一个开源的文件数据库。介于关系数据库和内存数据库之间。比特币的数据作为文件类型放在硬盘上。</p><p>LevelDB用来存储区块的索引和UTXO记录。它是KV数据库。它的数据是冗余数据，可以用原始区块链数据来重建，但是非常慢。</p><h5 id="P2P网络管理"><a href="#P2P网络管理" class="headerlink" title="P2P网络管理"></a>P2P网络管理</h5><p>在P2P网络上实现和其他邻接点的通信功能</p><h5 id="ZMQ队列管理"><a href="#ZMQ队列管理" class="headerlink" title="ZMQ队列管理"></a>ZMQ队列管理</h5><p>采用Zero MQ作为消息队列管理和消息分发工具。这是一个简单好用的传输层，提供像框架一样的一个socket library，是个socket编程更加简单。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="3-0-超越货币，金融范围的区块链应用"><a href="#3-0-超越货币，金融范围的区块链应用" class="headerlink" title="3.0 超越货币，金融范围的区块链应用"></a>3.0 超越货币，金融范围的区块链应用</h1><p>超宇货币和金融范围，特别是政府、健康、科学、工业、文化和艺术的应用<br>支持广义资产、广义交换、支持行业应用。<br>支持行业应用意味着具备企业级属性。其中安全性最突出。同时对网络和共识算法的性能、每秒交易数TPS都有比较高的要求。可以不是完全去中华的架构，最有可能是在不同场景下的混合架构。</p><h3 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h3><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h3><h5 id="自动化采购"><a href="#自动化采购" class="headerlink" title="自动化采购"></a>自动化采购</h5><h5 id="智能化物联网应用"><a href="#智能化物联网应用" class="headerlink" title="智能化物联网应用"></a>智能化物联网应用</h5><h5 id="供应链自动化管理"><a href="#供应链自动化管理" class="headerlink" title="供应链自动化管理"></a>供应链自动化管理</h5><h5 id="虚拟资产兑换、转移"><a href="#虚拟资产兑换、转移" class="headerlink" title="虚拟资产兑换、转移"></a>虚拟资产兑换、转移</h5><h5 id="产权登记"><a href="#产权登记" class="headerlink" title="产权登记"></a>产权登记</h5><h1 id="互联链架构剖析"><a href="#互联链架构剖析" class="headerlink" title="互联链架构剖析"></a>互联链架构剖析</h1><p>不同链的价值转移</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>共识算法详解</title>
      <link href="/2018/05/26/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/26/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>共识算法的结果，确定一个在一段时间内拥有记账权的唯一节点</p><p>共识算法的假设条件有以下几种，</p><ol><li>故障模型： 非拜占庭故障/拜占庭故障</li><li>通信模型： 同步/异步</li><li>通信网络连接： 节点间直连数</li><li>信息发送者身份： 实名/匿名</li><li>通信通道稳定性： 通道可靠/不可靠</li><li>消息认证性： 认证消息/非认证消息</li></ol><p>由于应用场景的不同，所设计的目标各异，不同的区块链系统采用了不同的共识算法。一般来说，私有链和联盟链对一致性、正确性要求更高，一般采用强一致性的共识算法。公有链对一致性和正确性通常没法做到百分之百，通常采用最终一致性Eventual Consistency的共识算法。</p><h1 id="拜占庭容错技术"><a href="#拜占庭容错技术" class="headerlink" title="拜占庭容错技术"></a>拜占庭容错技术</h1><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><h3 id="拜占庭容错系统"><a href="#拜占庭容错系统" class="headerlink" title="拜占庭容错系统"></a>拜占庭容错系统</h3><h3 id="实用的拜占庭容错系统"><a href="#实用的拜占庭容错系统" class="headerlink" title="实用的拜占庭容错系统"></a>实用的拜占庭容错系统</h3><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><h5 id="Raft基础"><a href="#Raft基础" class="headerlink" title="Raft基础"></a>Raft基础</h5><h5 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h5><h5 id="记账过程"><a href="#记账过程" class="headerlink" title="记账过程"></a>记账过程</h5><h1 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h1><p>一句话解释，根据投入的算力来选择记账节点</p><p>会导致算力浪费</p><p>穷举法找到一个符合要求的哈希值。</p><h3 id="工作量证明函数"><a href="#工作量证明函数" class="headerlink" title="工作量证明函数"></a>工作量证明函数</h3><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><h3 id="难度值"><a href="#难度值" class="headerlink" title="难度值"></a>难度值</h3><h3 id="PoW的过程"><a href="#PoW的过程" class="headerlink" title="PoW的过程"></a>PoW的过程</h3><h3 id="基于PoW的共识记账"><a href="#基于PoW的共识记账" class="headerlink" title="基于PoW的共识记账"></a>基于PoW的共识记账</h3><h3 id="关于比特币PoW能否解决拜占庭将军的问题"><a href="#关于比特币PoW能否解决拜占庭将军的问题" class="headerlink" title="关于比特币PoW能否解决拜占庭将军的问题"></a>关于比特币PoW能否解决拜占庭将军的问题</h3><h1 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h1><p>一句话解释，根据拥有的货币数量来算则记账节点</p><p>会导致中心化</p><p>用户证明拥有某些数量的货币(即对货币的权益)</p><h3 id="PoS的应用"><a href="#PoS的应用" class="headerlink" title="PoS的应用"></a>PoS的应用</h3><p>点点币结合币龄</p><h3 id="随机区块选择"><a href="#随机区块选择" class="headerlink" title="随机区块选择"></a>随机区块选择</h3><p>NXT和blackcoin采用随机方法预测下一合法区块，使用公式查找与权益大小结合的最小哈希值</p><h3 id="基于权益速度的选择"><a href="#基于权益速度的选择" class="headerlink" title="基于权益速度的选择"></a>基于权益速度的选择</h3><p>Reddcoin引入权益速度证明，即鼓励钱币的流动而非囤积。通过给币龄引入指数衰减函数，使得币龄不会超过2币月</p><h1 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h1><p>股份授权证明机制 Delegated Proof of Stake,期望通过引入一个技术民主层来减少中心化的负面影响</p><p>持股人投票选出见证人。见证人按序生成区块。</p><h1 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h1><p>基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。</p><p>参与投票节点的身份是事先知道的，因此算法的效率比PoW高，交易的确认只需要几秒钟。<br>这点也决定了它只适合权限链。</p><p>容忍20%的拜占庭错误</p><h3 id="Ripple的网络结构"><a href="#Ripple的网络结构" class="headerlink" title="Ripple的网络结构"></a>Ripple的网络结构</h3><h3 id="Ripple共识算法-1"><a href="#Ripple共识算法-1" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><h1 id="小蚁共识机制"><a href="#小蚁共识机制" class="headerlink" title="小蚁共识机制"></a>小蚁共识机制</h1><p>PoW、PoS、DPoS确定谁有记账权。小蚁侧重于解决如何限制记账人权利的问题。这种记账机制被称为中性记账。记账人只有选择是否参加的权利，而不能改变交易数据，不能认为排除某笔交易，也不能对交易排序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PoW安全性和公平性强一些。PoS和DPoS更环保高效。</p><p>PoW和PoS比较适合公共链环境，PBFT和Raft适合联盟链和私有链的分布式环境。</p><p>比特币的PoW机制是一种概念性的拜占庭协议，能在一定程度上解决拜占庭问题，而PoS等其他机制 并没有严格分析其在拜占庭协议方面的属性。</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>以太坊笔记</title>
      <link href="/2018/05/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
      <url>/2018/05/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A/</url>
      <content type="html"><![CDATA[<p>以太坊有账户的概念，可以实时查看指定地址的账户情况和交易状态。<br>比特币没有账户的概念，只有UTXO。需要计算。</p><h1 id="以太坊架构"><a href="#以太坊架构" class="headerlink" title="以太坊架构"></a>以太坊架构</h1><p>智能合约部署在以太坊虚拟机上，通过虚拟机和RPC接口和底层区块链进行交互</p><p>核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用。</p><h3 id="账户设计"><a href="#账户设计" class="headerlink" title="账户设计"></a>账户设计</h3><p>两种账户。外部所有账户EOA和合约账户。</p><p>以太坊的设计是将区块链作为一个通用的管理对象状态的去中心化平台，账户就是有状态的对象。</p><p>合约账户可以执行图灵完备的计算任务，也可在合约账户之间传递消息，合约编译成EVM字节码。并记录在区块链上。</p><h3 id="区块链设计"><a href="#区块链设计" class="headerlink" title="区块链设计"></a>区块链设计</h3><p>Merkle Patricia树</p><h3 id="PoW机制"><a href="#PoW机制" class="headerlink" title="PoW机制"></a>PoW机制</h3><p>Ethash工作量证明机制加入内存难度，使得它具有抵抗单凭哈希运算优化的ASIC挖矿机的属性。每30000个区块需要一个全新的DAG，有向无环图。</p><h3 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h3><h3 id="EVM高级语言"><a href="#EVM高级语言" class="headerlink" title="EVM高级语言"></a>EVM高级语言</h3><h3 id="以太坊P2P网络"><a href="#以太坊P2P网络" class="headerlink" title="以太坊P2P网络"></a>以太坊P2P网络</h3><p>节点间使用RLPx协议，Dapp间用Whisper协议</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约是在区块验证的时候被交易触发。以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。事件利用现有的ABI功能来解析日志记录。</p><h1 id="以太坊技术"><a href="#以太坊技术" class="headerlink" title="以太坊技术"></a>以太坊技术</h1><h3 id="以太坊核心概念"><a href="#以太坊核心概念" class="headerlink" title="以太坊核心概念"></a>以太坊核心概念</h3><h5 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h5><p>由许多互联的计算机组成。程序按照EVM定义的方式运行在其上。任何人都可以为所有权、交易格式和状态转换函数创建商业逻辑</p><h5 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h5><p>两类账户，公用一个空间地址。</p><p>外部账户，被密钥对控制。外部账户没有代码。用户通过创建和签名一笔交易从一个外部账户发送信息。</p><p>合约账户，被存储在账户中的代码控制。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取、写入、发送其他消息和创建合约。</p><p>以太坊的账户包含四个部分</p><ol><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码（如果有的话）</li><li>账户的存储（默认为空）</li></ol><h5 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h5><p>类似于比特币的交易，主要有3点不同：</p><ol><li>以太坊的消息可以由外部实体或者合约创建，比特币的交易只能从外部创建</li><li>以太坊消息可以选择包含数据</li><li>如果消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念</li></ol><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>指存储从外部账户发出的消息的签名数据包。<br>交易包含：</p><ol><li>消息的接受者</li><li>用于确认发送者的签名</li><li>以太币账户余额</li><li>要发送的数据</li><li>STARTGAS，通过需要支付的燃料来对计算步骤进行限制</li><li>GASPRICE，每一计算步骤需要支付给矿工的燃料</li></ol><h5 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h5><p>每笔交易都会被收取一定数量的Gas，其目的是限制交易执行所需要的工作量，同时为交易的执行支付费用。</p><h5 id="存储、主存和栈"><a href="#存储、主存和栈" class="headerlink" title="存储、主存和栈"></a>存储、主存和栈</h5><p>每个账户都有一块永久内存区域，成为存储，key-value形式。存储的读写开销比主存和栈大。合约只能对自己的存储进行读写。</p><p>第二个内存区叫主存，合约执行每次消息调用时都有一块新的被清除过的主存。</p><p>EVM不是基于寄存器的，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈的区域内执行。</p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><p>EVM指令集被可以保持在最小规模，以尽可能的避免可能导致共识问题的而错误。所有的指令都是针对256位这个基本的数据单位进行的操作，具备常用的算术、位、逻辑和比较操作还有条件跳转和无条件跳转。</p><p>此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。</p><h5 id="消息调用"><a href="#消息调用" class="headerlink" title="消息调用"></a>消息调用</h5><p>合约通过消息调用的方式来调用其他合约，或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源，目标，数据负载，以太币，Gas和返回数据。</p><p>事实上每个交易都可以被认为是一个顶层消息调用，这个消息调用会一次产生更多的消息调用。</p><h5 id="代码调用和库"><a href="#代码调用和库" class="headerlink" title="代码调用和库"></a>代码调用和库</h5><p>callcode是一种特殊的消息调用。加载来自目标地址的代码将在发起调用的合约上下文中运行。用来实现库。</p><h3 id="以太坊状态转换"><a href="#以太坊状态转换" class="headerlink" title="以太坊状态转换"></a>以太坊状态转换</h3><p>一个交易发生时，从一个状态转换到下一个状态</p><h3 id="以太坊客户端"><a href="#以太坊客户端" class="headerlink" title="以太坊客户端"></a>以太坊客户端</h3><p>go语言客户端Geth</p><p>客户端浏览器Mist</p><h1 id="以太坊智能合约"><a href="#以太坊智能合约" class="headerlink" title="以太坊智能合约"></a>以太坊智能合约</h1><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>由尼克萨博提出，几乎与互联网同龄。但一直没有可信的执行环境，以太坊首先实现了区块链和智能合约的完整契合。</p><p>以太坊这方面的特性有：</p><ol><li>图灵完备性</li><li>价值意识(value-awareness)</li><li>区块链意识(blockchain-awareness)</li><li>多状态<h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3>以太坊有四种专用语言：</li><li>Serpent(Python)</li><li>Solidity(Js)</li><li>Mutan(Go)</li><li>LLL(Lisp)</li></ol><p>图灵完备，可以解决所有的计算问题。但是半图灵完备，因为通过对计算量设置上限来避免图灵完备语言的无法停机的问题。</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>以太坊合约的代码是使用低级的基于堆栈的字节码的语言写成的。可以访问三种存储空间。</p><ol><li>堆栈</li><li>内存，可无限扩展的字节队列</li><li>合约的长期存储，一个秘钥/数值的存储<br>堆栈与内存计算结束就重置，长期存储会保持。<h1 id="以太坊的去中心化应用"><a href="#以太坊的去中心化应用" class="headerlink" title="以太坊的去中心化应用"></a>以太坊的去中心化应用</h1><h3 id="什么是Dapp"><a href="#什么是Dapp" class="headerlink" title="什么是Dapp"></a>什么是Dapp</h3>Dapp由智能合约和客户端代码构成。类似于后端和前端。智能合约跑在区块链上。</li></ol><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TDD笔记</title>
      <link href="/2017/12/21/TDD%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/TDD%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<pre><code>graph TD需求提出--&gt;抽象出模型抽象出模型--&gt;转化出测试用例转化出测试用例--&gt;TDD:定义接口测试接口抽象出模型--&gt;|not TDD|codeTDD:定义接口测试接口--&gt;提交PR并讨论提交PR并讨论--&gt;codecode --&gt;整合</code></pre><h2 id="自己写测试的心得"><a href="#自己写测试的心得" class="headerlink" title="自己写测试的心得"></a>自己写测试的心得</h2><p>普通写代码就是直接撸，写成啥是啥，错了就改<br>正确的写测试就是  先想好接口，根据接口来写测试用例，最后再写代码去通过测试<br>这就叫谋而后动</p><p>今天跟了一个测试教程<br>学会了测试语言describe it   before after(mocha)  expect(supettest)</p><h2 id="在egg中写测试"><a href="#在egg中写测试" class="headerlink" title="在egg中写测试"></a>在egg中写测试</h2><p>这是应用的单元测试，不是插件和框架的单元测试</p><p>内置的egg-bin模块，这个模块已经内置了所有测试所需要的好用的模块。<br>包括：Mocha、co-mocha、power-assert，istanbul<br>测试mock辅助模块egg-mock</p><h3 id="第一步，编写测试"><a href="#第一步，编写测试" class="headerlink" title="第一步，编写测试"></a>第一步，编写测试</h3><h4 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h4><h3 id="第二步-配置测试"><a href="#第二步-配置测试" class="headerlink" title="第二步 配置测试"></a>第二步 配置测试</h3><p>在==package.json==中配置==script.test==</p><pre><code class="js">{    &quot;scripts&quot;:{        &quot;test&quot;:&quot;egg-bin test&quot;    }}</code></pre><h3 id="第三步-启动测试"><a href="#第三步-启动测试" class="headerlink" title="第三步 启动测试"></a>第三步 启动测试</h3><pre><code class="js">npm test</code></pre><p><a href="https://zhuanlan.zhihu.com/p/24997923" target="_blank" rel="noopener">打开TDD的正确姿势</a></p><h2 id="TDD是什么"><a href="#TDD是什么" class="headerlink" title="TDD是什么"></a>TDD是什么</h2><p>tested dirven development,测试驱动开发</p><h2 id="TDD的核心"><a href="#TDD的核心" class="headerlink" title="TDD的核心"></a>TDD的核心</h2><p>做好需求分析和设计，将==需求==拆解</p><h2 id="为什么要测试，什么时候测试"><a href="#为什么要测试，什么时候测试" class="headerlink" title="为什么要测试，什么时候测试"></a>为什么要测试，什么时候测试</h2><p>因为错误不可避免，要排除错误减少损失<br>测试越早越好，因为错误绝大部分错误是在早期引入的，发现在中后期<br>错误造成的损失随着时间呈现指数级的增长，越早发现，成本越低。这是软件测试的作用</p><p>测试驱动开发的作用：测试是根据需求来的，测试用例就是各个需求点，只要通过测试，模块的行为就能确保正确。在修改的时候做测试也能确保没有修改出错误。</p><h2 id="测试的概念"><a href="#测试的概念" class="headerlink" title="测试的概念"></a>测试的概念</h2><p><strong>单元测试</strong>：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。就是该部分能否正常工作</p><p> <strong>测试用例</strong>：进行单元测试使用的例子</p><p>单元测试不通过说明要么有bug，要么测试用例不正确</p><p>测试正确说明，对该函数的修改没有对原来的行为造成影响。</p><p>测试驱动，是测试的什么？<br>测试个模块的接口<br>检验是否满足规定的需求，找出与预期的差异</p><h2 id="测试效果的指标"><a href="#测试效果的指标" class="headerlink" title="测试效果的指标"></a>测试效果的指标</h2><p>提高测试覆盖率，测试效率</p><h2 id="测试的误区"><a href="#测试的误区" class="headerlink" title="测试的误区"></a>测试的误区</h2><p>盲目追求覆盖率</p><h2 id="测试的工具"><a href="#测试的工具" class="headerlink" title="测试的工具"></a>测试的工具</h2><h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h3><p>mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。</p><p>使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。</p><p>mocha的特点主要有：</p><p>既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一；</p><p>可以自动运行所有测试，也可以只运行特定的测试；</p><p>可以支持before、after、beforeEach和afterEach来编写初始化代码。</p><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p>包裹it们</p><p>第一个参数是测试的名字</p><p>第二个参数是一个函数，函数里是it</p><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><p>是各个测试用例</p><p>第一个参数是测试用例的描述</p><p>第二个参数是一个函数，函数体就是测试的内容，assert们</p><h3 id="supertest"><a href="#supertest" class="headerlink" title="supertest"></a>supertest</h3><p>网络测试<br>构造请求，expect断言 判断回复</p><h3 id="node自带断言库-assert"><a href="#node自带断言库-assert" class="headerlink" title="node自带断言库 assert"></a>node自带断言库 assert</h3><h2 id="如何写好测试"><a href="#如何写好测试" class="headerlink" title="如何写好测试"></a>如何写好测试</h2><p>所有人都假设TDD以后软件质量一定提高到最高境界了，但是测试代码也是代码，也有合理不合理的问题，也有价值与维护成本，不好的测试代码会降低效率<br>那么如何写好测试代码呢</p><blockquote><p>测试的核心是“可测试“，可测试意味着好的代码架构，写出可测试代码是优良测试的必要条件。</p></blockquote><blockquote><p>测试驱动开发不是测试人员驱动。<br>这种开发方法完全是开发人员自行实施的，要点在于开发功能之前先开发该功能的测试程序，当然一开始测试程序的结果是失败的，然后去实现功能，让测试结果成功通过<br>测试驱动也不是测试驱动项目运转</p></blockquote><blockquote><p>因为国内大多数程序员写的代码粒度太粗，无法测试。</p></blockquote><p>编写测试的原则是，一次只测一种情况，且测试代码要非常简单。</p><h2 id="TDD和时间的关系"><a href="#TDD和时间的关系" class="headerlink" title="TDD和时间的关系"></a>TDD和时间的关系</h2><blockquote><p>如果时间够，自然可以TDD。如果时间不够，有人可以tdd，测试先行，不代表真的要先写测试。tdd像一种工具或者流程，其背后有它自己的思维，掌握了思维，没有按流程出招，或许就表示tdd已死了吧。如果楼主是指形式或者招式，那么其在某些情况下还是继续存活的。比如时间足够，而程序员足够热爱它</p></blockquote><blockquote><p>TDD只是一个概念，时间允许的话每个重要的方法业务都写单元测试，涉及正确性测试，边界测试，错误测试等等。之后代码有改动再跑单元测试就可以了。这样开发会节省挺多时间。</p></blockquote><p>和时间的关系，写测试要消耗时间<br>这是一个问题，很多公司的迭代周期比较短，比如半个月。那么如何搞TDD呢</p><h2 id="TDD的好处"><a href="#TDD的好处" class="headerlink" title="TDD的好处"></a>TDD的好处</h2><blockquote><p>TDD好处其实很简单：</p><ol><li>帮你整理需求</li><li>帮你设计接口（空想的话很容易设计出屎）</li><li>帮你做regression和给以后重构做准备</li></ol></blockquote><p>提高程序健壮性</p><blockquote><p>TDD会鼓励你对现有代码，更频繁，更敏捷地进行改变<br>它带给你的是，更少的regression，更少的debuggingtime，以及更多的勇气来refactor</p></blockquote><blockquote><p>是tdd重新让我编程的信心和乐趣。<br>我不爱用眼睛看检查运行结果，只要改动之后，一运行看到一长排的勾我就去冲杯香飘飘喝吧喝吧，喝了睡觉去了</p></blockquote><hr><blockquote><p>过度测试是存在。但一些看似过度的testmethod确实揪出了bug。国内中小公司(没去过大公司，不知道啥情况)从上到下对测试总是抗拒的态度。他们会迷惑如何在需求变更中控制缺陷，却不愿试着作任何改变。整天鼓吹熬夜搬砖的人是没法沟通的:(。所以总是测试不够，而非过度</p></blockquote><p>要会单元测试，没有deadline的威胁，就是时间要足够<br>适合思路发散常常迷糊的人，让人有安全感，能确定想法落实了<br>可以灵活一些，比较高层的feature在确保接口可测试的前提下，没必要完全tdd。</p><blockquote><p>TDD是否已死先不说，很多程序员连写出基本的整洁代码都做不到，还能指望他先写测试吗？写代码绝对是个技术活，而不是体力活。所以，写代码需要不断修炼，比如code dojo, code kata 至于是否用TDD方式写代码，倒不一定。如果程序员的思维转变，写代码之前先考虑到测试用例、测试场景，也是一个很大的转变，即测试先行。</p></blockquote><blockquote><p>我觉得TDD不火的原因是它对developer的素质要求非常高。新手看到TDD会欢欣鼓舞，但是他们没有能力来实践。老手们在项目的压力下，早就麻木了，先写case还不如写好代码再补case呢，很多东西我还没时间想清楚，怎么写case？不如先写个小功能先，边写边改，等稳定下来再补case. 所以对老手来说也需要不断练习，才能熟悉TDD.</p></blockquote><blockquote><p>其实我们的目的是为了快速的交付有价值，有质量的产品或者服务，赢得公司的生存和发展空间。为了达到这个目的，我们有很多种的手段。但手段不是目的。<br>有很多盲目推崇TDD的所谓敏捷专家，其实是把手段当做目的，而忽略了问题的本质</p></blockquote><blockquote><p>首先理清一个价值观问题，是方法论为生产力服务还是生产力为方法论服务<br>TDD的错误在于，他没有尊重程序员尊重开发实际，让非生产代码通知生产代码</p></blockquote><blockquote><p>TDD 力量和问题都源自 test first。要能 test first，写代码之前要想得更清楚；代码得要有良好的可测试性，而为了可测试性要做一些不直接产生效益的工作；两者都既能推动思考，也能限制思考。TDD 是正确的思想：程序员要保证代码的正确性，和不完美的实践：程序员写测试。</p></blockquote><blockquote><p>目前我们团队也在想办法推行TDD，但是不是标准的TDD，而仅仅是测试先行，并且不用mock这样做可以在实现业务代码之前对于自己的程序要实现什么有一个清晰的认识，而且写程序的过程也变成了“跑通我的单元测试”的过程，这样更加有目标和针对性，当你看到你写完的业务代码能跑通单元测试的时候，是否有种游戏过关的成就感呢？等到全员都逐渐适应这种测试先行的做法，再“得寸进尺”，多要求一点点。</p></blockquote><blockquote><p>测试先行，怎么和开发做交互呢？什么时间调用开发的方法？<br>测试先行是说在实现业务逻辑前先写完单元测试，此时的单元测试肯定不通，之后再逐渐针对测试完善业务代码，最后跑通测试的时候业务代码也就完成了。不是让测试人员先测的意思</p></blockquote><blockquote><p>TDD解决了：1）我要开始写代码了，我从哪开始。 搞个main，还是搞个test2）我不知道那个家伙的代码写的怎么样，以后会不会捅个篓子，要求他TDD好了。CodeReview的时候也轻松点。飞机上写几个小时代码，下来编译一遍过还没有bug的人。你跳出来说，他没有tdd，他LowB，那你是不是有毛病。总之一句话，各种方法论都是解决一个问题——人不行。</p></blockquote><blockquote><p>软件开发说到底还是抽象和逻辑的艺术，TDD只是一种辅助开发手段，并不会减少因为开发人员素质不过硬或者工期短赶工而在开发过程中产生的抽象和逻辑问题。从来没听说过历史上哪位编程高手是因为什么方法论而练成的，人家是数据结构、算法、抽象和逻辑能力真的强大。对了，除了TDD，那什么敏捷、XP、结对、DDD等等，所有抛开实际抽象和逻辑问题的方法论，都是垃圾。</p></blockquote><p>更重要的是  基础的是  数据结构算法  抽象  逻辑能力</p><blockquote><p>TDD在什么情况下最有效？</p><ol><li>一个老系统，</li><li>老系统有还不错的test case</li><li>有很多相关系统依赖老系统</li><li>老系统要推翻重做</li></ol></blockquote><blockquote><p>先阐明观点，TDD没死，只是存活着在一些技术及配合要求比较高的团队，并且是挑业务的。我在互联网行业摸打滚爬了蛮久，历经各种项目，包括PC、游戏、云存储、电商等项目，TDD也是我这几年年一直在推动的事情，大部分失败了，也有些收获，这里大致把所了解以及个人见解说下。拿我所熟悉的互联网行业来说吧，其他传统软件行业经历时间太早，离当前较远，就不乱说了。现在互联网大都流行敏捷开发，其模式大家可自行度娘，但是真正做到的貌似没有，最少我没见过或者听过，很难用定性的词语来形容（语文不好），用个相似度来说吧，当前BAT公司排序为BTA（还是个人见解），用我个人的说法就是作坊式开发，忽略很多流程，只留下骨干的评审、开发、用例评审、转测、回归发布的流程。这个模式特点就是快，从需求提出到发布上线，一般都是一两周的时间，现有三周才能开发完成的业务。当然这里也有提出异议，说我太片面了，不过我说的大部分的互联网公司业务，保守估计60%的比例吧。解释完了互联网公司的开发模式，接下来我们回到TDD，至于TDD的概念，我就不科普了，自行度娘。其中TDD有一个特点非常明确，基本上可以作为是否做到的标签。这就是测试架构先于开发完成，并可对开发完成大部分模块进行测试（个人的理解，标准定义自行百度）。为了达到这个目的，我们搬出几个要素出来：时间、人、效果、方式。时间：什么时候完成，项目时间大约多久可以做TDD，TDD占项目时间大约多少比例合适。人：谁来做，一个人的项目我这里不谈，只谈多人协作项目，开发做还是测试来做？效果：要达成什么效果，以什么为合格的TDD的指标，功能覆盖？代码覆盖率？方式：要怎么做，开发一套自动化框架，还是用先协商接口用单测来完成，这里特别要提出的是，需要考虑后期维护的代价。</p></blockquote><blockquote><p>TDD 推行的最大问题在于，大多数程序员还不会「写测试用例」和「重构」。<br>我认为推行TDD主要在两个方面努力，即意识和能力（好像任何事情都是这两方面哈）。意识方面主要是：认识到自己原有编程方法的不足；搞清楚TDD的价值所在，如何弥补原有方法的不足；心态开放，勇于尝试新鲜事物，不要浅尝辄止，要持续改进。意识和能力没有先后关系，而是在不断学习和实践过程中同时提高。在这篇文章中，我更想谈的是能力。我见到初接触TDD的人常犯下面的错误：在声明测试方法后，便开始写实现代码；写完“所有”的测试代码才开始写实现；一次实现过多的代码（超出当前测试覆盖的业务）；从不重构；测试实现细节而不是接口行为；TDD真是看起来容易，做起来难。</p></blockquote><pre><code>graph LRRed--&gt;GreenGreen--&gt;RefactorRefactor--&gt;Red</code></pre><blockquote><p>上面这个图一目了然，但其实每一步都是对能力有要求的：红测试先行并不是说不需要思考，直接开始写代码。在开始写代码之前要进行需求分析，将需求分解为任务列表，再从列表中挑选一个任务，转换成一组测试用例，然后不断循环去实现。测试代码其实是产品代码的“用户”，在写测试代码时你就要考虑如何“使用”产品代码，是一个实例方法还是一个类方法，是从构造函数传参还是从方法调用传参，方法的命名，返回值等。这时其实我们就是在做设计，而且设计以代码来体现，比在脑袋中空想要更直观。很多人不懂“意图式编程”，总是习惯先实现一个东西，再去调用它。而测试先行就要求先使用，再实现。这样能少走很多弯路，减少返工。无法把测试前置的原因往往在于，测试的是「实现」，也就是你写的是「白盒」测试。这样的测试根本没有价值，重构的时候会成为维护负担。而好的做法是测试「做什么」，而不是「怎么做」。绿以最快的速度让测试变绿，意味着我们通常用最直接但可能并不优雅的方式，比如复制代码。然后小步重构，直到符合简单设计的原则：通过所有测试每个概念都被清楚地表达没有重复没有多余的东西难的是要让实现刚好满足当前的测试，不做过度的设计，不写多余的代码。因为如果你写多了，除了引入复杂性以外，多的那部分就没有测试能覆盖到。或者你后面的测试写出来就能直接变绿，你就没办法按TDD的节奏进行下去了。重构首先要能识别坏味道，一些低级的Smell，很容易识别，比如：Magic Number，重复代码，太大的类，太长的方法，命名等。但更高级的如Feature Envy，Lazy Class等就比较难以识别。只要识别到Smell，知道用什么手法去重构，剩下的就比较简单了，现代的IDE，尤其是JetBrains的产品，对重构的支持非常强大，几乎都可以用快捷键完成。选对工具非常重要，善假于物能极大提高开发效率。但也不能过分依赖工具，要明白每一个手法背后的原理。所以推荐每个想要实践TDD的开发者，一定要先读《重构》。最后我想说：TDD不是银弹，不可能适合所有的场景，但这不应该成为我们拒绝它的理由。也不要轻易否定TDD，如果要否定，起码要在认真实践过之后。</p></blockquote><h1 id="TDD教程"><a href="#TDD教程" class="headerlink" title="TDD教程"></a>TDD教程</h1><p>总览</p><p>TDD的理解和讲解</p><p>基线描述</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态<br>掌握mock技巧，能够讲出几种mock的场景<br>了解SetUp的作用<br>会写TestCase<br>给出题目可以驱动着写出来<br>细节如下：</p><p>能够讲出来科学的TDD步骤，和TDD的三个主要的状态</p><p>正确的TDD的步骤至少包含下面的几个点，写一个TestCase，运行，得到期望的失败，写实现，重构</p>]]></content>
      
      <categories>
          
          <category> 程序员修养 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基础数据结构</title>
      <link href="/2017/12/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/12/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>数据结构，数据存储的方法，包括数据对象，和操作集，不包括具体实现。具体实现是算法</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>检索简单，增删难</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Set，不重复的数组</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>增删简单，检索难。插入删除内存和时间消耗小，查询消耗大，适合插入多，查询少的情景</p><p>广义表：是线性表的推广，元素可以是另一个广义表</p><p>多重链表：节点可能属于多个链表，双向链表不是多重链表。树和图就是用多重链表实现</p><p>稀疏矩阵用多重链表存储。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>先进后出</p><p>表达式求值，递归，函数调用，深度优先搜索，回溯算法</p><p>具有一定操作约束的线性表</p><h5 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h5><p>一维数组和一个记录栈顶元素位置的变量</p><p>链表实现，从头部插入</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>也是一种受限制的线性表，先进先出</p><p>普通线性表在所有位置都可以增删，堆栈只在顶部增删，队列只在头尾增删</p><p>用链表实现的时候，因为链表的尾部不能执行删除操作，所以队列的头部只能是链表的头部</p><h5 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h5><ol><li>优先队列</li><li>循环队列</li></ol>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法笔记</title>
      <link href="/2017/12/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h3 id="计算时间复杂度的方法"><a href="#计算时间复杂度的方法" class="headerlink" title="计算时间复杂度的方法"></a>计算时间复杂度的方法</h3><p>数循环次数：循环的嵌套</p><p>均摊分析：(1+n)/2，一次性的操作平均到整体</p><p>递归式:主定理</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p>1:基本运算，+,-,*,/,%,寻址</p><p>logn：二分查找</p><p>根号n:枚举约数，少见</p><p>n:线性查找，很多时候算法的下限就是n，因为数据的读入的复杂度就已经是n了</p><p>nlogn：归并排序，快速排序的期望复杂度，基于比较排序的算法下界</p><hr><p>n的平方：朴素最近点对，冒泡排序，选择排序</p><p>n的三次方：Floyd最短路径，普通矩阵乘法</p><p>2的n次方：枚举全部的子集</p><p>n的阶乘：枚举全排列</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1>]]></content>
      
      <categories>
          
          <category> 程序员修养 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>cs总结</title>
      <link href="/2017/12/21/cs%E6%80%BB%E7%BB%93/"/>
      <url>/2017/12/21/cs%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="熟悉"><a href="#熟悉" class="headerlink" title="熟悉"></a>熟悉</h3><pre><code class="coffeescript"># 列表解析result = (item.value for item in array when item.name is &#39;test&#39;)# 前十个全局属性(变量)globals = (name for name of window)[0...10]# 对象解析ages = for key, value of Object  &quot;#{key} is #{value}&quot;# 定义函数square = (x) -&gt;  x * x  # body...  # 定义的时候有括号，调用的时候没括号# 数组song = [  &#39;do&#39;  &#39;re&#39;  &#39;mi&#39;  &#39;fa&#39;  &#39;so&#39;]# 对象singers =  brother:    name:&#39;max&#39;    age:11  sister:    name:&#39;ida&#39;    age:9    s-sister:      name:&#39;haha&#39;      age:2# if elseif one and/or/is/not two  # body...else  # body...# 三元判断date = if one and two then value else other# 函数链式调用$ &#39;body&#39;.click (e) -&gt;  $ &#39;.box&#39;  .fadeIn &#39;fast&#39;  .addClass &#39;show&#39; .css &#39;background&#39;, &#39;white&#39;# 回调写法和胖箭头函数Account = (customer,cart) -&gt;  @customer = customer  @cart = cart  $(&#39;.shapping_cart&#39;)  .on &#39;click&#39;, (event) =&gt;    @customer.purchase @cart# promise写法sleep = (ms) -&gt;  new Promise (resolve) -&gt;    window.setTimeout resovle,ms# async写法直接写在普通函数里，阻塞的执行# 类的写法class Animal  constructor: (@name) -&gt;  move:(meters) -&gt;    alert @name + &quot; moved #{meters}m.&quot;    # body...</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>编译命令，</p><pre><code>coffee -c -o targetfolder filename</code></pre><p>先是两个参数，然后是目标文件夹，最后是编译的文件</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>数组换行可以省略一个逗号，那就都换行吧，彻底抛弃逗号</li><li>直接加尾巴截取数组，还可以直接用来赋值<pre><code>[0...10]</code></pre></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ol><li>对象的花括号用缩进代替</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的区别，</p><ol><li>定义的时候有括号，调用的时候没括号,调用的时候没有参数也需要括号</li><li>函数没有大括号，用箭头识别，箭头左边小括号里放参数，右边是函数体</li><li>函数默认返回函数体最后一个表达式的值，可以省略return</li><li>空return取消return</li><li>变量不需要声明，所以函数名也不需要声明</li><li>默认参数</li><li>胖箭头函数，作用只是绑定this？ 需要返回一个绑定this的函数的时候使用</li></ol><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p>直接把await写在普通函数里</p><h3 id="词法作用域和变量安全"><a href="#词法作用域和变量安全" class="headerlink" title="词法作用域和变量安全"></a>词法作用域和变量安全</h3><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><h4 id="变量安全"><a href="#变量安全" class="headerlink" title="变量安全"></a>变量安全</h4><ol><li>函数的所有 CoffeeScript 结果都被一个匿名函数包裹</li></ol><pre><code>(function(){ ... })();</code></pre><p>这层安全的封装, 加上自动生成的 var 关键字,使得不小心污染全局命名空间很难发生.</p><ol><li>因为被包裹了，用顶层变量, 需要将其作为赋值在 window 上, 或者在 CommonJS 里的 exports 上.</li><li>存在操作符(existential operator)可以帮你写出一个可靠的方式找到添加位置; 比如你的目标是同时满足 CommonJS 和浏览器: exports ? this<br>4.</li></ol><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><ol><li>一个判断一个赋值的判断简写</li></ol><pre><code>name = value if condition</code></pre><ol><li>普通写法,和js相比就是省略了条件的小括号和函数体的大括号</li><li>三元判断符</li></ol><pre><code>name = if condition then rightvalue else wrongvalue</code></pre><ol><li>unless: 不是… ，就执行，是就跳过</li></ol><pre><code>return 哈哈哈 unless 嘿嘿嘿//如果不是嘿嘿嘿，就返回哈哈哈//如果是嘿嘿嘿，就跳过往下执行//作用：满足嘿嘿嘿才能往下执行//干嘛不用if？</code></pre><p>if else 和unless都可以，看个人喜好</p><h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>变参函数定义,参数后加上…</p><p>变参函数调用,函数调用后加上…</p><h3 id="循环和推导式"><a href="#循环和推导式" class="headerlink" title="循环和推导式"></a>循环和推导式</h3><h4 id="for-in遍历数组"><a href="#for-in遍历数组" class="headerlink" title="for in遍历数组"></a>for in遍历数组</h4><pre><code>item-operation for item in 数组</code></pre><p>两个参数</p><pre><code>for in 循环的参数，第一个是值，i是index</code></pre><p>加上判断</p><pre><code>item-operation for item in 数组 when item isnt value</code></pre><p>by控制循环的跨度</p><h4 id="for-of-遍历对象"><a href="#for-of-遍历对象" class="headerlink" title="for of 遍历对象"></a>for of 遍历对象</h4><pre><code>#遍历所有键值对ages = for key,value of yearsOld  &quot;#{child is #{age}&quot;#遍历自有非继承键值对for own key,value of yearsOld#遍历gegerator用from</code></pre><h4 id="while和until"><a href="#while和until" class="headerlink" title="while和until"></a>while和until</h4><pre><code># 满足条件就一直执行buy() while supply &gt; demand# 满足条件就不执行了sell() until supply &gt; demand</code></pre><h4 id="for-in-do"><a href="#for-in-do" class="headerlink" title="for in + do"></a>for in + do</h4><p>配合起来，对每一个满足条件的元素执行操作</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><table><thead><tr><th>CoffeeScript</th><th>JavaScript</th></tr></thead><tbody><tr><td>is</td><td>===</td></tr><tr><td>isnt</td><td>!==</td></tr><tr><td>not</td><td>!</td></tr><tr><td>and</td><td>&amp;&amp;</td></tr><tr><td>or</td><td></td></tr><tr><td>ture,yes,on</td><td>true</td></tr><tr><td>false,no,off</td><td>false</td></tr><tr><td>@,this</td><td>this</td></tr><tr><td>a in b</td><td>[].indexOf.call(b,a) &gt;=0</td></tr><tr><td>a of b</td><td>a in b</td></tr><tr><td>for a form b</td><td>for (a of b)</td></tr><tr><td>a ** b</td><td>Math.pow(a,b)</td></tr><tr><td>a // b</td><td>Math.floor(a/b)</td></tr><tr><td>a %% b</td><td>(a % b + b) % b</td></tr></tbody></table><h3 id="存在性操作符"><a href="#存在性操作符" class="headerlink" title="存在性操作符"></a>存在性操作符</h3><pre><code>?name# 只要不是null或者undefined就返回truespeed ?= 15# 当speed为null或者undefined的时候执行赋值</code></pre><h1 id="自己的总结"><a href="#自己的总结" class="headerlink" title="自己的总结"></a>自己的总结</h1><ol><li>没有冒号</li><li>没有括号，用换行和缩进控制层级</li><li>数组的省略写法</li><li>编译之后给module.exports外面套一层自执行函数对导出模块没有影响</li><li>if判断里面没有默认return</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>控制返回值，不想让它包裹一层然后返回，可以写<br>return 那么对async函数有影响</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://cnodejs.org/topic/53a64eb1c3ee0b5820b20863" target="_blank" rel="noopener">coffeescript编码风格指南</a></p><h1 id="不喜欢的地方"><a href="#不喜欢的地方" class="headerlink" title="不喜欢的地方"></a>不喜欢的地方</h1><ol><li>关于语义化的思考</li><li>调用函数的时候，前面一个参数较复杂，后面一个参数需要仔细辨别，没有括号直观<br>3.</li></ol>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计需求分析与方案选择</title>
      <link href="/2017/12/21/%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/"/>
      <url>/2017/12/21/%E8%AE%BE%E8%AE%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9/</url>
      <content type="html"><![CDATA[<p>设计师的基本思路是，解决了什么问题，为什么要这样解决</p><p>了解问题比提供解决方案重要</p><h3 id="设计方案不能令人满意的原因"><a href="#设计方案不能令人满意的原因" class="headerlink" title="设计方案不能令人满意的原因"></a>设计方案不能令人满意的原因</h3><ol><li>没有细致的沟通==业务需求==，一直改方案，没有自己的观点</li><li>没有仔细的分析==用户需求==，只是简单的进行页面排版</li><li>没有对==用户体验路径==进行仔细分析，缺乏一个好的方式引导用户使用</li></ol><h4 id="业务需求-业务目的-业务目标"><a href="#业务需求-业务目的-业务目标" class="headerlink" title="业务需求 = 业务目的 + 业务目标"></a>业务需求 = 业务目的 + 业务目标</h4><p>业务目的：为什么要做这块业务，当中存在哪些问题<br>业务目标：做了这块业务之后，产品期望得到怎样的结果</p><h4 id="用户需求-目标用户（特征、经验）-场景-行为-体验目标"><a href="#用户需求-目标用户（特征、经验）-场景-行为-体验目标" class="headerlink" title="用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标"></a>用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标</h4><p>谁在什么时候有什么样的行为，目标是什么</p><h4 id="用户体验路径"><a href="#用户体验路径" class="headerlink" title="用户体验路径"></a>用户体验路径</h4><p>搞清楚用户在使用前，使用中，使用后的各个接触点，确保设计方案能够形成闭环</p><h1 id="需求分析四步"><a href="#需求分析四步" class="headerlink" title="需求分析四步"></a>需求分析四步</h1><h2 id="一-分析业务需求"><a href="#一-分析业务需求" class="headerlink" title="一 分析业务需求"></a>一 分析业务需求</h2><p>业务需求 = 业务目的 + 业务目标<br>业务目的：为什么要做这块业务，当中存在哪些问题<br>业务目标：做了这块业务之后，产品期望得到怎样的结果</p><p>目的是达到了某个目标之后想要做的事情，也就是实现目标的真正动机</p><p>例：</p><table><thead><tr><th>业务需求</th><th>业务目的</th><th>业务目标</th></tr></thead><tbody><tr><td>注册</td><td>通过登记用户信息，以方便产品进行用户管理</td><td>提高注册页面的转化率</td></tr></tbody></table><p>提供用户注册是一个业务需求，提高注册转化率是它的业务目标。当我们提高了注册转化率，就能获得更多的注册用户数，从而实现有效进行用户管理的目的。</p><h3 id="互联网产品常见的目标（提升-降低）"><a href="#互联网产品常见的目标（提升-降低）" class="headerlink" title="互联网产品常见的目标（提升/降低）"></a>互联网产品常见的目标（提升/降低）</h3><table><thead><tr><th>类别</th><th>常见目标</th></tr></thead><tbody><tr><td>产品类</td><td>PV，UV，用户数，转化率，留存率，活跃度等等</td></tr><tr><td>市场类</td><td>传播量，市场份额，各种排名等</td></tr><tr><td>品牌类</td><td>服务认知，品牌认知，品牌忠诚度等等</td></tr><tr><td>营收类</td><td>销售量，销售额，利润率，ROI等等</td></tr></tbody></table><h3 id="制定具体的目标时，要符合smart原则"><a href="#制定具体的目标时，要符合smart原则" class="headerlink" title="制定具体的目标时，要符合smart原则"></a>制定具体的目标时，要符合smart原则</h3><p>S:specific，具体<br>M:measurable，可衡量<br>A:attainable，可实现<br>R:relevant，有关联<br>T:time-based，有时限</p><h3 id="没有目标导致的结果"><a href="#没有目标导致的结果" class="headerlink" title="没有目标导致的结果"></a>没有目标导致的结果</h3><ol><li>方案的讨论容易发散</li><li>方案的评估缺乏评判标准</li><li>方案的效果无法衡量<br>4.</li></ol><h3 id="了解目的和目标之后"><a href="#了解目的和目标之后" class="headerlink" title="了解目的和目标之后"></a>了解目的和目标之后</h3><h2 id="二-分析用户需求"><a href="#二-分析用户需求" class="headerlink" title="二 分析用户需求"></a>二 分析用户需求</h2><p>用户需求= 目标用户（特征、经验）+ 场景 + 行为 + 体验目标<br>谁在什么时候有什么样的行为，目标是什么</p><h2 id="三-分解关键因素"><a href="#三-分解关键因素" class="headerlink" title="三 分解关键因素"></a>三 分解关键因素</h2><p>用户的动机，担忧，障碍</p><p>实现业务目标的关键因素</p><ol><li>创造动机，促进用户行为</li><li>排除担忧，排除行为前的担忧</li><li>解决障碍，解决行为中的障碍</li></ol><h2 id="四-归纳设计需求，明确设计策略"><a href="#四-归纳设计需求，明确设计策略" class="headerlink" title="四 归纳设计需求，明确设计策略"></a>四 归纳设计需求，明确设计策略</h2><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>将业务目标，用户目标转化成有效的解决方案</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>如何将==业务目标==转化为==用户行为==，即通过引导用户的使用来帮助产品实现目标</p><p>从设计==用户行为==到设计==用户界面==：<br>用户行为决定了用户界面，用户界面页导致了用户会出现什么样的行为</p><h3 id="如何选择解决方案"><a href="#如何选择解决方案" class="headerlink" title="如何选择解决方案"></a>如何选择解决方案</h3>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用户调研思考</title>
      <link href="/2017/12/21/%E7%94%A8%E6%88%B7%E8%B0%83%E7%A0%94%E6%80%9D%E8%80%83/"/>
      <url>/2017/12/21/%E7%94%A8%E6%88%B7%E8%B0%83%E7%A0%94%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>拿到小房东手里的房源信息</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>让更多的小房东使用我们的房屋租赁管理工具</p><h1 id="问题-远一点"><a href="#问题-远一点" class="headerlink" title="问题 远一点"></a>问题 远一点</h1><p>这是一个怎样的市场</p><p>市场上的房子是什么样的？种类及比例</p><p>市场上的房东是什么样的？种类及比例</p><p>市场上的租客是什么样的？种类及比例</p><p>未来几年内，房子，房东，租客又是什么样的？</p><h1 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户"></a>目标用户</h1><p>手里有几套房的，自己运营的房东</p><p>这群人有多少？他们有多少房？直接决定我们能做成多大的平台。</p><p>个体户足够多才能形成平台，平台足够大才能吸引大房东。</p><p>了解这样的个体户。</p><h2 id="问题-近"><a href="#问题-近" class="headerlink" title="问题 近"></a>问题 近</h2><h4 id="我们的目标用户是什么样的人？"><a href="#我们的目标用户是什么样的人？" class="headerlink" title="我们的目标用户是什么样的人？"></a>我们的目标用户是什么样的人？</h4><p>手里有房子需要租出去的人</p><h4 id="我们的功能"><a href="#我们的功能" class="headerlink" title="我们的功能"></a>我们的功能</h4><p>帮助所有需要把房租出去的人解决问题</p><h4 id="他们的数量"><a href="#他们的数量" class="headerlink" title="他们的数量"></a>他们的数量</h4><p>这决定了我们的平台第一阶段能够有多大</p><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><ol><li>一房东，二房东</li><li>业余，全职</li><li>房子少，房子多</li><li>个人，团队</li><li>用过工具，没用过工具</li><li>学习能力强，不强</li></ol><p>使用设备</p><p>常用APP</p><p>痛点，品牌偏好</p><p>不同的产品，用来描述用户的角度有所不同，即用户画像的内容纬度会有所不同</p><p>==场景故事== 时间，地点，干什么</p><p>一般会有3~6个用户</p><p>==用户画像==：<br>通过用户的目标，行为，观点，基本信息等，对其真实特征进行勾勒，一般会得到3~6个画像/人物角色，每个画像代表一群真实的人</p><p>就像小说里的角色，都是作者观察生活总结出来的典型</p><p>画像之后调研比例，形成定量用户画像</p><h4 id="他们的日常生活"><a href="#他们的日常生活" class="headerlink" title="他们的日常生活"></a>他们的日常生活</h4><h4 id="对于工具的需求如何？"><a href="#对于工具的需求如何？" class="headerlink" title="对于工具的需求如何？"></a>对于工具的需求如何？</h4><h4 id="面向小房东的管理工具？"><a href="#面向小房东的管理工具？" class="headerlink" title="面向小房东的管理工具？"></a>面向小房东的管理工具？</h4><h4 id="房屋租赁管理的基本需求"><a href="#房屋租赁管理的基本需求" class="headerlink" title="房屋租赁管理的基本需求"></a>房屋租赁管理的基本需求</h4><h4 id="我们的工具能在多大程度上帮助他们"><a href="#我们的工具能在多大程度上帮助他们" class="headerlink" title="我们的工具能在多大程度上帮助他们"></a>我们的工具能在多大程度上帮助他们</h4><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一个4.6万亿的市场。有前景。</p>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用研笔记</title>
      <link href="/2017/12/21/%E7%94%A8%E7%A0%94%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/21/%E7%94%A8%E7%A0%94%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="用户研究概述"><a href="#用户研究概述" class="headerlink" title="用户研究概述"></a>用户研究概述</h1><p>==用户研究员的能力==，技术技能和非技术技能</p><h2 id="技术技能"><a href="#技术技能" class="headerlink" title="技术技能"></a>技术技能</h2><ol><li>用户研究能力</li><li>人机交互能力</li><li>产品分析能力</li></ol><h3 id="一，用户研究能力"><a href="#一，用户研究能力" class="headerlink" title="一，用户研究能力"></a>一，用户研究能力</h3><p>针对产品开发的不同阶段，能够灵活运用各种调研方法，权衡利弊，制定适合的用户研究方案</p><p>能够输出高质量的用户调研报告，为产品设计提出合理化建议</p><p>用户研究能力包括：</p><ol><li>定量分析能力</li><li>定性分析能力</li></ol><h4 id="定量分析能力："><a href="#定量分析能力：" class="headerlink" title="定量分析能力："></a>定量分析能力：</h4><ol><li>数据的敏感度</li><li>数据分析能力</li><li>可熟练使用各类定量研究方法</li><li>掌握各类定量研究方法的应用场景及优缺点</li><li>独立完成分析的能力</li></ol><h4 id="定性分析能力："><a href="#定性分析能力：" class="headerlink" title="定性分析能力："></a>定性分析能力：</h4><ol><li>对常见定性研究方法，可熟练使用</li><li>对各个研究方法有自己的心得体会，掌握技巧</li><li>掌握各类定性研究方法的应用场景及优缺点</li><li>独立执行研究的能力</li></ol><h3 id="二，人机交互能力"><a href="#二，人机交互能力" class="headerlink" title="二，人机交互能力"></a>二，人机交互能力</h3><ol><li>熟练掌握人机交互的理论知识</li><li>熟悉掌握各终端设计规范</li><li>有良好的用户体验意识</li><li>可通过用户研究，发现产品设计中的不足，并能提供设计改善建议</li></ol><h3 id="三，产品分析能力"><a href="#三，产品分析能力" class="headerlink" title="三，产品分析能力"></a>三，产品分析能力</h3><ol><li>对所应聘行业非常了解，有充分准备</li><li>对所应聘行业的竞品非常熟悉</li><li>对所应聘部门的产品非常熟悉，并有自己的见解</li><li>有良好的产品感</li><li>热爱互联网产品，对于新兴产品有好奇心，保持对互联网产品的关注和体验</li></ol><h2 id="非技术技能"><a href="#非技术技能" class="headerlink" title="非技术技能"></a>非技术技能</h2><ol><li>沟通技巧</li><li>好奇心</li><li>学习能力</li><li>敏锐力</li></ol><h1 id="用户研究方法论"><a href="#用户研究方法论" class="headerlink" title="用户研究方法论"></a>用户研究方法论</h1><p>工作中会用到的知识与技能</p><h3 id="一，基本研究方法"><a href="#一，基本研究方法" class="headerlink" title="一，基本研究方法"></a>一，基本研究方法</h3><ol><li>研究设计，采集工具</li><li>数据的获取：外部数据，内部数据</li></ol><h3 id="二，统计学知识"><a href="#二，统计学知识" class="headerlink" title="二，统计学知识"></a>二，统计学知识</h3><ol><li>基础统计方法</li><li>高级统计学方法</li><li>数据挖掘（了解，可拓展学习）</li></ol><h4 id="基础统计分析"><a href="#基础统计分析" class="headerlink" title="基础统计分析"></a>基础统计分析</h4><h5 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>集中趋势</li><li>离散趋势</li><li>分布特征</li><li>推论统计</li><li>相关分析</li></ol><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>日常数据的初步加工分析</li><li>简单分析变量间关系</li><li>需要快速输出结果</li><li>进行简单分析</li></ol><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>用研岗要求掌握，相关岗位建议掌握</p><h4 id="高级统计方法"><a href="#高级统计方法" class="headerlink" title="高级统计方法"></a>高级统计方法</h4><h5 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>聚类</li><li>回归</li><li>主成分</li><li>因子分析</li><li>判别分析</li><li>对应分析</li><li>多维尺度分析</li><li>生存分析</li><li>路径分析</li><li>结构方程</li></ol><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>对数据进行深挖掘和分析</li><li>分析变量间的关系</li><li>趋势预测，用户细分等</li></ol><h5 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h5><p>用研岗要求掌握，相关岗位了解</p><h4 id="数据挖掘方法"><a href="#数据挖掘方法" class="headerlink" title="数据挖掘方法"></a>数据挖掘方法</h4><h5 id="主要方法-2"><a href="#主要方法-2" class="headerlink" title="主要方法"></a>主要方法</h5><ol><li>神经网络</li><li>决策树</li></ol><h5 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h5><ol><li>可实现实时，自动化分析</li><li>具备自适应和自学习性</li></ol><h5 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h5><p>拓展学习</p><h3 id="三，数据分析思路及框架"><a href="#三，数据分析思路及框架" class="headerlink" title="三，数据分析思路及框架"></a>三，数据分析思路及框架</h3><ol><li>常用的分析框架</li><li>基于理论的分析模型</li></ol><p>比如：</p><ol><li>宏观的行业分析框架</li><li>微观的分析用户需求</li><li>用户满意度</li><li>品牌认知</li><li>转化</li><li>留存的分析框架</li></ol><h3 id="四，分析工具及软件"><a href="#四，分析工具及软件" class="headerlink" title="四，分析工具及软件"></a>四，分析工具及软件</h3><ol><li>Excel</li><li>SPSS，专业数据分析软件，比Excel高阶</li><li>SPSS modeler， R语言， Amos（拓展学习），LISREL，Python</li></ol><h3 id="五，图表制作"><a href="#五，图表制作" class="headerlink" title="五，图表制作"></a>五，图表制作</h3><ol><li>基本图表制作</li><li>数据可视化</li></ol><h3 id="六，报告撰写及演示"><a href="#六，报告撰写及演示" class="headerlink" title="六，报告撰写及演示"></a>六，报告撰写及演示</h3><ol><li>PPT制作，演讲能力</li></ol><h3 id="七，行业及业务领域知识"><a href="#七，行业及业务领域知识" class="headerlink" title="七，行业及业务领域知识"></a>七，行业及业务领域知识</h3><h4 id="行业领域知识"><a href="#行业领域知识" class="headerlink" title="行业领域知识"></a>行业领域知识</h4><p>互联网，垂直细分行业知识</p><h4 id="业务相关知识"><a href="#业务相关知识" class="headerlink" title="业务相关知识"></a>业务相关知识</h4><ol><li>产品经理</li><li>设计</li><li>运营</li><li>市场营销相关知识</li></ol><h4 id="专业知识"><a href="#专业知识" class="headerlink" title="专业知识"></a>专业知识</h4><ol><li>用户体验</li><li>经济学</li><li>心理学</li><li>社会学</li><li>市场营销等</li></ol><h3 id="八，数据洞察和落地"><a href="#八，数据洞察和落地" class="headerlink" title="八，数据洞察和落地"></a>八，数据洞察和落地</h3><ol><li>通过数据给出有用的建议</li><li>落地跟进</li></ol><h1 id="用户定位与需求分析"><a href="#用户定位与需求分析" class="headerlink" title="用户定位与需求分析"></a>用户定位与需求分析</h1><h2 id="用户研究的‘用户’是谁？"><a href="#用户研究的‘用户’是谁？" class="headerlink" title="用户研究的‘用户’是谁？"></a>用户研究的‘用户’是谁？</h2><h3 id="用户的定义"><a href="#用户的定义" class="headerlink" title="用户的定义"></a>用户的定义</h3><p>狭义的用户：产品的使用者</p><p>广义的用户还有业务方</p><p>用户研究的意义</p><pre><code>graph TDa((业务方-所服务产品))--&gt;b((用户研究-桥梁))b--&gt;c((用户方-产品的目标用户))</code></pre><p>不是简单的将用户的需求告诉业务方，而是要考虑业务方为什么要提供这个产品/功能</p><p>业务方也是有需求的</p><p>了解双方的需求</p><h1 id="测试评估提升用户体验"><a href="#测试评估提升用户体验" class="headerlink" title="测试评估提升用户体验"></a>测试评估提升用户体验</h1><h3 id="用户体验优化设计"><a href="#用户体验优化设计" class="headerlink" title="用户体验优化设计"></a>用户体验优化设计</h3><p>目的&amp;内容：使产品更好用易用，产生更大的用户价值</p><h3 id="生命是数据分析"><a href="#生命是数据分析" class="headerlink" title="生命是数据分析"></a>生命是数据分析</h3><h3 id="案例分析：数据分析如何驱动体验优化"><a href="#案例分析：数据分析如何驱动体验优化" class="headerlink" title="案例分析：数据分析如何驱动体验优化"></a>案例分析：数据分析如何驱动体验优化</h3><h1 id="用户分群与追踪研究"><a href="#用户分群与追踪研究" class="headerlink" title="==用户分群与追踪研究=="></a>==用户分群与追踪研究==</h1><p>用户行为来自于用户动机（目标）</p><p>用户使用我们的产品（用户行为）产生用户态度</p><p>当前时间点下的用户情况</p><h2 id="用户画像例子，考霸族"><a href="#用户画像例子，考霸族" class="headerlink" title="用户画像例子，考霸族"></a>用户画像例子，考霸族</h2><h3 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h3><ol><li>人生阶段：毕业生</li><li>自驱力：强</li></ol><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>姓名，职业，年龄，家庭状况，互联网使用习惯</p><h3 id="个性特征"><a href="#个性特征" class="headerlink" title="个性特征"></a>个性特征</h3><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><h3 id="学习习惯"><a href="#学习习惯" class="headerlink" title="学习习惯"></a>学习习惯</h3><h3 id="付费经历及态度"><a href="#付费经历及态度" class="headerlink" title="付费经历及态度"></a>付费经历及态度</h3><h2 id="用户画像方法简介"><a href="#用户画像方法简介" class="headerlink" title="用户画像方法简介"></a>用户画像方法简介</h2><ol><li>定性用户画像，简单快速</li><li>定量用户画像</li><li>方法选择的原则</li></ol><h3 id="选择定性还是定量"><a href="#选择定性还是定量" class="headerlink" title="选择定性还是定量"></a>选择定性还是定量</h3><p>取决于</p><ol><li>用户画像的受众是谁？设计师?产品经理？</li><li>希望用户画像结果来支持什么类型的决定</li><li>打算花多少时间和钱</li></ol><h2 id="用户画像的特点"><a href="#用户画像的特点" class="headerlink" title="用户画像的特点"></a>用户画像的特点</h2><ol><li>越早越好，方向准确比行动重要</li><li>任何阶段都可以，任何阶段都有用，迟到比旷工好</li><li>不断迭代更新，用户会变化</li></ol><h1 id="从用户研究到商业分析"><a href="#从用户研究到商业分析" class="headerlink" title="从用户研究到商业分析"></a>从用户研究到商业分析</h1><p>用户研究为什么要学习商业分析</p><h3 id="产品人要具有大局观"><a href="#产品人要具有大局观" class="headerlink" title="产品人要具有大局观"></a>产品人要具有大局观</h3><p>理解用户只是基础，最终的目的都是创造商业价值，所以要懂商业分析</p><h3 id="商业与用户价值的平衡"><a href="#商业与用户价值的平衡" class="headerlink" title="商业与用户价值的平衡"></a>商业与用户价值的平衡</h3><p>豆瓣：过于重视用户体验而轻视商业发展</p><p>百度：过于重视商业发展而忽视用户体验</p><p>微信：取得用户体验和商业价值的平衡</p><p>在==正确的时机==找到产品在==商业价值和用户体验间的平衡点==至关重要</p><p>商业价值和用户价值的平衡就是</p><p>产品诉求和用户诉求的平衡</p><p>一名成功的用户研究员，需要研究和考量外部市场因素，驱动产品在商业价值和用户体验中取得平衡点</p><h3 id="创业公司中人员配置的不完备"><a href="#创业公司中人员配置的不完备" class="headerlink" title="创业公司中人员配置的不完备"></a>创业公司中人员配置的不完备</h3>]]></content>
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
